{"version":3,"sources":["../../../src/folders/hooks/ensureSafeCollectionsChange.ts"],"sourcesContent":["import { APIError, type CollectionBeforeValidateHook, type CollectionSlug } from '../../index.js'\nimport { extractID } from '../../utilities/extractID.js'\nimport { getTranslatedLabel } from '../../utilities/getTranslatedLabel.js'\n\nexport const ensureSafeCollectionsChange =\n  ({ foldersSlug }: { foldersSlug: CollectionSlug }): CollectionBeforeValidateHook =>\n  async ({ data, originalDoc, req }) => {\n    const currentFolderID = extractID(originalDoc || {})\n    const parentFolderID = extractID(data?.folder || originalDoc?.folder || {})\n    if (Array.isArray(data?.folderType) && data.folderType.length > 0) {\n      const folderType = data.folderType as string[]\n      const currentlyAssignedCollections: string[] | undefined =\n        Array.isArray(originalDoc?.folderType) && originalDoc.folderType.length > 0\n          ? originalDoc.folderType\n          : undefined\n      /**\n       * Check if the assigned collections have changed.\n       * example:\n       * - originalAssignedCollections: ['posts', 'pages']\n       * - folderType: ['posts']\n       *\n       * The user is narrowing the types of documents that can be associated with this folder.\n       * If the user is only expanding the types of documents that can be associated with this folder,\n       * we do not need to do anything.\n       */\n      const newCollections = currentlyAssignedCollections\n        ? // user is narrowing the current scope of the folder\n          currentlyAssignedCollections.filter((c) => !folderType.includes(c))\n        : // user is adding a scope to the folder\n          folderType\n\n      if (newCollections && newCollections.length > 0) {\n        let hasDependentDocuments = false\n        if (typeof currentFolderID === 'string' || typeof currentFolderID === 'number') {\n          const childDocumentsResult = await req.payload.findByID({\n            id: currentFolderID,\n            collection: foldersSlug,\n            joins: {\n              documentsAndFolders: {\n                limit: 100_000_000,\n                where: {\n                  or: [\n                    {\n                      relationTo: {\n                        in: newCollections,\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n            overrideAccess: true,\n            req,\n          })\n\n          hasDependentDocuments = childDocumentsResult.documentsAndFolders.docs.length > 0\n        }\n\n        // matches folders that are directly related to the removed collections\n        let hasDependentFolders = false\n        if (\n          !hasDependentDocuments &&\n          (typeof currentFolderID === 'string' || typeof currentFolderID === 'number')\n        ) {\n          const childFoldersResult = await req.payload.find({\n            collection: foldersSlug,\n            limit: 1,\n            req,\n            where: {\n              and: [\n                {\n                  folderType: {\n                    in: newCollections,\n                  },\n                },\n                {\n                  folder: {\n                    equals: currentFolderID,\n                  },\n                },\n              ],\n            },\n          })\n          hasDependentFolders = childFoldersResult.totalDocs > 0\n        }\n\n        if (hasDependentDocuments || hasDependentFolders) {\n          const translatedLabels = newCollections.map((collectionSlug) => {\n            if (req.payload.collections[collectionSlug]?.config.labels.singular) {\n              return getTranslatedLabel(\n                req.payload.collections[collectionSlug]?.config.labels.plural,\n                req.i18n,\n              )\n            }\n            return collectionSlug\n          })\n\n          throw new APIError(\n            `The folder \"${data.name || originalDoc.name}\" contains ${hasDependentDocuments ? 'documents' : 'folders'} that still belong to the following collections: ${translatedLabels.join(', ')}`,\n            400,\n          )\n        }\n        return data\n      }\n    } else if (\n      (data?.folderType === null ||\n        (Array.isArray(data?.folderType) && data?.folderType.length === 0)) &&\n      parentFolderID\n    ) {\n      // attempting to set the folderType to catch-all, so we need to ensure that the parent allows this\n      let parentFolder\n      if (typeof parentFolderID === 'string' || typeof parentFolderID === 'number') {\n        try {\n          parentFolder = await req.payload.findByID({\n            id: parentFolderID,\n            collection: foldersSlug,\n            overrideAccess: true,\n            req,\n            select: {\n              name: true,\n              folderType: true,\n            },\n            user: req.user,\n          })\n        } catch (_) {\n          // parent folder does not exist\n        }\n      }\n\n      if (\n        parentFolder &&\n        parentFolder?.folderType &&\n        Array.isArray(parentFolder.folderType) &&\n        parentFolder.folderType.length > 0\n      ) {\n        throw new APIError(\n          `The folder \"${data?.name || originalDoc.name}\" must have folder-type set since its parent folder ${parentFolder?.name ? `\"${parentFolder?.name}\" ` : ''}has a folder-type set.`,\n          400,\n        )\n      }\n    }\n\n    return data\n  }\n"],"names":["APIError","extractID","getTranslatedLabel","ensureSafeCollectionsChange","foldersSlug","data","originalDoc","req","currentFolderID","parentFolderID","folder","Array","isArray","folderType","length","currentlyAssignedCollections","undefined","newCollections","filter","c","includes","hasDependentDocuments","childDocumentsResult","payload","findByID","id","collection","joins","documentsAndFolders","limit","where","or","relationTo","in","overrideAccess","docs","hasDependentFolders","childFoldersResult","find","and","equals","totalDocs","translatedLabels","map","collectionSlug","collections","config","labels","singular","plural","i18n","name","join","parentFolder","select","user","_"],"mappings":"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"}