{"version":3,"sources":["../../src/folders/buildFolderField.ts"],"sourcesContent":["import type { SingleRelationshipField } from '../fields/config/types.js'\nimport type { Document } from '../types/index.js'\n\nimport { extractID } from '../utilities/extractID.js'\n\nexport const buildFolderField = ({\n  collectionSpecific,\n  folderFieldName,\n  folderSlug,\n  overrides = {},\n}: {\n  collectionSpecific: boolean\n  folderFieldName: string\n  folderSlug: string\n  overrides?: Partial<SingleRelationshipField>\n}): SingleRelationshipField => {\n  const field: SingleRelationshipField = {\n    name: folderFieldName,\n    type: 'relationship',\n    admin: {},\n    hasMany: false,\n    index: true,\n    label: 'Folder',\n    relationTo: folderSlug,\n    validate: async (value, { collectionSlug, data, overrideAccess, previousValue, req }) => {\n      if (!collectionSpecific) {\n        // if collection scoping is not enabled, no validation required since folders can contain any type of document\n        return true\n      }\n\n      if (!value) {\n        // no folder, no validation required\n        return true\n      }\n\n      const newID = extractID<Document>(value)\n      if (previousValue && extractID<Document>(previousValue) === newID) {\n        // value did not change, no validation required\n        return true\n      } else {\n        // need to validat the folder value allows this collection type\n        let parentFolder: Document = null\n        if (typeof value === 'string' || typeof value === 'number') {\n          // need to populate the value with the document\n          parentFolder = await req.payload.findByID({\n            id: newID,\n            collection: folderSlug,\n            depth: 0, // no need to populate nested folders\n            overrideAccess,\n            req,\n            select: {\n              folderType: true, // only need to check folderType\n            },\n            user: req.user,\n          })\n        }\n\n        if (parentFolder && collectionSlug) {\n          const parentFolderTypes: string[] = (parentFolder.folderType as string[]) || []\n\n          // if the parent folder has no folder types, it accepts all collections\n          if (parentFolderTypes.length === 0) {\n            return true\n          }\n\n          // validation for a folder document\n          if (collectionSlug === folderSlug) {\n            // ensure the parent accepts ALL folder types\n            const folderTypes: string[] = 'folderType' in data ? (data.folderType as string[]) : []\n            const invalidSlugs = folderTypes.filter((validCollectionSlug: string) => {\n              return !parentFolderTypes.includes(validCollectionSlug)\n            })\n            if (invalidSlugs.length === 0) {\n              return true\n            } else {\n              return `Folder with ID ${newID} does not allow documents of type ${invalidSlugs.join(', ')}`\n            }\n          }\n\n          // validation for a non-folder document\n          if (parentFolderTypes.includes(collectionSlug)) {\n            return true\n          } else {\n            return `Folder with ID ${newID} does not allow documents of type ${collectionSlug}`\n          }\n        } else {\n          return `Folder with ID ${newID} not found in collection ${folderSlug}`\n        }\n      }\n    },\n  }\n\n  if (overrides?.admin) {\n    field.admin = {\n      ...field.admin,\n      ...(overrides.admin || {}),\n    }\n\n    if (overrides.admin.components) {\n      field.admin.components = {\n        ...field.admin.components,\n        ...(overrides.admin.components || {}),\n      }\n    }\n  }\n\n  return field\n}\n"],"names":["extractID","buildFolderField","collectionSpecific","folderFieldName","folderSlug","overrides","field","name","type","admin","hasMany","index","label","relationTo","validate","value","collectionSlug","data","overrideAccess","previousValue","req","newID","parentFolder","payload","findByID","id","collection","depth","select","folderType","user","parentFolderTypes","length","folderTypes","invalidSlugs","filter","validCollectionSlug","includes","join","components"],"mappings":"AAGA,SAASA,SAAS,QAAQ,4BAA2B;AAErD,OAAO,MAAMC,mBAAmB,CAAC,EAC/BC,kBAAkB,EAClBC,eAAe,EACfC,UAAU,EACVC,YAAY,CAAC,CAAC,EAMf;IACC,MAAMC,QAAiC;QACrCC,MAAMJ;QACNK,MAAM;QACNC,OAAO,CAAC;QACRC,SAAS;QACTC,OAAO;QACPC,OAAO;QACPC,YAAYT;QACZU,UAAU,OAAOC,OAAO,EAAEC,cAAc,EAAEC,IAAI,EAAEC,cAAc,EAAEC,aAAa,EAAEC,GAAG,EAAE;YAClF,IAAI,CAAClB,oBAAoB;gBACvB,8GAA8G;gBAC9G,OAAO;YACT;YAEA,IAAI,CAACa,OAAO;gBACV,oCAAoC;gBACpC,OAAO;YACT;YAEA,MAAMM,QAAQrB,UAAoBe;YAClC,IAAII,iBAAiBnB,UAAoBmB,mBAAmBE,OAAO;gBACjE,+CAA+C;gBAC/C,OAAO;YACT,OAAO;gBACL,+DAA+D;gBAC/D,IAAIC,eAAyB;gBAC7B,IAAI,OAAOP,UAAU,YAAY,OAAOA,UAAU,UAAU;oBAC1D,+CAA+C;oBAC/CO,eAAe,MAAMF,IAAIG,OAAO,CAACC,QAAQ,CAAC;wBACxCC,IAAIJ;wBACJK,YAAYtB;wBACZuB,OAAO;wBACPT;wBACAE;wBACAQ,QAAQ;4BACNC,YAAY;wBACd;wBACAC,MAAMV,IAAIU,IAAI;oBAChB;gBACF;gBAEA,IAAIR,gBAAgBN,gBAAgB;oBAClC,MAAMe,oBAA8B,AAACT,aAAaO,UAAU,IAAiB,EAAE;oBAE/E,uEAAuE;oBACvE,IAAIE,kBAAkBC,MAAM,KAAK,GAAG;wBAClC,OAAO;oBACT;oBAEA,mCAAmC;oBACnC,IAAIhB,mBAAmBZ,YAAY;wBACjC,6CAA6C;wBAC7C,MAAM6B,cAAwB,gBAAgBhB,OAAQA,KAAKY,UAAU,GAAgB,EAAE;wBACvF,MAAMK,eAAeD,YAAYE,MAAM,CAAC,CAACC;4BACvC,OAAO,CAACL,kBAAkBM,QAAQ,CAACD;wBACrC;wBACA,IAAIF,aAAaF,MAAM,KAAK,GAAG;4BAC7B,OAAO;wBACT,OAAO;4BACL,OAAO,CAAC,eAAe,EAAEX,MAAM,kCAAkC,EAAEa,aAAaI,IAAI,CAAC,OAAO;wBAC9F;oBACF;oBAEA,uCAAuC;oBACvC,IAAIP,kBAAkBM,QAAQ,CAACrB,iBAAiB;wBAC9C,OAAO;oBACT,OAAO;wBACL,OAAO,CAAC,eAAe,EAAEK,MAAM,kCAAkC,EAAEL,gBAAgB;oBACrF;gBACF,OAAO;oBACL,OAAO,CAAC,eAAe,EAAEK,MAAM,yBAAyB,EAAEjB,YAAY;gBACxE;YACF;QACF;IACF;IAEA,IAAIC,WAAWI,OAAO;QACpBH,MAAMG,KAAK,GAAG;YACZ,GAAGH,MAAMG,KAAK;YACd,GAAIJ,UAAUI,KAAK,IAAI,CAAC,CAAC;QAC3B;QAEA,IAAIJ,UAAUI,KAAK,CAAC8B,UAAU,EAAE;YAC9BjC,MAAMG,KAAK,CAAC8B,UAAU,GAAG;gBACvB,GAAGjC,MAAMG,KAAK,CAAC8B,UAAU;gBACzB,GAAIlC,UAAUI,KAAK,CAAC8B,UAAU,IAAI,CAAC,CAAC;YACtC;QACF;IACF;IAEA,OAAOjC;AACT,EAAC"}