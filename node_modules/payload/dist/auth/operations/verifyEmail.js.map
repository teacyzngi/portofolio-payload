{"version":3,"sources":["../../../src/auth/operations/verifyEmail.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { Collection } from '../../collections/config/types.js'\nimport type { PayloadRequest } from '../../types/index.js'\n\nimport { APIError, Forbidden } from '../../errors/index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\n\nexport type Args = {\n  collection: Collection\n  req: PayloadRequest\n  token: string\n}\n\nexport const verifyEmailOperation = async (args: Args): Promise<boolean> => {\n  const { collection, req, token } = args\n\n  if (collection.config.auth.disableLocalStrategy) {\n    throw new Forbidden(req.t)\n  }\n  if (!Object.prototype.hasOwnProperty.call(args, 'token')) {\n    throw new APIError('Missing required data.', httpStatus.BAD_REQUEST)\n  }\n\n  try {\n    const shouldCommit = await initTransaction(req)\n\n    const where = appendNonTrashedFilter({\n      enableTrash: Boolean(collection.config.trash),\n      trash: false,\n      where: {\n        _verificationToken: { equals: token },\n      },\n    })\n\n    const user = await req.payload.db.findOne<any>({\n      collection: collection.config.slug,\n      req,\n      where,\n    })\n\n    if (!user) {\n      throw new APIError('Verification token is invalid.', httpStatus.FORBIDDEN)\n    }\n\n    // Ensure updatedAt date is always updated\n    user.updatedAt = new Date().toISOString()\n\n    await req.payload.db.updateOne({\n      id: user.id,\n      collection: collection.config.slug,\n      data: {\n        ...user,\n        _verificationToken: null,\n        _verified: true,\n      },\n      req,\n      returning: false,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return true\n  } catch (error: unknown) {\n    await killTransaction(req)\n    throw error\n  }\n}\n"],"names":["status","httpStatus","APIError","Forbidden","appendNonTrashedFilter","commitTransaction","initTransaction","killTransaction","verifyEmailOperation","args","collection","req","token","config","auth","disableLocalStrategy","t","Object","prototype","hasOwnProperty","call","BAD_REQUEST","shouldCommit","where","enableTrash","Boolean","trash","_verificationToken","equals","user","payload","db","findOne","slug","FORBIDDEN","updatedAt","Date","toISOString","updateOne","id","data","_verified","returning","error"],"mappings":"AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAKlD,SAASC,QAAQ,EAAEC,SAAS,QAAQ,wBAAuB;AAC3D,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,iBAAiB,QAAQ,uCAAsC;AACxE,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,eAAe,QAAQ,qCAAoC;AAQpE,OAAO,MAAMC,uBAAuB,OAAOC;IACzC,MAAM,EAAEC,UAAU,EAAEC,GAAG,EAAEC,KAAK,EAAE,GAAGH;IAEnC,IAAIC,WAAWG,MAAM,CAACC,IAAI,CAACC,oBAAoB,EAAE;QAC/C,MAAM,IAAIZ,UAAUQ,IAAIK,CAAC;IAC3B;IACA,IAAI,CAACC,OAAOC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACX,MAAM,UAAU;QACxD,MAAM,IAAIP,SAAS,0BAA0BD,WAAWoB,WAAW;IACrE;IAEA,IAAI;QACF,MAAMC,eAAe,MAAMhB,gBAAgBK;QAE3C,MAAMY,QAAQnB,uBAAuB;YACnCoB,aAAaC,QAAQf,WAAWG,MAAM,CAACa,KAAK;YAC5CA,OAAO;YACPH,OAAO;gBACLI,oBAAoB;oBAAEC,QAAQhB;gBAAM;YACtC;QACF;QAEA,MAAMiB,OAAO,MAAMlB,IAAImB,OAAO,CAACC,EAAE,CAACC,OAAO,CAAM;YAC7CtB,YAAYA,WAAWG,MAAM,CAACoB,IAAI;YAClCtB;YACAY;QACF;QAEA,IAAI,CAACM,MAAM;YACT,MAAM,IAAI3B,SAAS,kCAAkCD,WAAWiC,SAAS;QAC3E;QAEA,0CAA0C;QAC1CL,KAAKM,SAAS,GAAG,IAAIC,OAAOC,WAAW;QAEvC,MAAM1B,IAAImB,OAAO,CAACC,EAAE,CAACO,SAAS,CAAC;YAC7BC,IAAIV,KAAKU,EAAE;YACX7B,YAAYA,WAAWG,MAAM,CAACoB,IAAI;YAClCO,MAAM;gBACJ,GAAGX,IAAI;gBACPF,oBAAoB;gBACpBc,WAAW;YACb;YACA9B;YACA+B,WAAW;QACb;QAEA,IAAIpB,cAAc;YAChB,MAAMjB,kBAAkBM;QAC1B;QAEA,OAAO;IACT,EAAE,OAAOgC,OAAgB;QACvB,MAAMpC,gBAAgBI;QACtB,MAAMgC;IACR;AACF,EAAC"}