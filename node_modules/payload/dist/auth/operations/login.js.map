{"version":3,"sources":["../../../src/auth/operations/login.ts"],"sourcesContent":["import type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n  DataFromCollectionSlug,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug, TypedUser } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utils.js'\nimport {\n  AuthenticationError,\n  LockedAuth,\n  UnverifiedEmail,\n  ValidationError,\n} from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { Forbidden } from '../../index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport { getLoginOptions } from '../getLoginOptions.js'\nimport { isUserLocked } from '../isUserLocked.js'\nimport { jwtSign } from '../jwt.js'\nimport { addSessionToUser } from '../sessions.js'\nimport { authenticateLocalStrategy } from '../strategies/local/authenticate.js'\nimport { incrementLoginAttempts } from '../strategies/local/incrementLoginAttempts.js'\nimport { resetLoginAttempts } from '../strategies/local/resetLoginAttempts.js'\n\nexport type Result = {\n  exp?: number\n  token?: string\n  user?: TypedUser\n}\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: AuthOperationsFromCollectionSlug<TSlug>['login']\n  depth?: number\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\ntype CheckLoginPermissionArgs = {\n  loggingInWithUsername?: boolean\n  req: PayloadRequest\n  user: any\n}\n\n/**\n * Throws an error if the user is locked or does not exist.\n * This does not check the login attempts, only the lock status. Whoever increments login attempts\n * is responsible for locking the user properly, not whoever checks the login permission.\n */\nexport const checkLoginPermission = ({\n  loggingInWithUsername,\n  req,\n  user,\n}: CheckLoginPermissionArgs) => {\n  if (!user) {\n    throw new AuthenticationError(req.t, Boolean(loggingInWithUsername))\n  }\n\n  if (isUserLocked(new Date(user.lockUntil))) {\n    throw new LockedAuth(req.t)\n  }\n}\n\nexport const loginOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<{ user: DataFromCollectionSlug<TSlug> } & Result> => {\n  let args = incomingArgs\n\n  if (args.collection.config.auth.disableLocalStrategy) {\n    throw new Forbidden(args.req.t)\n  }\n\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    if (args.collection.config.hooks?.beforeOperation?.length) {\n      for (const hook of args.collection.config.hooks.beforeOperation) {\n        args =\n          (await hook({\n            args,\n            collection: args.collection?.config,\n            context: args.req.context,\n            operation: 'login',\n            req: args.req,\n          })) || args\n      }\n    }\n\n    const {\n      collection: { config: collectionConfig },\n      data,\n      depth,\n      overrideAccess,\n      req,\n      req: {\n        fallbackLocale,\n        locale,\n        payload,\n        payload: { secret },\n      },\n      showHiddenFields,\n    } = args\n\n    // /////////////////////////////////////\n    // Login\n    // /////////////////////////////////////\n\n    const { email: unsanitizedEmail, password } = data\n    const loginWithUsername = collectionConfig.auth.loginWithUsername\n\n    const sanitizedEmail =\n      typeof unsanitizedEmail === 'string' ? unsanitizedEmail.toLowerCase().trim() : null\n    const sanitizedUsername =\n      'username' in data && typeof data?.username === 'string'\n        ? data.username.toLowerCase().trim()\n        : null\n\n    const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)\n\n    // cannot login with email, did not provide username\n    if (!canLoginWithEmail && !sanitizedUsername) {\n      throw new ValidationError({\n        collection: collectionConfig.slug,\n        errors: [{ message: req.i18n.t('validation:required'), path: 'username' }],\n      })\n    }\n\n    // cannot login with username, did not provide email\n    if (!canLoginWithUsername && !sanitizedEmail) {\n      throw new ValidationError({\n        collection: collectionConfig.slug,\n        errors: [{ message: req.i18n.t('validation:required'), path: 'email' }],\n      })\n    }\n\n    // can login with either email or username, did not provide either\n    if (!sanitizedUsername && !sanitizedEmail) {\n      throw new ValidationError({\n        collection: collectionConfig.slug,\n        errors: [\n          { message: req.i18n.t('validation:required'), path: 'email' },\n          { message: req.i18n.t('validation:required'), path: 'username' },\n        ],\n      })\n    }\n\n    // did not provide password for login\n    if (typeof password !== 'string' || password.trim() === '') {\n      throw new ValidationError({\n        collection: collectionConfig.slug,\n        errors: [{ message: req.i18n.t('validation:required'), path: 'password' }],\n      })\n    }\n\n    let whereConstraint: Where = {}\n    const emailConstraint: Where = {\n      email: {\n        equals: sanitizedEmail,\n      },\n    }\n    const usernameConstraint: Where = {\n      username: {\n        equals: sanitizedUsername,\n      },\n    }\n\n    if (canLoginWithEmail && canLoginWithUsername && (sanitizedUsername || sanitizedEmail)) {\n      if (sanitizedUsername) {\n        whereConstraint = {\n          or: [\n            usernameConstraint,\n            {\n              email: {\n                equals: sanitizedUsername,\n              },\n            },\n          ],\n        }\n      } else {\n        whereConstraint = {\n          or: [\n            emailConstraint,\n            {\n              username: {\n                equals: sanitizedEmail,\n              },\n            },\n          ],\n        }\n      }\n    } else if (canLoginWithEmail && sanitizedEmail) {\n      whereConstraint = emailConstraint\n    } else if (canLoginWithUsername && sanitizedUsername) {\n      whereConstraint = usernameConstraint\n    }\n\n    // Exclude trashed users\n    whereConstraint = appendNonTrashedFilter({\n      enableTrash: collectionConfig.trash,\n      trash: false,\n      where: whereConstraint,\n    })\n\n    let user = (await payload.db.findOne<TypedUser>({\n      collection: collectionConfig.slug,\n      req,\n      where: whereConstraint,\n    })) as TypedUser\n\n    checkLoginPermission({\n      loggingInWithUsername: Boolean(canLoginWithUsername && sanitizedUsername),\n      req,\n      user,\n    })\n\n    user.collection = collectionConfig.slug\n    user._strategy = 'local-jwt'\n\n    const authResult = await authenticateLocalStrategy({ doc: user, password })\n    user = sanitizeInternalFields(user)\n\n    const maxLoginAttemptsEnabled = args.collection.config.auth.maxLoginAttempts > 0\n\n    if (!authResult) {\n      if (maxLoginAttemptsEnabled) {\n        await incrementLoginAttempts({\n          collection: collectionConfig,\n          payload: req.payload,\n          req,\n          user,\n        })\n\n        // Re-check login permissions and max attempts after incrementing attempts, in case parallel updates occurred\n        checkLoginPermission({\n          loggingInWithUsername: Boolean(canLoginWithUsername && sanitizedUsername),\n          req,\n          user,\n        })\n      }\n\n      throw new AuthenticationError(req.t)\n    }\n\n    if (collectionConfig.auth.verify && user._verified === false) {\n      throw new UnverifiedEmail({ t: req.t })\n    }\n\n    /*\n     * Correct password accepted - reâ€‘check that the account didn't\n     * get locked by parallel bad attempts in the meantime.\n     */\n    if (maxLoginAttemptsEnabled) {\n      const { lockUntil, loginAttempts } = (await payload.db.findOne<TypedUser>({\n        collection: collectionConfig.slug,\n        req,\n        select: {\n          lockUntil: true,\n          loginAttempts: true,\n        },\n        where: { id: { equals: user.id } },\n      }))!\n\n      user.lockUntil = lockUntil\n      user.loginAttempts = loginAttempts\n\n      checkLoginPermission({\n        req,\n        user,\n      })\n    }\n\n    const fieldsToSignArgs: Parameters<typeof getFieldsToSign>[0] = {\n      collectionConfig,\n      email: sanitizedEmail!,\n      user,\n    }\n\n    const { sid } = await addSessionToUser({\n      collectionConfig,\n      payload,\n      req,\n      user,\n    })\n\n    if (sid) {\n      fieldsToSignArgs.sid = sid\n    }\n\n    const fieldsToSign = getFieldsToSign(fieldsToSignArgs)\n\n    if (maxLoginAttemptsEnabled) {\n      await resetLoginAttempts({\n        collection: collectionConfig,\n        doc: user,\n        payload: req.payload,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // beforeLogin - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeLogin?.length) {\n      for (const hook of collectionConfig.hooks.beforeLogin) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            user,\n          })) || user\n      }\n    }\n\n    const { exp, token } = await jwtSign({\n      fieldsToSign,\n      secret,\n      tokenExpiration: collectionConfig.auth.tokenExpiration,\n    })\n\n    req.user = user\n\n    // /////////////////////////////////////\n    // afterLogin - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterLogin?.length) {\n      for (const hook of collectionConfig.hooks.afterLogin) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            token,\n            user,\n          })) || user\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    user = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: depth!,\n      doc: user,\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      draft: undefined,\n      fallbackLocale: fallbackLocale!,\n      global: null,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      req,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRead?.length) {\n      for (const hook of collectionConfig.hooks.afterRead) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: req.context,\n            doc: user,\n            req,\n          })) || user\n      }\n    }\n\n    let result: { user: DataFromCollectionSlug<TSlug> } & Result = {\n      exp,\n      token,\n      user,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'login',\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["buildAfterOperation","AuthenticationError","LockedAuth","UnverifiedEmail","ValidationError","afterRead","Forbidden","appendNonTrashedFilter","killTransaction","sanitizeInternalFields","getFieldsToSign","getLoginOptions","isUserLocked","jwtSign","addSessionToUser","authenticateLocalStrategy","incrementLoginAttempts","resetLoginAttempts","checkLoginPermission","loggingInWithUsername","req","user","t","Boolean","Date","lockUntil","loginOperation","incomingArgs","args","collection","config","auth","disableLocalStrategy","hooks","beforeOperation","length","hook","context","operation","collectionConfig","data","depth","overrideAccess","fallbackLocale","locale","payload","secret","showHiddenFields","email","unsanitizedEmail","password","loginWithUsername","sanitizedEmail","toLowerCase","trim","sanitizedUsername","username","canLoginWithEmail","canLoginWithUsername","slug","errors","message","i18n","path","whereConstraint","emailConstraint","equals","usernameConstraint","or","enableTrash","trash","where","db","findOne","_strategy","authResult","doc","maxLoginAttemptsEnabled","maxLoginAttempts","verify","_verified","loginAttempts","select","id","fieldsToSignArgs","sid","fieldsToSign","beforeLogin","exp","token","tokenExpiration","afterLogin","draft","undefined","global","result","error"],"mappings":"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"}