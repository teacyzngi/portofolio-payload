{"version":3,"sources":["../../src/utilities/flattenTopLevelFields.spec.ts"],"sourcesContent":["import { I18nClient } from '@payloadcms/translations'\nimport { ClientField } from '../fields/config/client.js'\nimport { flattenTopLevelFields } from './flattenTopLevelFields.js'\n\ndescribe('flattenFields', () => {\n  const i18n: I18nClient = {\n    t: (value: string) => value,\n    language: 'en',\n    dateFNS: {} as any,\n    dateFNSKey: 'en-US',\n    fallbackLanguage: 'en',\n    translations: {},\n  }\n\n  const baseField: ClientField = {\n    type: 'text',\n    name: 'title',\n    label: 'Title',\n  }\n\n  describe('basic flattening', () => {\n    it('should return flat list for top-level fields', () => {\n      const fields = [baseField]\n      const result = flattenTopLevelFields(fields)\n      expect(result).toHaveLength(1)\n      expect(result[0].name).toBe('title')\n    })\n  })\n\n  describe('group flattening', () => {\n    it('should flatten fields inside group with accessor and labelWithPrefix with moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'group',\n          name: 'meta',\n          label: 'Meta Info',\n          fields: [\n            {\n              type: 'text',\n              name: 'slug',\n              label: 'Slug',\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(result).toHaveLength(2)\n      expect(result[1].name).toBe('slug')\n      expect(result[1].accessor).toBe('meta.slug')\n      expect(result[1].labelWithPrefix).toBe('Meta Info > Slug')\n    })\n\n    it('should NOT flatten fields inside group without moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'group',\n          name: 'meta',\n          label: 'Meta Info',\n          fields: [\n            {\n              type: 'text',\n              name: 'slug',\n              label: 'Slug',\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields)\n\n      // Should return the group as a top-level item, not the inner field\n      expect(result).toHaveLength(1)\n      expect(result[0].name).toBe('meta')\n      expect('fields' in result[0]).toBe(true)\n      expect('accessor' in result[0]).toBe(false)\n      expect('labelWithPrefix' in result[0]).toBe(false)\n    })\n\n    it('should correctly handle deeply nested group fields with and without moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'group',\n          name: 'outer',\n          label: 'Outer',\n          fields: [\n            {\n              type: 'group',\n              name: 'inner',\n              label: 'Inner',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'deep',\n                  label: 'Deep Field',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const hoisted = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(hoisted).toHaveLength(3)\n      expect(hoisted[2].name).toBe('deep')\n      expect(hoisted[2].accessor).toBe('outer.inner.deep')\n      expect(hoisted[2].labelWithPrefix).toBe('Outer > Inner > Deep Field')\n\n      const nonHoisted = flattenTopLevelFields(fields)\n\n      expect(nonHoisted).toHaveLength(1)\n      expect(nonHoisted[0].name).toBe('outer')\n      expect('fields' in nonHoisted[0]).toBe(true)\n      expect('accessor' in nonHoisted[0]).toBe(false)\n      expect('labelWithPrefix' in nonHoisted[0]).toBe(false)\n    })\n\n    it('should hoist fields from unnamed group if moveSubFieldsToTop is true', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'group',\n          label: 'Unnamed group',\n          fields: [\n            {\n              type: 'text',\n              name: 'insideUnnamedGroup',\n            },\n          ],\n        },\n      ]\n\n      const withExtract = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      // Should include top level group and its nested field as a top-level field\n      expect(withExtract).toHaveLength(2)\n      expect(withExtract[1].type).toBe('text')\n      expect(withExtract[1].accessor).toBeUndefined()\n      expect(withExtract[1].labelWithPrefix).toBeUndefined()\n\n      const withoutExtract = flattenTopLevelFields(fields)\n\n      // Should return the group as a top-level item, not the inner field\n      expect(withoutExtract).toHaveLength(1)\n      expect(withoutExtract[0].type).toBe('text')\n      expect(withoutExtract[0].accessor).toBeUndefined()\n      expect(withoutExtract[0].labelWithPrefix).toBeUndefined()\n    })\n\n    it('should hoist using deepest named group only if parents are unnamed', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'group',\n          label: 'Outer',\n          fields: [\n            {\n              type: 'group',\n              label: 'Middle',\n              fields: [\n                {\n                  type: 'group',\n                  name: 'namedGroup',\n                  label: 'Named Group',\n                  fields: [\n                    {\n                      type: 'group',\n                      label: 'Inner',\n                      fields: [\n                        {\n                          type: 'text',\n                          name: 'nestedField',\n                          label: 'Nested Field',\n                        },\n                      ],\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const hoistedResult = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(hoistedResult).toHaveLength(5)\n      expect(hoistedResult[4].name).toBe('nestedField')\n      expect(hoistedResult[4].accessor).toBe('namedGroup.nestedField')\n      expect(hoistedResult[4].labelWithPrefix).toBe('Named Group > Nested Field')\n\n      const nonHoistedResult = flattenTopLevelFields(fields)\n\n      expect(nonHoistedResult).toHaveLength(1)\n      expect(nonHoistedResult[0].type).toBe('group')\n      expect('fields' in nonHoistedResult[0]).toBe(true)\n      expect('accessor' in nonHoistedResult[0]).toBe(false)\n      expect('labelWithPrefix' in nonHoistedResult[0]).toBe(false)\n    })\n  })\n\n  describe('array and block edge cases', () => {\n    it('should NOT flatten fields in arrays or blocks with moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'array',\n          name: 'items',\n          label: 'Items',\n          fields: [\n            {\n              type: 'text',\n              name: 'label',\n              label: 'Label',\n            },\n          ],\n        },\n        {\n          type: 'blocks',\n          name: 'layout',\n          blocks: [\n            {\n              slug: 'block',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'content',\n                  label: 'Content',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, { moveSubFieldsToTop: true })\n      expect(result).toHaveLength(2)\n      expect(result[0].name).toBe('items')\n      expect(result[1].name).toBe('layout')\n    })\n\n    it('should NOT flatten fields in arrays or blocks without moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'array',\n          name: 'things',\n          label: 'Things',\n          fields: [\n            {\n              type: 'text',\n              name: 'thingLabel',\n              label: 'Thing Label',\n            },\n          ],\n        },\n        {\n          type: 'blocks',\n          name: 'contentBlocks',\n          blocks: [\n            {\n              slug: 'content',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'body',\n                  label: 'Body',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields)\n      expect(result).toHaveLength(2)\n      expect(result[0].name).toBe('things')\n      expect(result[1].name).toBe('contentBlocks')\n    })\n\n    it('should not hoist group fields nested inside arrays', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'array',\n          name: 'arrayField',\n          label: 'Array Field',\n          fields: [\n            {\n              type: 'group',\n              name: 'groupInArray',\n              label: 'Group In Array',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'nestedInArrayGroup',\n                  label: 'Nested In Array Group',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, { moveSubFieldsToTop: true })\n      expect(result).toHaveLength(1)\n      expect(result[0].name).toBe('arrayField')\n    })\n\n    it('should not hoist group fields nested inside blocks', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'blocks',\n          name: 'blockField',\n          blocks: [\n            {\n              slug: 'exampleBlock',\n              fields: [\n                {\n                  type: 'group',\n                  name: 'groupInBlock',\n                  label: 'Group In Block',\n                  fields: [\n                    {\n                      type: 'text',\n                      name: 'nestedInBlockGroup',\n                      label: 'Nested In Block Group',\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, { moveSubFieldsToTop: true })\n      expect(result).toHaveLength(1)\n      expect(result[0].name).toBe('blockField')\n    })\n  })\n\n  describe('row and collapsible behavior', () => {\n    it('should recursively flatten collapsible fields regardless of moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'collapsible',\n          label: 'Collapsible',\n          fields: [\n            {\n              type: 'text',\n              name: 'nickname',\n              label: 'Nickname',\n            },\n          ],\n        },\n      ]\n\n      const defaultResult = flattenTopLevelFields(fields)\n      const hoistedResult = flattenTopLevelFields(fields, { moveSubFieldsToTop: true })\n\n      for (const result of [defaultResult, hoistedResult]) {\n        expect(result).toHaveLength(1)\n        expect(result[0].name).toBe('nickname')\n        expect('accessor' in result[0]).toBe(false)\n        expect('labelWithPrefix' in result[0]).toBe(false)\n      }\n    })\n\n    it('should recursively flatten row fields regardless of moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'row',\n          fields: [\n            {\n              type: 'text',\n              name: 'firstName',\n              label: 'First Name',\n            },\n            {\n              type: 'text',\n              name: 'lastName',\n              label: 'Last Name',\n            },\n          ],\n        },\n      ]\n\n      const defaultResult = flattenTopLevelFields(fields)\n      const hoistedResult = flattenTopLevelFields(fields, { moveSubFieldsToTop: true })\n\n      for (const result of [defaultResult, hoistedResult]) {\n        expect(result).toHaveLength(2)\n        expect(result[0].name).toBe('firstName')\n        expect(result[1].name).toBe('lastName')\n        expect('accessor' in result[0]).toBe(false)\n        expect('labelWithPrefix' in result[0]).toBe(false)\n      }\n    })\n\n    it('should hoist named group fields inside rows', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'row',\n          fields: [\n            {\n              type: 'group',\n              name: 'groupInRow',\n              label: 'Group In Row',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'nestedInRowGroup',\n                  label: 'Nested In Row Group',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(result).toHaveLength(2)\n      expect(result[1].accessor).toBe('groupInRow.nestedInRowGroup')\n      expect(result[1].labelWithPrefix).toBe('Group In Row > Nested In Row Group')\n    })\n\n    it('should hoist named group fields inside collapsibles', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'collapsible',\n          label: 'Collapsible',\n          fields: [\n            {\n              type: 'group',\n              name: 'groupInCollapsible',\n              label: 'Group In Collapsible',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'nestedInCollapsibleGroup',\n                  label: 'Nested In Collapsible Group',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(result).toHaveLength(2)\n      expect(result[1].accessor).toBe('groupInCollapsible.nestedInCollapsibleGroup')\n      expect(result[1].labelWithPrefix).toBe('Group In Collapsible > Nested In Collapsible Group')\n    })\n  })\n\n  describe('tab integration', () => {\n    const namedTabFields: ClientField[] = [\n      {\n        type: 'tabs',\n        tabs: [\n          {\n            label: 'Tab One',\n            name: 'tabOne',\n            fields: [\n              {\n                type: 'array',\n                name: 'array',\n                fields: [\n                  {\n                    type: 'text',\n                    name: 'text',\n                  },\n                ],\n              },\n              {\n                type: 'row',\n                fields: [\n                  {\n                    name: 'arrayInRow',\n                    type: 'array',\n                    fields: [\n                      {\n                        name: 'textInArrayInRow',\n                        type: 'text',\n                      },\n                    ],\n                  },\n                ],\n              },\n              {\n                type: 'text',\n                name: 'textInTab',\n                label: 'Text In Tab',\n              },\n              {\n                type: 'group',\n                name: 'groupInTab',\n                label: 'Group In Tab',\n                fields: [\n                  {\n                    type: 'text',\n                    name: 'nestedTextInTabGroup',\n                    label: 'Nested Text In Tab Group',\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    ]\n\n    const unnamedTabFields: ClientField[] = [\n      {\n        type: 'tabs',\n        tabs: [\n          {\n            label: 'Tab One',\n            fields: [\n              {\n                type: 'array',\n                name: 'array',\n                fields: [\n                  {\n                    type: 'text',\n                    name: 'text',\n                  },\n                ],\n              },\n              {\n                type: 'row',\n                fields: [\n                  {\n                    name: 'arrayInRow',\n                    type: 'array',\n                    fields: [\n                      {\n                        name: 'textInArrayInRow',\n                        type: 'text',\n                      },\n                    ],\n                  },\n                ],\n              },\n              {\n                type: 'text',\n                name: 'textInTab',\n                label: 'Text In Tab',\n              },\n            ],\n          },\n        ],\n      },\n    ]\n\n    it('should hoist named group fields inside unamed tabs when moveSubFieldsToTop is true', () => {\n      const unnamedTabWithNamedGroup: ClientField[] = [\n        {\n          type: 'tabs',\n          tabs: [\n            {\n              label: 'Tab One',\n              fields: [\n                {\n                  type: 'group',\n                  name: 'groupInTab',\n                  label: 'Group In Tab',\n                  fields: [\n                    {\n                      type: 'text',\n                      name: 'nestedInTabGroup',\n                      label: 'Nested In Tab Group',\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(unnamedTabWithNamedGroup, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(result).toHaveLength(2)\n      expect(result[1].accessor).toBe('groupInTab.nestedInTabGroup')\n      expect(result[1].labelWithPrefix).toBe('Group In Tab > Nested In Tab Group')\n    })\n\n    it('should hoist fields inside unnamed groups inside unnamed tabs when moveSubFieldsToTop is true', () => {\n      const unnamedTabWithUnnamedGroup: ClientField[] = [\n        {\n          type: 'tabs',\n          tabs: [\n            {\n              label: 'Tab One',\n              fields: [\n                {\n                  type: 'group',\n                  label: 'Unnamed Group In Tab',\n                  fields: [\n                    {\n                      type: 'text',\n                      name: 'nestedInUnnamedGroup',\n                      label: 'Nested In Unnamed Group',\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const defaultResult = flattenTopLevelFields(unnamedTabWithUnnamedGroup)\n\n      expect(defaultResult).toHaveLength(1)\n      expect(defaultResult[0].type).toBe('text')\n      expect(defaultResult[0].label).toBe('Nested In Unnamed Group')\n      expect('accessor' in defaultResult[0]).toBe(false)\n      expect('labelWithPrefix' in defaultResult[0]).toBe(false)\n\n      const hoistedResult = flattenTopLevelFields(unnamedTabWithUnnamedGroup, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(hoistedResult).toHaveLength(2)\n      const hoistedField = hoistedResult[1]\n      expect(hoistedField.name).toBe('nestedInUnnamedGroup')\n      expect(hoistedField.accessor).toBeUndefined()\n      expect(hoistedField.labelWithPrefix).toBeUndefined()\n    })\n\n    it('should properly hoist fields inside named tabs when moveSubFieldsToTop is true', () => {\n      const result = flattenTopLevelFields(namedTabFields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(result).toHaveLength(5)\n      expect(result[0].accessor).toBe('tabOne.array')\n      expect(result[0].labelWithPrefix).toBe('Tab One > array')\n      expect(result[1].accessor).toBe('tabOne.arrayInRow')\n      expect(result[1].labelWithPrefix).toBe('Tab One > arrayInRow')\n      expect(result[2].accessor).toBe('tabOne.textInTab')\n      expect(result[2].labelWithPrefix).toBe('Tab One > Text In Tab')\n      expect(result[4].accessor).toBe('tabOne.groupInTab.nestedTextInTabGroup')\n      expect(result[4].labelWithPrefix).toBe('Tab One > Group In Tab > Nested Text In Tab Group')\n    })\n\n    it('should NOT hoist fields inside named tabs when moveSubFieldsToTop is false', () => {\n      const result = flattenTopLevelFields(namedTabFields)\n\n      // We expect one top-level field: the tabs container itself is *not* hoisted\n      expect(result).toHaveLength(1)\n\n      const tabField = result[0]\n      expect(tabField.type).toBe('tab')\n\n      // Confirm nested fields are NOT hoisted: no accessors or labelWithPrefix at the top level\n      expect('accessor' in tabField).toBe(false)\n      expect('labelWithPrefix' in tabField).toBe(false)\n    })\n\n    it('should hoist fields inside unnamed tabs regardless of moveSubFieldsToTop', () => {\n      const resultDefault = flattenTopLevelFields(unnamedTabFields)\n      const resultHoisted = flattenTopLevelFields(unnamedTabFields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(resultDefault).toHaveLength(3)\n      expect(resultHoisted).toHaveLength(3)\n      expect(resultDefault).toEqual(resultHoisted)\n\n      for (const field of resultDefault) {\n        expect(field.accessor).toBeUndefined()\n        expect(field.labelWithPrefix).toBeUndefined()\n      }\n    })\n  })\n})\n"],"names":["flattenTopLevelFields","describe","i18n","t","value","language","dateFNS","dateFNSKey","fallbackLanguage","translations","baseField","type","name","label","it","fields","result","expect","toHaveLength","toBe","moveSubFieldsToTop","accessor","labelWithPrefix","hoisted","nonHoisted","withExtract","toBeUndefined","withoutExtract","hoistedResult","nonHoistedResult","blocks","slug","defaultResult","namedTabFields","tabs","unnamedTabFields","unnamedTabWithNamedGroup","unnamedTabWithUnnamedGroup","hoistedField","tabField","resultDefault","resultHoisted","toEqual","field"],"mappings":"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"}