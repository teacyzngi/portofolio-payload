{"version":3,"sources":["../../../src/utilities/dependencies/dependencyChecker.ts"],"sourcesContent":["import path from 'path'\nimport { fileURLToPath } from 'url'\n\nimport { getDependencies } from '../../index.js'\nimport { compareVersions } from './versionUtils.js'\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nexport type CustomVersionParser = (version: string) => { parts: number[]; preReleases: string[] }\n\nexport type DependencyCheckerArgs = {\n  /**\n   * Define dependency groups to ensure that all dependencies within that group are on the same version, and that no dependencies in that group with different versions are found\n   */\n  dependencyGroups?: {\n    dependencies: string[]\n    /**\n     * Name of the dependency group to be displayed in the error message\n     */\n    name: string\n    targetVersion?: string\n    targetVersionDependency?: string\n  }[]\n  /**\n   * Dependency package names keyed to their required versions. Supports >= (greater or equal than version) as a prefix, or no prefix for the exact version\n   */\n  dependencyVersions?: {\n    [dependency: string]: {\n      customVersionParser?: CustomVersionParser\n      required?: boolean\n      version?: string\n    }\n  }\n}\n\nexport async function checkDependencies({\n  dependencyGroups,\n  dependencyVersions,\n}: DependencyCheckerArgs): Promise<void> {\n  if (dependencyGroups?.length) {\n    for (const dependencyGroup of dependencyGroups) {\n      const resolvedDependencies = await getDependencies(dirname, dependencyGroup.dependencies)\n\n      // Go through each resolved dependency. If any dependency has a mismatching version, throw an error\n      const foundVersions: {\n        [version: string]: string\n      } = {}\n      for (const [_pkg, { version }] of resolvedDependencies.resolved) {\n        if (!Object.keys(foundVersions).includes(version)) {\n          foundVersions[version] = _pkg\n        }\n      }\n      if (Object.keys(foundVersions).length > 1) {\n        const targetVersion =\n          dependencyGroup.targetVersion ??\n          resolvedDependencies.resolved.get(dependencyGroup.targetVersionDependency!)?.version\n        if (targetVersion) {\n          const formattedVersionsWithPackageNameString = Object.entries(foundVersions)\n            .filter(([version]) => version !== targetVersion)\n            .map(([version, pkg]) => `${pkg}@${version} (Please change this to ${targetVersion})`)\n            .join(', ')\n          throw new Error(\n            `Mismatching \"${dependencyGroup.name}\" dependency versions found: ${formattedVersionsWithPackageNameString}. All \"${dependencyGroup.name}\" packages must have the same version. This is an error with your set-up, not a bug in Payload. Please go to your package.json and ensure all \"${dependencyGroup.name}\" packages have the same version.`,\n          )\n        } else {\n          const formattedVersionsWithPackageNameString = Object.entries(foundVersions)\n            .map(([version, pkg]) => `${pkg}@${version}`)\n            .join(', ')\n          throw new Error(\n            `Mismatching \"${dependencyGroup.name}\" dependency versions found: ${formattedVersionsWithPackageNameString}. All \"${dependencyGroup.name}\" packages must have the same version. This is an error with your set-up, not a bug in Payload. Please go to your package.json and ensure all \"${dependencyGroup.name}\" packages have the same version.`,\n          )\n        }\n      }\n    }\n  }\n\n  if (dependencyVersions && Object.keys(dependencyVersions).length) {\n    const resolvedDependencies = await getDependencies(dirname, Object.keys(dependencyVersions))\n    for (const [dependency, settings] of Object.entries(dependencyVersions)) {\n      const resolvedDependency = resolvedDependencies.resolved.get(dependency)\n      if (!resolvedDependency) {\n        if (!settings.required) {\n          continue\n        }\n        throw new Error(`Dependency ${dependency} not found. Please ensure it is installed.`)\n      }\n\n      if (settings.version) {\n        const settingsVersionToCheck = settings.version.startsWith('>=')\n          ? settings.version.slice(2)\n          : settings.version\n\n        const versionCompareResult = compareVersions(\n          resolvedDependency.version,\n          settingsVersionToCheck,\n          settings.customVersionParser,\n        )\n\n        if (settings.version.startsWith('>=')) {\n          if (versionCompareResult === 'lower') {\n            throw new Error(\n              `Dependency ${dependency} is on version ${resolvedDependency.version}, but ${settings.version} or greater is required. Please update this dependency.`,\n            )\n          }\n        } else if (versionCompareResult === 'lower' || versionCompareResult === 'greater') {\n          throw new Error(\n            `Dependency ${dependency} is on version ${resolvedDependency.version}, but ${settings.version} is required. Please update this dependency.`,\n          )\n        }\n      }\n    }\n  }\n}\n"],"names":["path","fileURLToPath","getDependencies","compareVersions","filename","url","dirname","checkDependencies","dependencyGroups","dependencyVersions","length","dependencyGroup","resolvedDependencies","dependencies","foundVersions","_pkg","version","resolved","Object","keys","includes","targetVersion","get","targetVersionDependency","formattedVersionsWithPackageNameString","entries","filter","map","pkg","join","Error","name","dependency","settings","resolvedDependency","required","settingsVersionToCheck","startsWith","slice","versionCompareResult","customVersionParser"],"mappings":"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"}