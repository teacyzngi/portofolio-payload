{"version":3,"sources":["../../src/utilities/addDataAndFileToRequest.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\nimport { APIError } from '../errors/APIError.js'\nimport { processMultipartFormdata } from '../uploads/fetchAPI-multipart/index.js'\n\ntype AddDataAndFileToRequest = (req: PayloadRequest) => Promise<void>\n\n/**\n * Mutates the Request, appending 'data' and 'file' if found\n */\nexport const addDataAndFileToRequest: AddDataAndFileToRequest = async (req) => {\n  const { body, headers, method, payload } = req\n\n  if (method && ['PATCH', 'POST', 'PUT'].includes(method.toUpperCase()) && body) {\n    const [contentType] = (headers.get('Content-Type') || '').split(';')\n    const bodyByteSize = parseInt(req.headers.get('Content-Length') || '0', 10)\n\n    if (contentType === 'application/json') {\n      let data = {}\n      try {\n        const text = await req.text?.()\n        data = text ? JSON.parse(text) : {}\n      } catch (error) {\n        req.payload.logger.error(error)\n      } finally {\n        req.data = data\n        // @ts-expect-error attach json method to request\n        req.json = () => Promise.resolve(data)\n      }\n    } else if (bodyByteSize && contentType?.includes('multipart/')) {\n      const { error, fields, files } = await processMultipartFormdata({\n        options: {\n          ...(payload.config.bodyParser || {}),\n          ...(payload.config.upload || {}),\n        },\n        request: req as Request,\n      })\n\n      if (error) {\n        throw new APIError(error.message)\n      }\n\n      if (files?.file) {\n        req.file = files.file\n      }\n\n      if (fields?._payload && typeof fields._payload === 'string') {\n        req.data = JSON.parse(fields._payload)\n      }\n\n      if (!req.file && fields?.file && typeof fields?.file === 'string') {\n        const { clientUploadContext, collectionSlug, filename, mimeType, size } = JSON.parse(\n          fields.file,\n        )\n        const uploadConfig = req.payload.collections[collectionSlug]!.config.upload\n\n        if (!uploadConfig.handlers) {\n          throw new APIError('uploadConfig.handlers is not present for ' + collectionSlug)\n        }\n\n        let response: null | Response = null\n        let error: unknown\n\n        for (const handler of uploadConfig.handlers) {\n          try {\n            const result = await handler(req, {\n              doc: null!,\n              params: {\n                clientUploadContext, // Pass additional specific to adapters context returned from UploadHandler, then staticHandler can use them.\n                collection: collectionSlug,\n                filename,\n              },\n            })\n            if (result) {\n              response = result\n            }\n            // If we couldn't get the file from that handler, save the error and try other.\n          } catch (err) {\n            error = err\n          }\n        }\n\n        if (!response) {\n          if (error) {\n            payload.logger.error(error)\n          }\n\n          throw new APIError('Expected response from the upload handler.')\n        }\n\n        req.file = {\n          name: filename,\n          clientUploadContext,\n          data: Buffer.from(await response.arrayBuffer()),\n          mimetype: response.headers.get('Content-Type') || mimeType,\n          size,\n        }\n      }\n    }\n  }\n}\n"],"names":["APIError","processMultipartFormdata","addDataAndFileToRequest","req","body","headers","method","payload","includes","toUpperCase","contentType","get","split","bodyByteSize","parseInt","data","text","JSON","parse","error","logger","json","Promise","resolve","fields","files","options","config","bodyParser","upload","request","message","file","_payload","clientUploadContext","collectionSlug","filename","mimeType","size","uploadConfig","collections","handlers","response","handler","result","doc","params","collection","err","name","Buffer","from","arrayBuffer","mimetype"],"mappings":"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"}