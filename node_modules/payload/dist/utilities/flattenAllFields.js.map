{"version":3,"sources":["../../src/utilities/flattenAllFields.ts"],"sourcesContent":["import type {\n  Block,\n  Field,\n  FlattenedBlock,\n  FlattenedBlocksField,\n  FlattenedField,\n  FlattenedJoinField,\n} from '../fields/config/types.js'\n\nimport { fieldAffectsData, tabHasName } from '../fields/config/types.js'\n\nexport const flattenBlock = ({ block }: { block: Block }): FlattenedBlock => {\n  return {\n    ...block,\n    flattenedFields: flattenAllFields({ fields: block.fields }),\n  }\n}\n\nconst flattenedFieldsCache = new Map<Field[], FlattenedField[]>()\n\n/**\n * Flattens all fields in a collection, preserving the nested field structure.\n * @param cache\n * @param fields\n */\nexport const flattenAllFields = ({\n  cache,\n  fields,\n}: {\n  /** Allows you to get FlattenedField[] from Field[] anywhere without performance overhead by caching. */\n  cache?: boolean\n  fields: Field[]\n}): FlattenedField[] => {\n  if (cache) {\n    const maybeFields = flattenedFieldsCache.get(fields)\n    if (maybeFields) {\n      return maybeFields\n    }\n  }\n\n  const result: FlattenedField[] = []\n\n  for (const field of fields) {\n    switch (field.type) {\n      case 'array':\n      case 'group': {\n        if (fieldAffectsData(field)) {\n          result.push({ ...field, flattenedFields: flattenAllFields({ fields: field.fields }) })\n        } else {\n          for (const nestedField of flattenAllFields({ fields: field.fields })) {\n            result.push(nestedField)\n          }\n        }\n        break\n      }\n\n      case 'blocks': {\n        const blocks: FlattenedBlock[] = []\n        let blockReferences: (FlattenedBlock | string)[] | undefined = undefined\n        if (field.blockReferences) {\n          blockReferences = []\n          for (const block of field.blockReferences) {\n            if (typeof block === 'string') {\n              blockReferences.push(block)\n              continue\n            }\n            blockReferences.push(flattenBlock({ block }))\n          }\n        } else {\n          for (const block of field.blocks) {\n            if (typeof block === 'string') {\n              blocks.push(block)\n              continue\n            }\n            blocks.push(flattenBlock({ block }))\n          }\n        }\n\n        const resultField: FlattenedBlocksField = {\n          ...field,\n          blockReferences,\n          blocks,\n        }\n\n        result.push(resultField)\n        break\n      }\n\n      case 'collapsible':\n      case 'row': {\n        for (const nestedField of flattenAllFields({ fields: field.fields })) {\n          result.push(nestedField)\n        }\n        break\n      }\n\n      case 'join': {\n        result.push(field as FlattenedJoinField)\n        break\n      }\n\n      case 'tabs': {\n        for (const tab of field.tabs) {\n          if (!tabHasName(tab)) {\n            for (const nestedField of flattenAllFields({ fields: tab.fields })) {\n              result.push(nestedField)\n            }\n          } else {\n            result.push({\n              ...tab,\n              type: 'tab',\n              flattenedFields: flattenAllFields({ fields: tab.fields }),\n            })\n          }\n        }\n        break\n      }\n\n      default: {\n        if (field.type !== 'ui') {\n          result.push(field)\n        }\n      }\n    }\n  }\n\n  flattenedFieldsCache.set(fields, result)\n\n  return result\n}\n"],"names":["fieldAffectsData","tabHasName","flattenBlock","block","flattenedFields","flattenAllFields","fields","flattenedFieldsCache","Map","cache","maybeFields","get","result","field","type","push","nestedField","blocks","blockReferences","undefined","resultField","tab","tabs","set"],"mappings":"AASA,SAASA,gBAAgB,EAAEC,UAAU,QAAQ,4BAA2B;AAExE,OAAO,MAAMC,eAAe,CAAC,EAAEC,KAAK,EAAoB;IACtD,OAAO;QACL,GAAGA,KAAK;QACRC,iBAAiBC,iBAAiB;YAAEC,QAAQH,MAAMG,MAAM;QAAC;IAC3D;AACF,EAAC;AAED,MAAMC,uBAAuB,IAAIC;AAEjC;;;;CAIC,GACD,OAAO,MAAMH,mBAAmB,CAAC,EAC/BI,KAAK,EACLH,MAAM,EAKP;IACC,IAAIG,OAAO;QACT,MAAMC,cAAcH,qBAAqBI,GAAG,CAACL;QAC7C,IAAII,aAAa;YACf,OAAOA;QACT;IACF;IAEA,MAAME,SAA2B,EAAE;IAEnC,KAAK,MAAMC,SAASP,OAAQ;QAC1B,OAAQO,MAAMC,IAAI;YAChB,KAAK;YACL,KAAK;gBAAS;oBACZ,IAAId,iBAAiBa,QAAQ;wBAC3BD,OAAOG,IAAI,CAAC;4BAAE,GAAGF,KAAK;4BAAET,iBAAiBC,iBAAiB;gCAAEC,QAAQO,MAAMP,MAAM;4BAAC;wBAAG;oBACtF,OAAO;wBACL,KAAK,MAAMU,eAAeX,iBAAiB;4BAAEC,QAAQO,MAAMP,MAAM;wBAAC,GAAI;4BACpEM,OAAOG,IAAI,CAACC;wBACd;oBACF;oBACA;gBACF;YAEA,KAAK;gBAAU;oBACb,MAAMC,SAA2B,EAAE;oBACnC,IAAIC,kBAA2DC;oBAC/D,IAAIN,MAAMK,eAAe,EAAE;wBACzBA,kBAAkB,EAAE;wBACpB,KAAK,MAAMf,SAASU,MAAMK,eAAe,CAAE;4BACzC,IAAI,OAAOf,UAAU,UAAU;gCAC7Be,gBAAgBH,IAAI,CAACZ;gCACrB;4BACF;4BACAe,gBAAgBH,IAAI,CAACb,aAAa;gCAAEC;4BAAM;wBAC5C;oBACF,OAAO;wBACL,KAAK,MAAMA,SAASU,MAAMI,MAAM,CAAE;4BAChC,IAAI,OAAOd,UAAU,UAAU;gCAC7Bc,OAAOF,IAAI,CAACZ;gCACZ;4BACF;4BACAc,OAAOF,IAAI,CAACb,aAAa;gCAAEC;4BAAM;wBACnC;oBACF;oBAEA,MAAMiB,cAAoC;wBACxC,GAAGP,KAAK;wBACRK;wBACAD;oBACF;oBAEAL,OAAOG,IAAI,CAACK;oBACZ;gBACF;YAEA,KAAK;YACL,KAAK;gBAAO;oBACV,KAAK,MAAMJ,eAAeX,iBAAiB;wBAAEC,QAAQO,MAAMP,MAAM;oBAAC,GAAI;wBACpEM,OAAOG,IAAI,CAACC;oBACd;oBACA;gBACF;YAEA,KAAK;gBAAQ;oBACXJ,OAAOG,IAAI,CAACF;oBACZ;gBACF;YAEA,KAAK;gBAAQ;oBACX,KAAK,MAAMQ,OAAOR,MAAMS,IAAI,CAAE;wBAC5B,IAAI,CAACrB,WAAWoB,MAAM;4BACpB,KAAK,MAAML,eAAeX,iBAAiB;gCAAEC,QAAQe,IAAIf,MAAM;4BAAC,GAAI;gCAClEM,OAAOG,IAAI,CAACC;4BACd;wBACF,OAAO;4BACLJ,OAAOG,IAAI,CAAC;gCACV,GAAGM,GAAG;gCACNP,MAAM;gCACNV,iBAAiBC,iBAAiB;oCAAEC,QAAQe,IAAIf,MAAM;gCAAC;4BACzD;wBACF;oBACF;oBACA;gBACF;YAEA;gBAAS;oBACP,IAAIO,MAAMC,IAAI,KAAK,MAAM;wBACvBF,OAAOG,IAAI,CAACF;oBACd;gBACF;QACF;IACF;IAEAN,qBAAqBgB,GAAG,CAACjB,QAAQM;IAEjC,OAAOA;AACT,EAAC"}