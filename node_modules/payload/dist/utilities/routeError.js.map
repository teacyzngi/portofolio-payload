{"version":3,"sources":["../../src/utilities/routeError.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { ErrorResult, SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { APIError } from '../errors/APIError.js'\nimport { getPayload } from '../index.js'\nimport { formatErrors } from './formatErrors.js'\nimport { headersWithCors } from './headersWithCors.js'\nimport { logError } from './logError.js'\nimport { mergeHeaders } from './mergeHeaders.js'\n\nexport const routeError = async ({\n  collection,\n  config: configArg,\n  err,\n  req: incomingReq,\n}: {\n  collection?: Collection\n  config: Promise<SanitizedConfig> | SanitizedConfig\n  err: APIError\n  req: PayloadRequest | Request\n}): Promise<Response> => {\n  if ('payloadInitError' in err && err.payloadInitError === true) {\n    // do not attempt initializing Payload if the error is due to a failed initialization. Otherwise,\n    // it will cause an infinite loop of initialization attempts and endless error responses, without\n    // actually logging the error, as the error logging code will never be reached.\n    console.error(err)\n    return Response.json(\n      {\n        message: 'There was an error initializing Payload',\n      },\n      { status: httpStatus.INTERNAL_SERVER_ERROR },\n    )\n  }\n\n  let payload = incomingReq && 'payload' in incomingReq && incomingReq?.payload\n\n  if (!payload) {\n    try {\n      payload = await getPayload({ config: configArg, cron: true })\n    } catch (ignore) {\n      return Response.json(\n        {\n          message: 'There was an error initializing Payload',\n        },\n        { status: httpStatus.INTERNAL_SERVER_ERROR },\n      )\n    }\n  }\n\n  let response = formatErrors(err)\n\n  let status = err.status || httpStatus.INTERNAL_SERVER_ERROR\n\n  logError({ err, payload })\n\n  const req = incomingReq as PayloadRequest\n\n  req.payload = payload\n  const headers = headersWithCors({\n    headers: new Headers(),\n    req,\n  })\n\n  const { config } = payload\n\n  // Internal server errors can contain anything, including potentially sensitive data.\n  // Therefore, error details will be hidden from the response unless `config.debug` is `true`\n  if (!config.debug && !err.isPublic && status === httpStatus.INTERNAL_SERVER_ERROR) {\n    response = formatErrors(new APIError('Something went wrong.'))\n  }\n\n  if (config.debug && config.debug === true) {\n    response.stack = err.stack\n  }\n\n  if (collection) {\n    await collection.config.hooks.afterError?.reduce(async (promise, hook) => {\n      await promise\n\n      const result = await hook({\n        collection: collection.config,\n        context: req.context,\n        error: err,\n        req,\n        result: response,\n      })\n\n      if (result) {\n        response = (result.response as ErrorResult) || response\n        status = result.status || status\n      }\n    }, Promise.resolve())\n  }\n\n  await config.hooks.afterError?.reduce(async (promise, hook) => {\n    await promise\n\n    const result = await hook({\n      collection: collection?.config,\n      context: req.context,\n      error: err,\n      req,\n      result: response,\n    })\n\n    if (result) {\n      response = (result.response as ErrorResult) || response\n      status = result.status || status\n    }\n  }, Promise.resolve())\n\n  return Response.json(response, {\n    headers: req.responseHeaders ? mergeHeaders(req.responseHeaders, headers) : headers,\n    status,\n  })\n}\n"],"names":["status","httpStatus","APIError","getPayload","formatErrors","headersWithCors","logError","mergeHeaders","routeError","collection","config","configArg","err","req","incomingReq","payloadInitError","console","error","Response","json","message","INTERNAL_SERVER_ERROR","payload","cron","ignore","response","headers","Headers","debug","isPublic","stack","hooks","afterError","reduce","promise","hook","result","context","Promise","resolve","responseHeaders"],"mappings":"AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAMlD,SAASC,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,UAAU,QAAQ,cAAa;AACxC,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,eAAe,QAAQ,uBAAsB;AACtD,SAASC,QAAQ,QAAQ,gBAAe;AACxC,SAASC,YAAY,QAAQ,oBAAmB;AAEhD,OAAO,MAAMC,aAAa,OAAO,EAC/BC,UAAU,EACVC,QAAQC,SAAS,EACjBC,GAAG,EACHC,KAAKC,WAAW,EAMjB;IACC,IAAI,sBAAsBF,OAAOA,IAAIG,gBAAgB,KAAK,MAAM;QAC9D,iGAAiG;QACjG,iGAAiG;QACjG,+EAA+E;QAC/EC,QAAQC,KAAK,CAACL;QACd,OAAOM,SAASC,IAAI,CAClB;YACEC,SAAS;QACX,GACA;YAAEpB,QAAQC,WAAWoB,qBAAqB;QAAC;IAE/C;IAEA,IAAIC,UAAUR,eAAe,aAAaA,eAAeA,aAAaQ;IAEtE,IAAI,CAACA,SAAS;QACZ,IAAI;YACFA,UAAU,MAAMnB,WAAW;gBAAEO,QAAQC;gBAAWY,MAAM;YAAK;QAC7D,EAAE,OAAOC,QAAQ;YACf,OAAON,SAASC,IAAI,CAClB;gBACEC,SAAS;YACX,GACA;gBAAEpB,QAAQC,WAAWoB,qBAAqB;YAAC;QAE/C;IACF;IAEA,IAAII,WAAWrB,aAAaQ;IAE5B,IAAIZ,SAASY,IAAIZ,MAAM,IAAIC,WAAWoB,qBAAqB;IAE3Df,SAAS;QAAEM;QAAKU;IAAQ;IAExB,MAAMT,MAAMC;IAEZD,IAAIS,OAAO,GAAGA;IACd,MAAMI,UAAUrB,gBAAgB;QAC9BqB,SAAS,IAAIC;QACbd;IACF;IAEA,MAAM,EAAEH,MAAM,EAAE,GAAGY;IAEnB,qFAAqF;IACrF,4FAA4F;IAC5F,IAAI,CAACZ,OAAOkB,KAAK,IAAI,CAAChB,IAAIiB,QAAQ,IAAI7B,WAAWC,WAAWoB,qBAAqB,EAAE;QACjFI,WAAWrB,aAAa,IAAIF,SAAS;IACvC;IAEA,IAAIQ,OAAOkB,KAAK,IAAIlB,OAAOkB,KAAK,KAAK,MAAM;QACzCH,SAASK,KAAK,GAAGlB,IAAIkB,KAAK;IAC5B;IAEA,IAAIrB,YAAY;QACd,MAAMA,WAAWC,MAAM,CAACqB,KAAK,CAACC,UAAU,EAAEC,OAAO,OAAOC,SAASC;YAC/D,MAAMD;YAEN,MAAME,SAAS,MAAMD,KAAK;gBACxB1B,YAAYA,WAAWC,MAAM;gBAC7B2B,SAASxB,IAAIwB,OAAO;gBACpBpB,OAAOL;gBACPC;gBACAuB,QAAQX;YACV;YAEA,IAAIW,QAAQ;gBACVX,WAAW,AAACW,OAAOX,QAAQ,IAAoBA;gBAC/CzB,SAASoC,OAAOpC,MAAM,IAAIA;YAC5B;QACF,GAAGsC,QAAQC,OAAO;IACpB;IAEA,MAAM7B,OAAOqB,KAAK,CAACC,UAAU,EAAEC,OAAO,OAAOC,SAASC;QACpD,MAAMD;QAEN,MAAME,SAAS,MAAMD,KAAK;YACxB1B,YAAYA,YAAYC;YACxB2B,SAASxB,IAAIwB,OAAO;YACpBpB,OAAOL;YACPC;YACAuB,QAAQX;QACV;QAEA,IAAIW,QAAQ;YACVX,WAAW,AAACW,OAAOX,QAAQ,IAAoBA;YAC/CzB,SAASoC,OAAOpC,MAAM,IAAIA;QAC5B;IACF,GAAGsC,QAAQC,OAAO;IAElB,OAAOrB,SAASC,IAAI,CAACM,UAAU;QAC7BC,SAASb,IAAI2B,eAAe,GAAGjC,aAAaM,IAAI2B,eAAe,EAAEd,WAAWA;QAC5E1B;IACF;AACF,EAAC"}