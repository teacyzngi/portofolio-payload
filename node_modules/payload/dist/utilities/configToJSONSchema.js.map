{"version":3,"sources":["../../src/utilities/configToJSONSchema.ts"],"sourcesContent":["import type { JSONSchema4, JSONSchema4TypeName } from 'json-schema'\n\nimport pluralize from 'pluralize'\nconst { singular } = pluralize\n\nimport type { I18n } from '@payloadcms/translations'\n\nimport type { Auth } from '../auth/types.js'\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { FieldAffectingData, FlattenedField, Option } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { MissingEditorProp } from '../errors/MissingEditorProp.js'\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { generateJobsJSONSchemas } from '../queues/config/generateJobsJSONSchemas.js'\nimport { toWords } from './formatLabels.js'\nimport { getCollectionIDFieldTypes } from './getCollectionIDFieldTypes.js'\n\nconst fieldIsRequired = (field: FlattenedField): boolean => {\n  const isConditional = Boolean(field?.admin && field?.admin?.condition)\n  if (isConditional) {\n    return false\n  }\n\n  const isMarkedRequired = 'required' in field && field.required === true\n  if (fieldAffectsData(field) && isMarkedRequired) {\n    return true\n  }\n\n  // if any subfields are required, this field is required\n  if ('fields' in field && field.type !== 'array') {\n    return field.flattenedFields.some((subField) => fieldIsRequired(subField))\n  }\n\n  return false\n}\n\nfunction buildOptionEnums(options: Option[]): string[] {\n  return options.map((option) => {\n    if (typeof option === 'object' && 'value' in option) {\n      return option.value\n    }\n\n    return option\n  })\n}\n\nfunction generateEntitySchemas(\n  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],\n): JSONSchema4 {\n  const properties = [...entities].reduce(\n    (acc, { slug }) => {\n      acc[slug] = {\n        $ref: `#/definitions/${slug}`,\n      }\n\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateEntitySelectSchemas(\n  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],\n): JSONSchema4 {\n  const properties = [...entities].reduce(\n    (acc, { slug }) => {\n      acc[slug] = {\n        $ref: `#/definitions/${slug}_select`,\n      }\n\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateCollectionJoinsSchemas(collections: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties = [...collections].reduce<Record<string, JSONSchema4>>(\n    (acc, { slug, joins, polymorphicJoins }) => {\n      const schema = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {},\n        required: [] as string[],\n      } satisfies JSONSchema4\n\n      for (const collectionSlug in joins) {\n        for (const join of joins[collectionSlug]!) {\n          ;(schema.properties as any)[join.joinPath] = {\n            type: 'string',\n            enum: [collectionSlug],\n          }\n          schema.required.push(join.joinPath)\n        }\n      }\n\n      for (const join of polymorphicJoins) {\n        ;(schema.properties as any)[join.joinPath] = {\n          type: 'string',\n          enum: join.field.collection,\n        }\n        schema.required.push(join.joinPath)\n      }\n\n      if (Object.keys(schema.properties).length > 0) {\n        acc[slug] = schema\n      }\n\n      return acc\n    },\n    {},\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateLocaleEntitySchemas(localization: SanitizedConfig['localization']): JSONSchema4 {\n  if (localization && 'locales' in localization && localization?.locales) {\n    const localesFromConfig = localization?.locales\n\n    const locales = [...localesFromConfig].map((locale) => {\n      return locale.code\n    }, [])\n\n    return {\n      type: 'string',\n      enum: locales,\n    }\n  }\n\n  return {\n    type: 'null',\n  }\n}\n\nfunction generateAuthEntitySchemas(entities: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties: JSONSchema4[] = [...entities]\n    .filter(({ auth }) => Boolean(auth))\n    .map(({ slug }) => {\n      return {\n        allOf: [\n          { $ref: `#/definitions/${slug}` },\n          {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              collection: { type: 'string', enum: [slug] },\n            },\n            required: ['collection'],\n          },\n        ],\n      }\n    }, {})\n\n  return {\n    oneOf: properties,\n  }\n}\n\n/**\n * Generates the JSON Schema for database configuration\n *\n * @example { db: idType: string }\n */\nfunction generateDbEntitySchema(config: SanitizedConfig): JSONSchema4 {\n  const defaultIDType: JSONSchema4 =\n    config.db?.defaultIDType === 'number' ? { type: 'number' } : { type: 'string' }\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties: {\n      defaultIDType,\n    },\n    required: ['defaultIDType'],\n  }\n}\n\n/**\n * Returns a JSON Schema Type with 'null' added if the field is not required.\n */\nexport function withNullableJSONSchemaType(\n  fieldType: JSONSchema4TypeName,\n  isRequired: boolean,\n): JSONSchema4TypeName | JSONSchema4TypeName[] {\n  const fieldTypes = [fieldType]\n  if (isRequired) {\n    return fieldType\n  }\n  fieldTypes.push('null')\n  return fieldTypes\n}\n\nfunction entityOrFieldToJsDocs({\n  entity,\n  i18n,\n}: {\n  entity: FlattenedField | SanitizedCollectionConfig | SanitizedGlobalConfig\n  i18n?: I18n\n}): string | undefined {\n  let description: string | undefined = undefined\n  if (entity?.admin?.description) {\n    if (typeof entity?.admin?.description === 'string') {\n      description = entity?.admin?.description\n    } else if (typeof entity?.admin?.description === 'object') {\n      if (entity?.admin?.description?.en) {\n        description = entity?.admin?.description?.en\n      } else if (entity?.admin?.description?.[i18n!.language]) {\n        description = entity?.admin?.description?.[i18n!.language]\n      }\n    } else if (typeof entity?.admin?.description === 'function' && i18n) {\n      // do not evaluate description functions for generating JSDocs. The output of\n      // those can differ depending on where and when they are called, creating\n      // inconsistencies in the generated JSDocs.\n    }\n  }\n  return description\n}\nexport function fieldsToJSONSchema(\n  /**\n   * Used for relationship fields, to determine whether to use a string or number type for the ID.\n   * While there is a default ID field type set by the db adapter, they can differ on a collection-level\n   * if they have custom ID fields.\n   */\n  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },\n  fields: FlattenedField[],\n  /**\n   * Allows you to define new top-level interfaces that can be re-used in the output schema.\n   */\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  config?: SanitizedConfig,\n  i18n?: I18n,\n): {\n  properties: {\n    [k: string]: JSONSchema4\n  }\n  required: string[]\n} {\n  const requiredFieldNames = new Set<string>()\n\n  return {\n    properties: Object.fromEntries(\n      fields.reduce((fieldSchemas, field, index) => {\n        const isRequired = fieldAffectsData(field) && fieldIsRequired(field)\n\n        const fieldDescription = entityOrFieldToJsDocs({ entity: field, i18n })\n        const baseFieldSchema: JSONSchema4 = {}\n        if (fieldDescription) {\n          baseFieldSchema.description = fieldDescription\n        }\n\n        let fieldSchema: JSONSchema4\n\n        switch (field.type) {\n          case 'array': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: {\n                type: 'object',\n                additionalProperties: false,\n                ...fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  field.flattenedFields,\n                  interfaceNameDefinitions,\n                  config,\n                  i18n,\n                ),\n              },\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n            break\n          }\n          case 'blocks': {\n            // Check for a case where no blocks are provided.\n            // We need to generate an empty array for this case, note that JSON schema 4 doesn't support empty arrays\n            // so the best we can get is `unknown[]`\n            const hasBlocks = Boolean(\n              field.blockReferences ? field.blockReferences.length : field.blocks.length,\n            )\n\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: hasBlocks\n                ? {\n                    oneOf: (field.blockReferences ?? field.blocks).map((block) => {\n                      if (typeof block === 'string') {\n                        const resolvedBlock = config?.blocks?.find((b) => b.slug === block)\n                        return {\n                          $ref: `#/definitions/${resolvedBlock!.interfaceName ?? resolvedBlock!.slug}`,\n                        }\n                      }\n                      const blockFieldSchemas = fieldsToJSONSchema(\n                        collectionIDFieldTypes,\n                        block.flattenedFields,\n                        interfaceNameDefinitions,\n                        config,\n                        i18n,\n                      )\n\n                      const blockSchema: JSONSchema4 = {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                          ...blockFieldSchemas.properties,\n                          blockType: {\n                            const: block.slug,\n                          },\n                        },\n                        required: ['blockType', ...blockFieldSchemas.required],\n                      }\n\n                      if (block.interfaceName) {\n                        interfaceNameDefinitions.set(block.interfaceName, blockSchema)\n\n                        return {\n                          $ref: `#/definitions/${block.interfaceName}`,\n                        }\n                      }\n\n                      return blockSchema\n                    }),\n                  }\n                : {},\n            }\n            break\n          }\n          case 'checkbox': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('boolean', isRequired),\n            }\n            break\n          }\n          case 'code':\n          case 'date':\n          case 'email':\n          case 'textarea': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('string', isRequired),\n            }\n            break\n          }\n\n          case 'group': {\n            if (fieldAffectsData(field)) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: 'object',\n                additionalProperties: false,\n                ...fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  field.flattenedFields,\n                  interfaceNameDefinitions,\n                  config,\n                  i18n,\n                ),\n              }\n\n              if (field.interfaceName) {\n                interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n                fieldSchema = { $ref: `#/definitions/${field.interfaceName}` }\n              }\n            }\n            break\n          }\n\n          case 'join': {\n            let items: JSONSchema4\n\n            if (Array.isArray(field.collection)) {\n              items = {\n                oneOf: field.collection.map((collection) => ({\n                  type: 'object',\n                  additionalProperties: false,\n                  properties: {\n                    relationTo: {\n                      const: collection,\n                    },\n                    value: {\n                      oneOf: [\n                        {\n                          type: collectionIDFieldTypes[collection],\n                        },\n                        {\n                          $ref: `#/definitions/${collection}`,\n                        },\n                      ],\n                    },\n                  },\n                  required: ['collectionSlug', 'value'],\n                })),\n              }\n            } else {\n              items = {\n                oneOf: [\n                  {\n                    type: collectionIDFieldTypes[field.collection],\n                  },\n                  {\n                    $ref: `#/definitions/${field.collection}`,\n                  },\n                ],\n              }\n            }\n\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: 'object',\n              additionalProperties: false,\n              properties: {\n                docs: {\n                  type: 'array',\n                  items,\n                },\n                hasNextPage: { type: 'boolean' },\n                totalDocs: { type: 'number' },\n              },\n            }\n            break\n          }\n\n          case 'json': {\n            fieldSchema = field.jsonSchema?.schema || {\n              ...baseFieldSchema,\n              type: ['object', 'array', 'string', 'number', 'boolean', 'null'],\n            }\n            break\n          }\n\n          case 'number': {\n            if (field.hasMany === true) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'number' },\n              }\n            } else {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('number', isRequired),\n              }\n            }\n            break\n          }\n\n          case 'point': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: [\n                {\n                  type: 'number',\n                },\n                {\n                  type: 'number',\n                },\n              ],\n              maxItems: 2,\n              minItems: 2,\n            }\n            break\n          }\n\n          case 'radio': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('string', isRequired),\n              enum: buildOptionEnums(field.options),\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n\n            break\n          }\n          case 'relationship':\n          case 'upload': {\n            if (Array.isArray(field.relationTo)) {\n              if (field.hasMany) {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    oneOf: field.relationTo.map((relation) => {\n                      return {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                          relationTo: {\n                            const: relation,\n                          },\n                          value: {\n                            oneOf: [\n                              {\n                                type: collectionIDFieldTypes[relation],\n                              },\n                              {\n                                $ref: `#/definitions/${relation}`,\n                              },\n                            ],\n                          },\n                        },\n                        required: ['value', 'relationTo'],\n                      }\n                    }),\n                  },\n                }\n              } else {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  oneOf: field.relationTo.map((relation) => {\n                    return {\n                      type: withNullableJSONSchemaType('object', isRequired),\n                      additionalProperties: false,\n                      properties: {\n                        relationTo: {\n                          const: relation,\n                        },\n                        value: {\n                          oneOf: [\n                            {\n                              type: collectionIDFieldTypes[relation],\n                            },\n                            {\n                              $ref: `#/definitions/${relation}`,\n                            },\n                          ],\n                        },\n                      },\n                      required: ['value', 'relationTo'],\n                    }\n                  }),\n                }\n              }\n            } else if (field.hasMany) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  oneOf: [\n                    {\n                      type: collectionIDFieldTypes[field.relationTo],\n                    },\n                    {\n                      $ref: `#/definitions/${field.relationTo}`,\n                    },\n                  ],\n                },\n              }\n            } else {\n              fieldSchema = {\n                ...baseFieldSchema,\n                oneOf: [\n                  {\n                    type: withNullableJSONSchemaType(\n                      collectionIDFieldTypes[field.relationTo]!,\n                      isRequired,\n                    ),\n                  },\n                  { $ref: `#/definitions/${field.relationTo}` },\n                ],\n              }\n            }\n\n            break\n          }\n          case 'richText': {\n            if (!field?.editor) {\n              throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n            }\n            if (typeof field.editor === 'function') {\n              throw new Error('Attempted to access unsanitized rich text editor.')\n            }\n            if (field.editor.outputSchema) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                ...field.editor.outputSchema({\n                  collectionIDFieldTypes,\n                  config,\n                  field,\n                  i18n,\n                  interfaceNameDefinitions,\n                  isRequired,\n                }),\n              }\n            } else {\n              // Maintain backwards compatibility with existing rich text editors\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  type: 'object',\n                },\n              }\n            }\n\n            break\n          }\n\n          case 'select': {\n            const optionEnums = buildOptionEnums(field.options)\n            // We get the previous field to check for a date in the case of a timezone select\n            // This works because timezone selects are always inserted right after a date with 'timezone: true'\n            const previousField = fields?.[index - 1]\n            const isTimezoneField =\n              previousField?.type === 'date' && previousField.timezone && field.name.includes('_tz')\n\n            // Timezone selects should reference the supportedTimezones definition\n            if (isTimezoneField) {\n              fieldSchema = {\n                $ref: `#/definitions/supportedTimezones`,\n              }\n            } else {\n              if (field.hasMany) {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    type: 'string',\n                  },\n                }\n                if (optionEnums?.length) {\n                  ;(fieldSchema.items as JSONSchema4).enum = optionEnums\n                }\n              } else {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  type: withNullableJSONSchemaType('string', isRequired),\n                }\n                if (optionEnums?.length) {\n                  fieldSchema.enum = optionEnums\n                }\n              }\n\n              if (field.interfaceName) {\n                interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n                fieldSchema = {\n                  $ref: `#/definitions/${field.interfaceName}`,\n                }\n              }\n              break\n            }\n\n            break\n          }\n          case 'tab': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: 'object',\n              additionalProperties: false,\n              ...fieldsToJSONSchema(\n                collectionIDFieldTypes,\n                field.flattenedFields,\n                interfaceNameDefinitions,\n                config,\n                i18n,\n              ),\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = { $ref: `#/definitions/${field.interfaceName}` }\n            }\n            break\n          }\n\n          case 'text':\n            if (field.hasMany === true) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'string' },\n              }\n            } else {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('string', isRequired),\n              }\n            }\n            break\n\n          default: {\n            break\n          }\n        }\n\n        if ('typescriptSchema' in field && field?.typescriptSchema?.length) {\n          for (const schema of field.typescriptSchema) {\n            fieldSchema = schema({ jsonSchema: fieldSchema! })\n          }\n        }\n\n        if (fieldSchema! && fieldAffectsData(field)) {\n          if (isRequired && fieldSchema.required !== false) {\n            requiredFieldNames.add(field.name)\n          }\n          fieldSchemas.set(field.name, fieldSchema)\n        }\n\n        return fieldSchemas\n      }, new Map<string, JSONSchema4>()),\n    ),\n    required: Array.from(requiredFieldNames),\n  }\n}\n\n// This function is part of the public API and is exported through payload/utilities\nexport function entityToJSONSchema(\n  config: SanitizedConfig,\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig,\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  defaultIDType: 'number' | 'text',\n  collectionIDFieldTypes?: { [key: string]: 'number' | 'string' },\n  i18n?: I18n,\n): JSONSchema4 {\n  if (!collectionIDFieldTypes) {\n    collectionIDFieldTypes = getCollectionIDFieldTypes({ config, defaultIDType })\n  }\n\n  const title = entity.typescript?.interface\n    ? entity.typescript.interface\n    : singular(toWords(entity.slug, true))\n\n  let mutableFields = [...entity.flattenedFields]\n\n  const idField: FieldAffectingData = { name: 'id', type: defaultIDType as 'text', required: true }\n  const customIdField = mutableFields.find((field) => field.name === 'id') as FieldAffectingData\n\n  if (customIdField && customIdField.type !== 'group' && customIdField.type !== 'tab') {\n    mutableFields = mutableFields.map((field) => {\n      if (field === customIdField) {\n        return { ...field, required: true }\n      }\n\n      return field\n    })\n  } else {\n    mutableFields.unshift(idField)\n  }\n\n  // mark timestamp fields required\n  if ('timestamps' in entity && entity.timestamps !== false) {\n    mutableFields = mutableFields.map((field) => {\n      if (field.name === 'createdAt' || field.name === 'updatedAt') {\n        return {\n          ...field,\n          required: true,\n        }\n      }\n      return field\n    })\n  }\n\n  if (\n    'auth' in entity &&\n    entity.auth &&\n    (!entity.auth?.disableLocalStrategy ||\n      (typeof entity.auth?.disableLocalStrategy === 'object' &&\n        entity.auth.disableLocalStrategy.enableFields))\n  ) {\n    mutableFields.push({\n      name: 'password',\n      type: 'text',\n    })\n  }\n\n  const jsonSchema: JSONSchema4 = {\n    type: 'object',\n    additionalProperties: false,\n    title,\n    ...fieldsToJSONSchema(\n      collectionIDFieldTypes,\n      mutableFields,\n      interfaceNameDefinitions,\n      config,\n      i18n,\n    ),\n  }\n\n  const entityDescription = entityOrFieldToJsDocs({ entity, i18n })\n\n  if (entityDescription) {\n    jsonSchema.description = entityDescription\n  }\n\n  return jsonSchema\n}\n\nexport function fieldsToSelectJSONSchema({\n  config,\n  fields,\n  interfaceNameDefinitions,\n}: {\n  config: SanitizedConfig\n  fields: FlattenedField[]\n  interfaceNameDefinitions: Map<string, JSONSchema4>\n}): JSONSchema4 {\n  const schema: JSONSchema4 = {\n    type: 'object',\n    additionalProperties: false,\n    properties: {},\n  }\n\n  for (const field of fields) {\n    switch (field.type) {\n      case 'array':\n      case 'group':\n      case 'tab': {\n        let fieldSchema: JSONSchema4 = fieldsToSelectJSONSchema({\n          config,\n          fields: field.flattenedFields,\n          interfaceNameDefinitions,\n        })\n\n        if (field.interfaceName) {\n          const definition = `${field.interfaceName}_select`\n          interfaceNameDefinitions.set(definition, fieldSchema)\n\n          fieldSchema = {\n            $ref: `#/definitions/${definition}`,\n          }\n        }\n\n        schema.properties![field.name] = {\n          oneOf: [\n            {\n              type: 'boolean',\n            },\n            fieldSchema,\n          ],\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const blocksSchema: JSONSchema4 = {\n          type: 'object',\n          additionalProperties: false,\n          properties: {},\n        }\n\n        for (const block of field.blockReferences ?? field.blocks) {\n          if (typeof block === 'string') {\n            continue // TODO\n          }\n\n          let blockSchema = fieldsToSelectJSONSchema({\n            config,\n            fields: block.flattenedFields,\n            interfaceNameDefinitions,\n          })\n\n          if (block.interfaceName) {\n            const definition = `${block.interfaceName}_select`\n            interfaceNameDefinitions.set(definition, blockSchema)\n            blockSchema = {\n              $ref: `#/definitions/${definition}`,\n            }\n          }\n\n          blocksSchema.properties![block.slug] = {\n            oneOf: [\n              {\n                type: 'boolean',\n              },\n              blockSchema,\n            ],\n          }\n        }\n\n        schema.properties![field.name] = {\n          oneOf: [\n            {\n              type: 'boolean',\n            },\n            blocksSchema,\n          ],\n        }\n\n        break\n      }\n\n      default:\n        schema.properties![field.name] = {\n          type: 'boolean',\n        }\n        break\n    }\n  }\n\n  return schema\n}\n\nconst fieldType: JSONSchema4 = {\n  type: 'string',\n  required: false,\n}\nconst generateAuthFieldTypes = ({\n  type,\n  loginWithUsername,\n}: {\n  loginWithUsername: Auth['loginWithUsername']\n  type: 'forgotOrUnlock' | 'login' | 'register'\n}): JSONSchema4 => {\n  if (loginWithUsername) {\n    switch (type) {\n      case 'forgotOrUnlock': {\n        if (loginWithUsername.allowEmailLogin) {\n          // allow email or username for unlock/forgot-password\n          return {\n            additionalProperties: false,\n            oneOf: [\n              {\n                additionalProperties: false,\n                properties: { email: fieldType },\n                required: ['email'],\n              },\n              {\n                additionalProperties: false,\n                properties: { username: fieldType },\n                required: ['username'],\n              },\n            ],\n          }\n        } else {\n          // allow only username for unlock/forgot-password\n          return {\n            additionalProperties: false,\n            properties: { username: fieldType },\n            required: ['username'],\n          }\n        }\n      }\n\n      case 'login': {\n        if (loginWithUsername.allowEmailLogin) {\n          // allow username or email and require password for login\n          return {\n            additionalProperties: false,\n            oneOf: [\n              {\n                additionalProperties: false,\n                properties: { email: fieldType, password: fieldType },\n                required: ['email', 'password'],\n              },\n              {\n                additionalProperties: false,\n                properties: { password: fieldType, username: fieldType },\n                required: ['username', 'password'],\n              },\n            ],\n          }\n        } else {\n          // allow only username and password for login\n          return {\n            additionalProperties: false,\n            properties: {\n              password: fieldType,\n              username: fieldType,\n            },\n            required: ['username', 'password'],\n          }\n        }\n      }\n\n      case 'register': {\n        const requiredFields: ('email' | 'password' | 'username')[] = ['password']\n        const properties: {\n          email?: JSONSchema4['properties']\n          password?: JSONSchema4['properties']\n          username?: JSONSchema4['properties']\n        } = {\n          password: fieldType,\n          username: fieldType,\n        }\n\n        if (loginWithUsername.requireEmail) {\n          requiredFields.push('email')\n        }\n        if (loginWithUsername.requireUsername) {\n          requiredFields.push('username')\n        }\n        if (loginWithUsername.requireEmail || loginWithUsername.allowEmailLogin) {\n          properties.email = fieldType\n        }\n\n        return {\n          additionalProperties: false,\n          properties,\n          required: requiredFields,\n        }\n      }\n    }\n  }\n\n  // default email (and password for login/register)\n  return {\n    additionalProperties: false,\n    properties: { email: fieldType, password: fieldType },\n    required: ['email', 'password'],\n  }\n}\n\nexport function authCollectionToOperationsJSONSchema(\n  config: SanitizedCollectionConfig,\n): JSONSchema4 {\n  const loginWithUsername = config.auth?.loginWithUsername\n  const loginUserFields: JSONSchema4 = generateAuthFieldTypes({ type: 'login', loginWithUsername })\n  const forgotOrUnlockUserFields: JSONSchema4 = generateAuthFieldTypes({\n    type: 'forgotOrUnlock',\n    loginWithUsername,\n  })\n  const registerUserFields: JSONSchema4 = generateAuthFieldTypes({\n    type: 'register',\n    loginWithUsername,\n  })\n\n  const properties: JSONSchema4['properties'] = {\n    forgotPassword: forgotOrUnlockUserFields,\n    login: loginUserFields,\n    registerFirstUser: registerUserFields,\n    unlock: forgotOrUnlockUserFields,\n  }\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n    title: `${singular(toWords(`${config.slug}`, true))}AuthOperations`,\n  }\n}\n\n// Generates the JSON Schema for supported timezones\nexport function timezonesToJSONSchema(\n  supportedTimezones: SanitizedConfig['admin']['timezones']['supportedTimezones'],\n): JSONSchema4 {\n  return {\n    description: 'Supported timezones in IANA format.',\n    enum: supportedTimezones.map((timezone) =>\n      typeof timezone === 'string' ? timezone : timezone.value,\n    ),\n  }\n}\n\nfunction generateAuthOperationSchemas(collections: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties = collections.reduce(\n    (acc, collection) => {\n      if (collection.auth) {\n        acc[collection.slug] = {\n          $ref: `#/definitions/auth/${collection.slug}`,\n        }\n      }\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\n/**\n * This is used for generating the TypeScript types (payload-types.ts) with the payload generate:types command.\n */\nexport function configToJSONSchema(\n  config: SanitizedConfig,\n  defaultIDType?: 'number' | 'text',\n  i18n?: I18n,\n): JSONSchema4 {\n  // a mutable Map to store custom top-level `interfaceName` types. Fields with an `interfaceName` property will be moved to the top-level definitions here\n  const interfaceNameDefinitions: Map<string, JSONSchema4> = new Map()\n\n  //  Used for relationship fields, to determine whether to use a string or number type for the ID.\n  const collectionIDFieldTypes = getCollectionIDFieldTypes({\n    config,\n    defaultIDType: defaultIDType!,\n  })\n\n  // Collections and Globals have to be moved to the top-level definitions as well. Reason: The top-level type will be the `Config` type - we don't want all collection and global\n  // types to be inlined inside the `Config` type\n\n  const entities: {\n    entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n    type: 'collection' | 'global'\n  }[] = [\n    ...config.globals.map((global) => ({ type: 'global' as const, entity: global })),\n    ...config.collections.map((collection) => ({\n      type: 'collection' as const,\n      entity: collection,\n    })),\n  ]\n\n  const entityDefinitions: { [k: string]: JSONSchema4 } = entities.reduce(\n    (acc, { type, entity }) => {\n      acc[entity.slug] = entityToJSONSchema(\n        config,\n        entity,\n        interfaceNameDefinitions,\n        defaultIDType!,\n        collectionIDFieldTypes,\n        i18n,\n      )\n      const select = fieldsToSelectJSONSchema({\n        config,\n        fields: entity.flattenedFields,\n        interfaceNameDefinitions,\n      })\n\n      if (type === 'global') {\n        select.properties!.globalType = {\n          type: 'boolean',\n        }\n      }\n\n      acc[`${entity.slug}_select`] = {\n        type: 'object',\n        additionalProperties: false,\n        ...select,\n      }\n\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  const timezoneDefinitions = timezonesToJSONSchema(config.admin.timezones.supportedTimezones)\n\n  const authOperationDefinitions = [...config.collections]\n    .filter(({ auth }) => Boolean(auth))\n    .reduce(\n      (acc, authCollection) => {\n        acc.auth[authCollection.slug] = authCollectionToOperationsJSONSchema(authCollection)\n        return acc\n      },\n      { auth: {} as Record<string, JSONSchema4> },\n    )\n\n  const jobsSchemas = config.jobs\n    ? generateJobsJSONSchemas(\n        config,\n        config.jobs,\n        interfaceNameDefinitions,\n        collectionIDFieldTypes,\n        i18n,\n      )\n    : {}\n\n  const blocksDefinition: JSONSchema4 | undefined = {\n    type: 'object',\n    additionalProperties: false,\n    properties: {},\n    required: [],\n  }\n  if (config?.blocks?.length) {\n    for (const block of config.blocks) {\n      const blockFieldSchemas = fieldsToJSONSchema(\n        collectionIDFieldTypes,\n        block.flattenedFields,\n        interfaceNameDefinitions,\n        config,\n        i18n,\n      )\n\n      const blockSchema: JSONSchema4 = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n          ...blockFieldSchemas.properties,\n          blockType: {\n            const: block.slug,\n          },\n        },\n        required: ['blockType', ...blockFieldSchemas.required],\n      }\n\n      const interfaceName = block.interfaceName ?? block.slug\n      interfaceNameDefinitions.set(interfaceName, blockSchema)\n\n      blocksDefinition.properties![block.slug] = {\n        $ref: `#/definitions/${interfaceName}`,\n      }\n      ;(blocksDefinition.required as string[]).push(block.slug)\n    }\n  }\n\n  let jsonSchema: JSONSchema4 = {\n    additionalProperties: false,\n    definitions: {\n      supportedTimezones: timezoneDefinitions,\n      ...entityDefinitions,\n      ...Object.fromEntries(interfaceNameDefinitions),\n      ...authOperationDefinitions,\n    },\n    // These properties here will be very simple, as all the complexity is in the definitions. These are just the properties for the top-level `Config` type\n    type: 'object',\n    properties: {\n      auth: generateAuthOperationSchemas(config.collections),\n      blocks: blocksDefinition,\n      collections: generateEntitySchemas(config.collections || []),\n      collectionsJoins: generateCollectionJoinsSchemas(config.collections || []),\n      collectionsSelect: generateEntitySelectSchemas(config.collections || []),\n      db: generateDbEntitySchema(config),\n      globals: generateEntitySchemas(config.globals || []),\n      globalsSelect: generateEntitySelectSchemas(config.globals || []),\n      locale: generateLocaleEntitySchemas(config.localization),\n      user: generateAuthEntitySchemas(config.collections),\n    },\n    required: [\n      'user',\n      'locale',\n      'collections',\n      'collectionsSelect',\n      'collectionsJoins',\n      'globalsSelect',\n      'globals',\n      'auth',\n      'db',\n      'jobs',\n      'blocks',\n    ],\n    title: 'Config',\n  }\n\n  if (jobsSchemas.definitions?.size) {\n    for (const [key, value] of jobsSchemas.definitions) {\n      jsonSchema.definitions![key] = value\n    }\n  }\n  if (jobsSchemas.properties) {\n    jsonSchema.properties!.jobs = {\n      type: 'object',\n      additionalProperties: false,\n      properties: jobsSchemas.properties,\n      required: ['tasks', 'workflows'],\n    }\n  }\n\n  if (config?.typescript?.schema?.length) {\n    for (const schema of config.typescript.schema) {\n      jsonSchema = schema({ collectionIDFieldTypes, config, i18n: i18n!, jsonSchema })\n    }\n  }\n\n  return jsonSchema\n}\n"],"names":["pluralize","singular","MissingEditorProp","fieldAffectsData","generateJobsJSONSchemas","toWords","getCollectionIDFieldTypes","fieldIsRequired","field","isConditional","Boolean","admin","condition","isMarkedRequired","required","type","flattenedFields","some","subField","buildOptionEnums","options","map","option","value","generateEntitySchemas","entities","properties","reduce","acc","slug","$ref","additionalProperties","Object","keys","generateEntitySelectSchemas","generateCollectionJoinsSchemas","collections","joins","polymorphicJoins","schema","collectionSlug","join","joinPath","enum","push","collection","length","generateLocaleEntitySchemas","localization","locales","localesFromConfig","locale","code","generateAuthEntitySchemas","filter","auth","allOf","oneOf","generateDbEntitySchema","config","defaultIDType","db","withNullableJSONSchemaType","fieldType","isRequired","fieldTypes","entityOrFieldToJsDocs","entity","i18n","description","undefined","en","language","fieldsToJSONSchema","collectionIDFieldTypes","fields","interfaceNameDefinitions","requiredFieldNames","Set","fromEntries","fieldSchemas","index","fieldDescription","baseFieldSchema","fieldSchema","items","interfaceName","set","hasBlocks","blockReferences","blocks","block","resolvedBlock","find","b","blockFieldSchemas","blockSchema","blockType","const","Array","isArray","relationTo","docs","hasNextPage","totalDocs","jsonSchema","hasMany","maxItems","minItems","relation","editor","Error","outputSchema","optionEnums","previousField","isTimezoneField","timezone","name","includes","typescriptSchema","add","Map","from","entityToJSONSchema","title","typescript","interface","mutableFields","idField","customIdField","unshift","timestamps","disableLocalStrategy","enableFields","entityDescription","fieldsToSelectJSONSchema","definition","blocksSchema","generateAuthFieldTypes","loginWithUsername","allowEmailLogin","email","username","password","requiredFields","requireEmail","requireUsername","authCollectionToOperationsJSONSchema","loginUserFields","forgotOrUnlockUserFields","registerUserFields","forgotPassword","login","registerFirstUser","unlock","timezonesToJSONSchema","supportedTimezones","generateAuthOperationSchemas","configToJSONSchema","globals","global","entityDefinitions","select","globalType","timezoneDefinitions","timezones","authOperationDefinitions","authCollection","jobsSchemas","jobs","blocksDefinition","definitions","collectionsJoins","collectionsSelect","globalsSelect","user","size","key"],"mappings":"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"}