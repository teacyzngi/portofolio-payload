{"version":3,"sources":["../../src/utilities/getEntityPolicies.ts"],"sourcesContent":["import type { CollectionPermission, FieldsPermissions, GlobalPermission } from '../auth/types.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { Access } from '../config/types.js'\nimport type { Field, FieldAccess } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { BlockSlug } from '../index.js'\nimport type { AllOperations, JsonObject, Payload, PayloadRequest, Where } from '../types/index.js'\n\nimport { combineQueries } from '../database/combineQueries.js'\nimport { tabHasName } from '../fields/config/types.js'\n\nexport type BlockPolicies = Record<BlockSlug, FieldsPermissions | Promise<FieldsPermissions>>\ntype Args = {\n  blockPolicies: BlockPolicies\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n  id?: number | string\n  operations: AllOperations[]\n  req: PayloadRequest\n  type: 'collection' | 'global'\n}\n\ntype ReturnType<T extends Args> = T['type'] extends 'global'\n  ? GlobalPermission\n  : CollectionPermission\n\ntype CreateAccessPromise = (args: {\n  access: Access | FieldAccess\n  accessLevel: 'entity' | 'field'\n  disableWhere?: boolean\n  operation: AllOperations\n  policiesObj: CollectionPermission | GlobalPermission\n}) => Promise<void>\n\ntype EntityDoc = JsonObject | TypeWithID\n\n/**\n * Build up permissions object for an entity (collection or global)\n */\nexport async function getEntityPolicies<T extends Args>(args: T): Promise<ReturnType<T>> {\n  const { id, type, blockPolicies, entity, operations, req } = args\n  const { data, locale, payload, user } = req\n  const isLoggedIn = !!user\n\n  const policies = {\n    fields: {},\n  } as ReturnType<T>\n\n  let docBeingAccessed: EntityDoc | Promise<EntityDoc | undefined> | undefined\n\n  async function getEntityDoc({\n    operation,\n    where,\n  }: { operation?: AllOperations; where?: Where } = {}): Promise<EntityDoc | undefined> {\n    if (!entity.slug) {\n      return undefined\n    }\n\n    if (type === 'global') {\n      return payload.findGlobal({\n        slug: entity.slug,\n        depth: 0,\n        fallbackLocale: null,\n        locale,\n        overrideAccess: true,\n        req,\n      })\n    }\n\n    if (type === 'collection' && id) {\n      if (typeof where === 'object') {\n        const options = {\n          collection: entity.slug,\n          depth: 0,\n          fallbackLocale: null,\n          limit: 1,\n          locale,\n          overrideAccess: true,\n          req,\n        }\n\n        if (operation === 'readVersions') {\n          const paginatedRes = await payload.findVersions({\n            ...options,\n            where: combineQueries(where, { parent: { equals: id } }),\n          })\n          return paginatedRes?.docs?.[0] || undefined\n        }\n\n        const paginatedRes = await payload.find({\n          ...options,\n          pagination: false,\n          where: combineQueries(where, { id: { equals: id } }),\n        })\n\n        return paginatedRes?.docs?.[0] || undefined\n      }\n\n      return payload.findByID({\n        id,\n        collection: entity.slug,\n        depth: 0,\n        fallbackLocale: null,\n        locale,\n        overrideAccess: true,\n        req,\n        trash: true,\n      })\n    }\n  }\n\n  const createAccessPromise: CreateAccessPromise = async ({\n    access,\n    accessLevel,\n    disableWhere = false,\n    operation,\n    policiesObj,\n  }) => {\n    const mutablePolicies = policiesObj as Record<string, any>\n    if (accessLevel === 'field' && docBeingAccessed === undefined) {\n      // assign docBeingAccessed first as the promise to avoid multiple calls to getEntityDoc\n      docBeingAccessed = getEntityDoc().then((doc) => {\n        docBeingAccessed = doc\n      })\n    }\n\n    // awaiting the promise to ensure docBeingAccessed is assigned before it is used\n    await docBeingAccessed\n\n    // https://payloadcms.slack.com/archives/C048Z9C2BEX/p1702054928343769\n    const accessResult = await access({ id, data, doc: docBeingAccessed, req })\n\n    // Where query was returned from access function => check if document is returned when querying with where\n    if (typeof accessResult === 'object' && !disableWhere) {\n      mutablePolicies[operation] = {\n        permission:\n          id || type === 'global'\n            ? !!(await getEntityDoc({ operation, where: accessResult }))\n            : true,\n        where: accessResult,\n      }\n    } else if (mutablePolicies[operation]?.permission !== false) {\n      mutablePolicies[operation] = {\n        permission: !!accessResult,\n      }\n    }\n  }\n\n  for (const operation of operations) {\n    if (typeof entity.access[operation as keyof typeof entity.access] === 'function') {\n      await createAccessPromise({\n        access: entity.access[operation as keyof typeof entity.access],\n        accessLevel: 'entity',\n        operation,\n        policiesObj: policies,\n      })\n    } else {\n      ;(policies as any)[operation] = {\n        permission: isLoggedIn,\n      }\n    }\n\n    await executeFieldPolicies({\n      blockPolicies,\n      createAccessPromise,\n      entityPermission: (policies as any)[operation].permission as boolean,\n      fields: entity.fields,\n      operation,\n      payload,\n      policiesObj: policies,\n    })\n  }\n\n  return policies\n}\n\n/**\n * Build up permissions object and run access functions for each field of an entity\n */\nconst executeFieldPolicies = async ({\n  blockPolicies,\n  createAccessPromise,\n  entityPermission,\n  fields,\n  operation,\n  payload,\n  policiesObj,\n}: {\n  blockPolicies: BlockPolicies\n  createAccessPromise: CreateAccessPromise\n  entityPermission: boolean\n  fields: Field[]\n  operation: AllOperations\n  payload: Payload\n  policiesObj: CollectionPermission | FieldsPermissions | GlobalPermission\n}) => {\n  const mutablePolicies = policiesObj.fields as Record<string, any>\n\n  // Fields don't have all operations of a collection\n  if (operation === 'delete' || operation === 'readVersions' || operation === 'unlock') {\n    return\n  }\n\n  await Promise.all(\n    fields.map(async (field) => {\n      if ('name' in field && field.name) {\n        if (!mutablePolicies[field.name]) {\n          mutablePolicies[field.name] = {}\n        }\n\n        if ('access' in field && field.access && typeof field.access[operation] === 'function') {\n          await createAccessPromise({\n            access: field.access[operation],\n            accessLevel: 'field',\n            disableWhere: true,\n            operation,\n            policiesObj: mutablePolicies[field.name],\n          })\n        } else {\n          mutablePolicies[field.name][operation] = {\n            permission: (policiesObj as any)[operation]?.permission,\n          }\n        }\n\n        if ('fields' in field && field.fields) {\n          if (!mutablePolicies[field.name].fields) {\n            mutablePolicies[field.name].fields = {}\n          }\n\n          await executeFieldPolicies({\n            blockPolicies,\n            createAccessPromise,\n            entityPermission,\n            fields: field.fields,\n            operation,\n            payload,\n            policiesObj: mutablePolicies[field.name],\n          })\n        }\n\n        if (\n          ('blocks' in field && field.blocks?.length) ||\n          ('blockReferences' in field && field.blockReferences?.length)\n        ) {\n          if (!mutablePolicies[field.name]?.blocks) {\n            mutablePolicies[field.name].blocks = {}\n          }\n\n          await Promise.all(\n            (field.blockReferences ?? field.blocks).map(async (_block) => {\n              const block = typeof _block === 'string' ? payload.blocks[_block]! : _block\n\n              if (typeof _block === 'string') {\n                if (blockPolicies[_block]) {\n                  if (typeof blockPolicies[_block].then === 'function') {\n                    // Earlier access to this block is still pending, so await it instead of re-running executeFieldPolicies\n                    mutablePolicies[field.name].blocks[block.slug] = await blockPolicies[_block]\n                  } else {\n                    // It's already a resolved policy object\n                    mutablePolicies[field.name].blocks[block.slug] = blockPolicies[_block]\n                  }\n                  return\n                } else {\n                  // We have not seen this block slug yet. Immediately create a promise\n                  // so that any parallel calls will just await this same promise\n                  // instead of re-running executeFieldPolicies.\n                  blockPolicies[_block] = (async () => {\n                    // If the block doesnâ€™t exist yet in our mutablePolicies, initialize it\n                    if (!mutablePolicies[field.name].blocks?.[block.slug]) {\n                      mutablePolicies[field.name].blocks[block.slug] = {\n                        fields: {},\n                        [operation]: { permission: entityPermission },\n                      }\n                    } else if (!mutablePolicies[field.name].blocks[block.slug][operation]) {\n                      mutablePolicies[field.name].blocks[block.slug][operation] = {\n                        permission: entityPermission,\n                      }\n                    }\n\n                    await executeFieldPolicies({\n                      blockPolicies,\n                      createAccessPromise,\n                      entityPermission,\n                      fields: block.fields,\n                      operation,\n                      payload,\n                      policiesObj: mutablePolicies[field.name].blocks[block.slug],\n                    })\n\n                    return mutablePolicies[field.name].blocks[block.slug]\n                  })()\n\n                  mutablePolicies[field.name].blocks[block.slug] = await blockPolicies[_block]\n                  blockPolicies[_block] = mutablePolicies[field.name].blocks[block.slug]\n                  return\n                }\n              }\n\n              if (!mutablePolicies[field.name].blocks?.[block.slug]) {\n                mutablePolicies[field.name].blocks[block.slug] = {\n                  fields: {},\n                  [operation]: { permission: entityPermission },\n                }\n              } else if (!mutablePolicies[field.name].blocks[block.slug][operation]) {\n                mutablePolicies[field.name].blocks[block.slug][operation] = {\n                  permission: entityPermission,\n                }\n              }\n\n              await executeFieldPolicies({\n                blockPolicies,\n                createAccessPromise,\n                entityPermission,\n                fields: block.fields,\n                operation,\n                payload,\n                policiesObj: mutablePolicies[field.name].blocks[block.slug],\n              })\n            }),\n          )\n        }\n      } else if ('fields' in field && field.fields) {\n        await executeFieldPolicies({\n          blockPolicies,\n          createAccessPromise,\n          entityPermission,\n          fields: field.fields,\n          operation,\n          payload,\n          policiesObj,\n        })\n      } else if (field.type === 'tabs') {\n        await Promise.all(\n          field.tabs.map(async (tab) => {\n            if (tabHasName(tab)) {\n              if (!mutablePolicies[tab.name]) {\n                mutablePolicies[tab.name] = {\n                  fields: {},\n                  [operation]: { permission: entityPermission },\n                }\n              } else if (!mutablePolicies[tab.name][operation]) {\n                mutablePolicies[tab.name][operation] = { permission: entityPermission }\n              }\n              await executeFieldPolicies({\n                blockPolicies,\n                createAccessPromise,\n                entityPermission,\n                fields: tab.fields,\n                operation,\n                payload,\n                policiesObj: mutablePolicies[tab.name],\n              })\n            } else {\n              await executeFieldPolicies({\n                blockPolicies,\n                createAccessPromise,\n                entityPermission,\n                fields: tab.fields,\n                operation,\n                payload,\n                policiesObj,\n              })\n            }\n          }),\n        )\n      }\n    }),\n  )\n}\n"],"names":["combineQueries","tabHasName","getEntityPolicies","args","id","type","blockPolicies","entity","operations","req","data","locale","payload","user","isLoggedIn","policies","fields","docBeingAccessed","getEntityDoc","operation","where","slug","undefined","findGlobal","depth","fallbackLocale","overrideAccess","options","collection","limit","paginatedRes","findVersions","parent","equals","docs","find","pagination","findByID","trash","createAccessPromise","access","accessLevel","disableWhere","policiesObj","mutablePolicies","then","doc","accessResult","permission","executeFieldPolicies","entityPermission","Promise","all","map","field","name","blocks","length","blockReferences","_block","block","tabs","tab"],"mappings":"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"}