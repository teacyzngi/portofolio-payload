{"version":3,"sources":["../../src/utilities/handleEndpoints.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\nimport { match } from 'path-to-regexp'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { Endpoint, PayloadHandler, SanitizedConfig } from '../config/types.js'\nimport type { APIError } from '../errors/APIError.js'\nimport type { GlobalConfig } from '../globals/config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { createPayloadRequest } from './createPayloadRequest.js'\nimport { headersWithCors } from './headersWithCors.js'\nimport { mergeHeaders } from './mergeHeaders.js'\nimport { routeError } from './routeError.js'\n\nconst notFoundResponse = (req: PayloadRequest, pathname?: string) => {\n  return Response.json(\n    {\n      message: `Route not found \"${pathname ?? new URL(req.url!).pathname}\"`,\n    },\n    {\n      headers: headersWithCors({\n        headers: new Headers(),\n        req,\n      }),\n      status: httpStatus.NOT_FOUND,\n    },\n  )\n}\n\n/**\n * Attaches the Payload REST API to any backend framework that uses Fetch Request/Response\n * like Next.js (app router), Remix, Bun, Hono.\n *\n * ### Example: Using Hono\n * ```ts\n * import { handleEndpoints } from 'payload';\n * import { serve } from '@hono/node-server';\n * import { loadEnv } from 'payload/node';\n *\n * const port = 3001;\n * loadEnv();\n *\n * const { default: config } = await import('@payload-config');\n *\n * const server = serve({\n *   fetch: async (request) => {\n *     const response = await handleEndpoints({\n *       config,\n *       request: request.clone(),\n *     });\n *\n *     return response;\n *   },\n *   port,\n * });\n *\n * server.on('listening', () => {\n *   console.log(`API server is listening on http://localhost:${port}/api`);\n * });\n * ```\n */\nexport const handleEndpoints = async ({\n  basePath = '',\n  config: incomingConfig,\n  path,\n  request,\n}: {\n  basePath?: string\n  config: Promise<SanitizedConfig> | SanitizedConfig\n  /** Override path from the request */\n  path?: string\n  request: Request\n}): Promise<Response> => {\n  let handler!: PayloadHandler\n  let req: PayloadRequest\n  let collection!: Collection\n\n  // This can be used against GET request search params size limit.\n  // Instead you can do POST request with a text body as search params.\n  // We use this interally for relationships querying on the frontend\n  // packages/ui/src/fields/Relationship/index.tsx\n  if (\n    request.method.toLowerCase() === 'post' &&\n    (request.headers.get('X-Payload-HTTP-Method-Override') === 'GET' ||\n      request.headers.get('X-HTTP-Method-Override') === 'GET')\n  ) {\n    let url = request.url\n    let data: any = undefined\n    if (request.headers.get('Content-Type') === 'application/x-www-form-urlencoded') {\n      const search = await request.text()\n      url = `${request.url}?${search}`\n    } else if (request.headers.get('Content-Type') === 'application/json') {\n      // May not be supported by every endpoint\n      data = await request.json()\n\n      // locale and fallbackLocale is read by createPayloadRequest to populate req.locale and req.fallbackLocale\n      // => add to searchParams\n      if (data?.locale) {\n        url += `?locale=${data.locale}`\n      }\n      if (data?.fallbackLocale) {\n        url += `&fallbackLocale=${data.depth}`\n      }\n    }\n\n    const req = new Request(url, {\n      // @ts-expect-error // TODO: check if this is required\n      cache: request.cache,\n      credentials: request.credentials,\n      headers: request.headers,\n      method: 'GET',\n      signal: request.signal,\n    })\n\n    if (data) {\n      // @ts-expect-error attach data to request - less overhead than using urlencoded\n      req.data = data\n    }\n\n    const response = await handleEndpoints({\n      basePath,\n      config: incomingConfig,\n      path,\n      request: req,\n    })\n\n    return response\n  }\n\n  try {\n    req = await createPayloadRequest({ canSetHeaders: true, config: incomingConfig, request })\n\n    if (req.method?.toLowerCase() === 'options') {\n      return Response.json(\n        {},\n        {\n          headers: headersWithCors({\n            headers: new Headers(),\n            req,\n          }),\n          status: 200,\n        },\n      )\n    }\n\n    const { payload } = req\n    const { config } = payload\n\n    const pathname = `${basePath}${path ?? new URL(req.url!).pathname}`\n\n    if (!pathname.startsWith(config.routes.api)) {\n      return notFoundResponse(req, pathname)\n    }\n\n    // /api/posts/route -> /posts/route\n    let adjustedPathname = pathname.replace(config.routes.api, '')\n\n    let isGlobals = false\n\n    // /globals/header/route -> /header/route\n    if (adjustedPathname.startsWith('/globals')) {\n      isGlobals = true\n      adjustedPathname = adjustedPathname.replace('/globals', '')\n    }\n\n    const segments = adjustedPathname.split('/')\n    // remove empty string first element\n    segments.shift()\n\n    const firstParam = segments[0]\n\n    let globalConfig!: GlobalConfig\n\n    // first param can be a global slug or collection slug, find the relevant config\n    if (firstParam) {\n      if (isGlobals) {\n        globalConfig = payload.globals.config.find((each) => each.slug === firstParam)!\n      } else if (payload.collections[firstParam]) {\n        collection = payload.collections[firstParam]\n      }\n    }\n\n    let endpoints: Endpoint[] | false = config.endpoints\n\n    if (collection) {\n      endpoints = collection.config.endpoints\n      // /posts/route -> /route\n      adjustedPathname = adjustedPathname.replace(`/${collection.config.slug}`, '')\n    } else if (globalConfig) {\n      // /header/route -> /route\n      adjustedPathname = adjustedPathname.replace(`/${globalConfig.slug}`, '')\n      endpoints = globalConfig.endpoints!\n    }\n\n    // sanitize when endpoint.path is '/'\n    if (adjustedPathname === '') {\n      adjustedPathname = '/'\n    }\n\n    if (endpoints === false) {\n      return Response.json(\n        {\n          message: `Cannot ${req.method?.toUpperCase()} ${req.url}`,\n        },\n        {\n          headers: headersWithCors({\n            headers: new Headers(),\n            req,\n          }),\n          status: httpStatus.NOT_IMPLEMENTED,\n        },\n      )\n    }\n\n    // Find the relevant endpoint configuration\n    const endpoint = endpoints?.find((endpoint) => {\n      if (endpoint.method !== req.method?.toLowerCase()) {\n        return false\n      }\n\n      const pathMatchFn = match(endpoint.path, { decode: decodeURIComponent })\n\n      const matchResult = pathMatchFn(adjustedPathname)\n\n      if (!matchResult) {\n        return false\n      }\n\n      req.routeParams = matchResult.params as Record<string, unknown>\n\n      // Inject to routeParams the slug as well so it can be used later\n      if (collection) {\n        req.routeParams.collection = collection.config.slug\n      } else if (globalConfig) {\n        req.routeParams.global = globalConfig.slug\n      }\n\n      return true\n    })\n\n    if (endpoint) {\n      handler = endpoint.handler\n    }\n\n    if (!handler) {\n      return notFoundResponse(req, pathname)\n    }\n\n    const response = await handler(req)\n\n    return new Response(response.body, {\n      headers: headersWithCors({\n        headers: mergeHeaders(req.responseHeaders ?? new Headers(), response.headers),\n        req,\n      }),\n      status: response.status,\n      statusText: response.statusText,\n    })\n  } catch (_err) {\n    const err = _err as APIError\n    return routeError({\n      collection,\n      config: incomingConfig,\n      err,\n      req: req!,\n    })\n  }\n}\n"],"names":["status","httpStatus","match","createPayloadRequest","headersWithCors","mergeHeaders","routeError","notFoundResponse","req","pathname","Response","json","message","URL","url","headers","Headers","NOT_FOUND","handleEndpoints","basePath","config","incomingConfig","path","request","handler","collection","method","toLowerCase","get","data","undefined","search","text","locale","fallbackLocale","depth","Request","cache","credentials","signal","response","canSetHeaders","payload","startsWith","routes","api","adjustedPathname","replace","isGlobals","segments","split","shift","firstParam","globalConfig","globals","find","each","slug","collections","endpoints","toUpperCase","NOT_IMPLEMENTED","endpoint","pathMatchFn","decode","decodeURIComponent","matchResult","routeParams","params","global","body","responseHeaders","statusText","_err","err"],"mappings":"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"}