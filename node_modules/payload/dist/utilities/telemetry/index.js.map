{"version":3,"sources":["../../../src/utilities/telemetry/index.ts"],"sourcesContent":["import { execSync } from 'child_process'\nimport ciInfo from 'ci-info'\nimport { randomBytes } from 'crypto'\nimport fs from 'fs'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\n\nimport type { Payload } from '../../types/index.js'\nimport type { AdminInitEvent } from './events/adminInit.js'\nimport type { ServerInitEvent } from './events/serverInit.js'\n\nimport { findUp } from '../findUp.js'\nimport { Conf } from './conf/index.js'\nimport { oneWayHash } from './oneWayHash.js'\n\nexport type BaseEvent = {\n  ciName: null | string\n  dbAdapter: string\n  emailAdapter: null | string\n  envID: string\n  isCI: boolean\n  locales: string[]\n  localizationDefaultLocale: null | string\n  localizationEnabled: boolean\n  nodeEnv: string\n  nodeVersion: string\n  payloadVersion: string\n  projectID: string\n  projectIDSource: 'cwd' | 'git' | 'packageJSON' | 'serverURL'\n  uploadAdapters: string[]\n}\n\ntype PackageJSON = {\n  dependencies: Record<string, string | undefined>\n  name: string\n}\n\ntype TelemetryEvent = AdminInitEvent | ServerInitEvent\n\ntype Args = {\n  event: TelemetryEvent\n  payload: Payload\n}\n\nlet baseEvent: BaseEvent | null = null\n\nexport const sendEvent = async ({ event, payload }: Args): Promise<void> => {\n  try {\n    if (payload.config.telemetry !== false) {\n      const { packageJSON, packageJSONPath } = await getPackageJSON()\n\n      // Only generate the base event once\n      if (!baseEvent) {\n        const { projectID, source: projectIDSource } = getProjectID(payload, packageJSON!)\n        baseEvent = {\n          ciName: ciInfo.isCI ? ciInfo.name : null,\n          envID: getEnvID(),\n          isCI: ciInfo.isCI,\n          nodeEnv: process.env.NODE_ENV || 'development',\n          nodeVersion: process.version,\n          payloadVersion: getPayloadVersion(packageJSON!),\n          projectID,\n          projectIDSource,\n          ...getLocalizationInfo(payload),\n          dbAdapter: payload.db.name,\n          emailAdapter: payload.email?.name || null,\n          uploadAdapters: payload.config.upload.adapters,\n        }\n      }\n\n      if (process.env.PAYLOAD_TELEMETRY_DEBUG) {\n        payload.logger.info({\n          event: { ...baseEvent, ...event, packageJSONPath },\n          msg: 'Telemetry Event',\n        })\n        return\n      }\n\n      await fetch('https://telemetry.payloadcms.com/events', {\n        body: JSON.stringify({ ...baseEvent, ...event }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        method: 'post',\n      })\n    }\n  } catch (_) {\n    // Eat any errors in sending telemetry event\n  }\n}\n\n/**\n * This is a quasi-persistent identifier used to dedupe recurring events. It's\n * generated from random data and completely anonymous.\n */\nconst getEnvID = (): string => {\n  const conf = new Conf()\n  const ENV_ID = 'envID'\n\n  const val = conf.get(ENV_ID)\n  if (val) {\n    return val as string\n  }\n\n  const generated = randomBytes(32).toString('hex')\n  conf.set(ENV_ID, generated)\n  return generated\n}\n\nconst getProjectID = (\n  payload: Payload,\n  packageJSON: PackageJSON,\n): { projectID: string; source: BaseEvent['projectIDSource'] } => {\n  const gitID = getGitID(payload)\n  if (gitID) {\n    return { projectID: oneWayHash(gitID, payload.secret), source: 'git' }\n  }\n\n  const packageJSONID = getPackageJSONID(payload, packageJSON)\n  if (packageJSONID) {\n    return { projectID: oneWayHash(packageJSONID, payload.secret), source: 'packageJSON' }\n  }\n\n  const serverURL = payload.config.serverURL\n  if (serverURL) {\n    return { projectID: oneWayHash(serverURL, payload.secret), source: 'serverURL' }\n  }\n\n  const cwd = process.cwd()\n  return { projectID: oneWayHash(cwd, payload.secret), source: 'cwd' }\n}\n\nconst getGitID = (payload: Payload) => {\n  try {\n    const originBuffer = execSync('git config --local --get remote.origin.url', {\n      stdio: 'pipe',\n      timeout: 1000,\n    })\n\n    return oneWayHash(String(originBuffer).trim(), payload.secret)\n  } catch (_) {\n    return null\n  }\n}\n\nconst getPackageJSON = async (): Promise<{\n  packageJSON?: PackageJSON\n  packageJSONPath: string\n}> => {\n  let packageJSONPath = path.resolve(process.cwd(), 'package.json')\n\n  if (!fs.existsSync(packageJSONPath)) {\n    // Old logic\n    const filename = fileURLToPath(import.meta.url)\n    const dirname = path.dirname(filename)\n    packageJSONPath = (await findUp({\n      dir: dirname,\n      fileNames: ['package.json'],\n    }))!\n  }\n\n  const jsonContentString = await fs.promises.readFile(packageJSONPath, 'utf-8')\n  const jsonContent: PackageJSON = JSON.parse(jsonContentString)\n  return { packageJSON: jsonContent, packageJSONPath }\n}\n\nconst getPackageJSONID = (payload: Payload, packageJSON: PackageJSON): string => {\n  return oneWayHash(packageJSON.name, payload.secret)\n}\n\nexport const getPayloadVersion = (packageJSON: PackageJSON): string => {\n  return packageJSON?.dependencies?.payload ?? ''\n}\n\nexport const getLocalizationInfo = (\n  payload: Payload,\n): Pick<BaseEvent, 'locales' | 'localizationDefaultLocale' | 'localizationEnabled'> => {\n  if (!payload.config.localization) {\n    return {\n      locales: [],\n      localizationDefaultLocale: null,\n      localizationEnabled: false,\n    }\n  }\n\n  return {\n    locales: payload.config.localization.localeCodes,\n    localizationDefaultLocale: payload.config.localization.defaultLocale,\n    localizationEnabled: true,\n  }\n}\n"],"names":["execSync","ciInfo","randomBytes","fs","path","fileURLToPath","findUp","Conf","oneWayHash","baseEvent","sendEvent","event","payload","config","telemetry","packageJSON","packageJSONPath","getPackageJSON","projectID","source","projectIDSource","getProjectID","ciName","isCI","name","envID","getEnvID","nodeEnv","process","env","NODE_ENV","nodeVersion","version","payloadVersion","getPayloadVersion","getLocalizationInfo","dbAdapter","db","emailAdapter","email","uploadAdapters","upload","adapters","PAYLOAD_TELEMETRY_DEBUG","logger","info","msg","fetch","body","JSON","stringify","headers","method","_","conf","ENV_ID","val","get","generated","toString","set","gitID","getGitID","secret","packageJSONID","getPackageJSONID","serverURL","cwd","originBuffer","stdio","timeout","String","trim","resolve","existsSync","filename","url","dirname","dir","fileNames","jsonContentString","promises","readFile","jsonContent","parse","dependencies","localization","locales","localizationDefaultLocale","localizationEnabled","localeCodes","defaultLocale"],"mappings":"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"}