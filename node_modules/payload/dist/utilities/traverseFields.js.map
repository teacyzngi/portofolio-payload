{"version":3,"sources":["../../src/utilities/traverseFields.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from '../config/types.js'\nimport type { ArrayField, Block, BlocksField, Field, TabAsField } from '../fields/config/types.js'\n\nimport {\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldShouldBeLocalized,\n  tabHasName,\n} from '../fields/config/types.js'\n\nconst traverseArrayOrBlocksField = ({\n  callback,\n  callbackStack,\n  config,\n  data,\n  field,\n  fillEmpty,\n  leavesFirst,\n  parentIsLocalized,\n  parentPath,\n  parentRef,\n}: {\n  callback: TraverseFieldsCallback\n  callbackStack: (() => ReturnType<TraverseFieldsCallback>)[]\n  config?: Config | SanitizedConfig\n  data: Record<string, unknown>[]\n  field: ArrayField | BlocksField\n  fillEmpty: boolean\n  leavesFirst: boolean\n  parentIsLocalized: boolean\n  parentPath: string\n  parentRef?: unknown\n}) => {\n  if (fillEmpty) {\n    if (field.type === 'array') {\n      traverseFields({\n        callback,\n        callbackStack,\n        config,\n        fields: field.fields,\n        isTopLevel: false,\n        leavesFirst,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: `${parentPath}${field.name}.`,\n        parentRef,\n      })\n    }\n    if (field.type === 'blocks') {\n      for (const _block of field.blockReferences ?? field.blocks) {\n        // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n        const block =\n          typeof _block === 'string' ? config?.blocks?.find((b) => b.slug === _block) : _block\n        if (block) {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: block.fields,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: `${parentPath}${field.name}.`,\n            parentRef,\n          })\n        }\n      }\n    }\n    return\n  }\n  for (const ref of data) {\n    let fields!: Field[]\n    if (field.type === 'blocks' && typeof ref?.blockType === 'string') {\n      // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n      const block = field.blockReferences\n        ? ((config?.blocks?.find((b) => b.slug === ref.blockType) ??\n            field.blockReferences.find(\n              (b) => typeof b !== 'string' && b.slug === ref.blockType,\n            )) as Block)\n        : field.blocks.find((b) => b.slug === ref.blockType)\n\n      fields = block?.fields as Field[]\n    } else if (field.type === 'array') {\n      fields = field.fields\n    }\n\n    if (fields) {\n      traverseFields({\n        callback,\n        callbackStack,\n        config,\n        fields,\n        fillEmpty,\n        isTopLevel: false,\n        leavesFirst,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: `${parentPath}${field.name}.`,\n        parentRef,\n        ref,\n      })\n    }\n  }\n}\n\nexport type TraverseFieldsCallback = (args: {\n  /**\n   * The current field\n   */\n  field: Field | TabAsField\n  /**\n   * Function that when called will skip the current field and continue to the next\n   */\n  next?: () => void\n  parentIsLocalized: boolean\n  parentPath: string\n  /**\n   * The parent reference object\n   */\n  parentRef?: Record<string, unknown> | unknown\n  /**\n   * The current reference object\n   */\n  ref?: Record<string, unknown> | unknown\n}) => boolean | void\n\ntype TraverseFieldsArgs = {\n  callback: TraverseFieldsCallback\n  callbackStack?: (() => ReturnType<TraverseFieldsCallback>)[]\n  config?: Config | SanitizedConfig\n  fields: (Field | TabAsField)[]\n  fillEmpty?: boolean\n  isTopLevel?: boolean\n  /**\n   * @default false\n   *\n   * if this is `true`, the callback functions of the leaf fields will be called before the parent fields.\n   * The return value of the callback function will be ignored.\n   */\n  leavesFirst?: boolean\n  parentIsLocalized?: boolean\n  parentPath?: string\n  parentRef?: Record<string, unknown> | unknown\n  ref?: Record<string, unknown> | unknown\n}\n\n/**\n * Iterate a recurse an array of fields, calling a callback for each field\n *\n * @param fields\n * @param callback callback called for each field, discontinue looping if callback returns truthy\n * @param fillEmpty fill empty properties to use this without data\n * @param ref the data or any artifacts assigned in the callback during field recursion\n * @param parentRef the data or any artifacts assigned in the callback during field recursion one level up\n */\nexport const traverseFields = ({\n  callback,\n  callbackStack: _callbackStack = [],\n  config,\n  fields,\n  fillEmpty = true,\n  isTopLevel = true,\n  leavesFirst = false,\n  parentIsLocalized,\n  parentPath = '',\n  parentRef = {},\n  ref = {},\n}: TraverseFieldsArgs): void => {\n  const fieldsMatched = fields.some((field) => {\n    let callbackStack: (() => ReturnType<TraverseFieldsCallback>)[] = []\n    if (!isTopLevel) {\n      callbackStack = _callbackStack\n    }\n    let skip = false\n    const next = () => {\n      skip = true\n    }\n\n    if (!ref || typeof ref !== 'object') {\n      return\n    }\n\n    if (\n      !leavesFirst &&\n      callback &&\n      callback({ field, next, parentIsLocalized: parentIsLocalized!, parentPath, parentRef, ref })\n    ) {\n      return true\n    } else if (leavesFirst) {\n      callbackStack.push(() =>\n        callback({\n          field,\n          next,\n          parentIsLocalized: parentIsLocalized!,\n          parentPath,\n          parentRef,\n          ref,\n        }),\n      )\n    }\n\n    if (skip) {\n      return false\n    }\n\n    // avoid mutation of ref for all fields\n    let currentRef = ref\n    let currentParentRef = parentRef\n\n    if (field.type === 'tabs' && 'tabs' in field) {\n      for (const tab of field.tabs) {\n        let tabRef = ref\n\n        if (skip) {\n          return false\n        }\n\n        if ('name' in tab && tab.name) {\n          if (\n            !ref[tab.name as keyof typeof ref] ||\n            typeof ref[tab.name as keyof typeof ref] !== 'object'\n          ) {\n            if (fillEmpty) {\n              if (tab.localized) {\n                ;(ref as Record<string, any>)[tab.name] = { en: {} }\n              } else {\n                ;(ref as Record<string, any>)[tab.name] = {}\n              }\n            } else {\n              continue\n            }\n          }\n\n          if (\n            callback &&\n            !leavesFirst &&\n            callback({\n              field: { ...tab, type: 'tab' },\n              next,\n              parentIsLocalized: parentIsLocalized!,\n              parentPath,\n              parentRef: currentParentRef,\n              ref: tabRef,\n            })\n          ) {\n            return true\n          } else if (leavesFirst) {\n            callbackStack.push(() =>\n              callback({\n                field: { ...tab, type: 'tab' },\n                next,\n                parentIsLocalized: parentIsLocalized!,\n                parentPath,\n                parentRef: currentParentRef,\n                ref: tabRef,\n              }),\n            )\n          }\n\n          tabRef = tabRef[tab.name as keyof typeof tabRef]\n\n          if (tab.localized) {\n            for (const key in tabRef as Record<string, unknown>) {\n              if (\n                tabRef[key as keyof typeof tabRef] &&\n                typeof tabRef[key as keyof typeof tabRef] === 'object'\n              ) {\n                traverseFields({\n                  callback,\n                  callbackStack,\n                  config,\n                  fields: tab.fields,\n                  fillEmpty,\n                  isTopLevel: false,\n                  leavesFirst,\n                  parentIsLocalized: true,\n                  parentPath: `${parentPath}${tab.name}.`,\n                  parentRef: currentParentRef,\n                  ref: tabRef[key as keyof typeof tabRef],\n                })\n              }\n            }\n          }\n        } else {\n          if (\n            callback &&\n            !leavesFirst &&\n            callback({\n              field: { ...tab, type: 'tab' },\n              next,\n              parentIsLocalized: parentIsLocalized!,\n              parentPath,\n              parentRef: currentParentRef,\n              ref: tabRef,\n            })\n          ) {\n            return true\n          } else if (leavesFirst) {\n            callbackStack.push(() =>\n              callback({\n                field: { ...tab, type: 'tab' },\n                next,\n                parentIsLocalized: parentIsLocalized!,\n                parentPath,\n                parentRef: currentParentRef,\n                ref: tabRef,\n              }),\n            )\n          }\n        }\n\n        if (!tab.localized) {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: tab.fields,\n            fillEmpty,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized: false,\n            parentPath: tabHasName(tab) ? `${parentPath}${tab.name}` : parentPath,\n            parentRef: currentParentRef,\n            ref: tabRef,\n          })\n        }\n\n        if (skip) {\n          return false\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'tab' || fieldHasSubFields(field) || field.type === 'blocks') {\n      if ('name' in field && field.name) {\n        currentParentRef = currentRef\n        if (!ref[field.name as keyof typeof ref]) {\n          if (fillEmpty) {\n            if (field.type === 'group' || field.type === 'tab') {\n              if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n                ;(ref as Record<string, any>)[field.name] = { en: {} }\n              } else {\n                ;(ref as Record<string, any>)[field.name] = {}\n              }\n            } else if (field.type === 'array' || field.type === 'blocks') {\n              if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n                ;(ref as Record<string, any>)[field.name] = { en: [] }\n              } else {\n                ;(ref as Record<string, any>)[field.name] = []\n              }\n            }\n          } else {\n            return\n          }\n        }\n        currentRef = ref[field.name as keyof typeof ref]\n      }\n\n      if (\n        (field.type === 'tab' || field.type === 'group') &&\n        fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! }) &&\n        currentRef &&\n        typeof currentRef === 'object'\n      ) {\n        if (fieldAffectsData(field)) {\n          for (const key in currentRef as Record<string, unknown>) {\n            if (currentRef[key as keyof typeof currentRef]) {\n              traverseFields({\n                callback,\n                callbackStack,\n                config,\n                fields: field.fields,\n                fillEmpty,\n                isTopLevel: false,\n                leavesFirst,\n                parentIsLocalized: true,\n                parentPath: field.name ? `${parentPath}${field.name}.` : parentPath,\n                parentRef: currentParentRef,\n                ref: currentRef[key as keyof typeof currentRef],\n              })\n            }\n          }\n        } else {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: field.fields,\n            fillEmpty,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized,\n            parentRef: currentParentRef,\n            ref: currentRef,\n          })\n        }\n\n        return\n      }\n\n      if (\n        (field.type === 'blocks' || field.type === 'array') &&\n        currentRef &&\n        typeof currentRef === 'object'\n      ) {\n        // TODO: `?? field.localized ?? false` shouldn't be necessary, but right now it\n        // is so that all fields are correctly traversed in copyToLocale and\n        // therefore pass the localization integration tests.\n        // I tried replacing the `!parentIsLocalized` condition with `parentIsLocalized === false`\n        // in `fieldShouldBeLocalized`, but several tests failed. We must be calling it with incorrect\n        // parameters somewhere.\n        if (\n          fieldShouldBeLocalized({\n            field,\n            parentIsLocalized: parentIsLocalized ?? false,\n          })\n        ) {\n          if (Array.isArray(currentRef)) {\n            traverseArrayOrBlocksField({\n              callback,\n              callbackStack,\n              config,\n              data: currentRef,\n              field,\n              fillEmpty,\n              leavesFirst,\n              parentIsLocalized: true,\n              parentPath,\n              parentRef: currentParentRef,\n            })\n          } else {\n            for (const key in currentRef as Record<string, unknown>) {\n              const localeData = currentRef[key as keyof typeof currentRef]\n              if (!Array.isArray(localeData)) {\n                continue\n              }\n\n              traverseArrayOrBlocksField({\n                callback,\n                callbackStack,\n                config,\n                data: localeData,\n                field,\n                fillEmpty,\n                leavesFirst,\n                parentIsLocalized: true,\n                parentPath,\n                parentRef: currentParentRef,\n              })\n            }\n          }\n        } else if (Array.isArray(currentRef)) {\n          traverseArrayOrBlocksField({\n            callback,\n            callbackStack,\n            config,\n            data: currentRef as Record<string, unknown>[],\n            field,\n            fillEmpty,\n            leavesFirst,\n            parentIsLocalized: parentIsLocalized!,\n            parentPath,\n            parentRef: currentParentRef,\n          })\n        }\n      } else if (currentRef && typeof currentRef === 'object' && 'fields' in field) {\n        traverseFields({\n          callback,\n          callbackStack,\n          config,\n          fields: field.fields,\n          fillEmpty,\n          isTopLevel: false,\n          leavesFirst,\n          parentIsLocalized,\n          parentPath: 'name' in field && field.name ? `${parentPath}${field.name}.` : parentPath,\n          parentRef: currentParentRef,\n          ref: currentRef,\n        })\n      }\n    }\n\n    if (isTopLevel) {\n      callbackStack.reverse().forEach((cb) => {\n        cb()\n      })\n    }\n  })\n\n  // Fallback: Handle dot-notation paths when no fields matched\n  if (!fieldsMatched && ref && typeof ref === 'object') {\n    Object.keys(ref).forEach((key) => {\n      if (key.includes('.')) {\n        // Split on first dot only\n        const firstDotIndex = key.indexOf('.')\n        const fieldName = key.substring(0, firstDotIndex)\n        const remainingPath = key.substring(firstDotIndex + 1)\n\n        // Create nested structure for this field\n        if (!ref[fieldName as keyof typeof ref]) {\n          ;(ref as Record<string, unknown>)[fieldName] = {}\n        }\n\n        const nestedRef = ref[fieldName as keyof typeof ref] as Record<string, unknown>\n\n        // Move the value to the nested structure\n        nestedRef[remainingPath] = (ref as Record<string, unknown>)[key]\n        delete (ref as Record<string, unknown>)[key]\n\n        // Recursively process the newly created nested structure\n        // The field traversal will naturally handle it if the field exists in the schema\n        traverseFields({\n          callback,\n          callbackStack: _callbackStack,\n          config,\n          fields,\n          fillEmpty,\n          isTopLevel: false,\n          leavesFirst,\n          parentIsLocalized,\n          parentPath,\n          parentRef,\n          ref,\n        })\n      }\n    })\n  }\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","fieldShouldBeLocalized","tabHasName","traverseArrayOrBlocksField","callback","callbackStack","config","data","field","fillEmpty","leavesFirst","parentIsLocalized","parentPath","parentRef","type","traverseFields","fields","isTopLevel","localized","name","_block","blockReferences","blocks","block","find","b","slug","ref","blockType","_callbackStack","fieldsMatched","some","skip","next","push","currentRef","currentParentRef","tab","tabs","tabRef","en","key","Array","isArray","localeData","reverse","forEach","cb","Object","keys","includes","firstDotIndex","indexOf","fieldName","substring","remainingPath","nestedRef"],"mappings":"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"}