{"version":3,"sources":["../../../src/queues/errors/handleTaskError.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { JobLog, PayloadRequest } from '../../index.js'\nimport type { RunJobsSilent } from '../localAPI.js'\nimport type { UpdateJobFunction } from '../operations/runJobs/runJob/getUpdateJobFunction.js'\nimport type { TaskError } from './index.js'\n\nimport { getCurrentDate } from '../utilities/getCurrentDate.js'\nimport { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'\nimport { getWorkflowRetryBehavior } from './getWorkflowRetryBehavior.js'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nexport async function handleTaskError({\n  error,\n  req,\n  silent = false,\n  updateJob,\n}: {\n  error: TaskError\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n}): Promise<{\n  hasFinalError: boolean\n}> {\n  const {\n    executedAt,\n    input,\n    job,\n    output,\n    parent,\n    retriesConfig,\n    taskConfig,\n    taskID,\n    taskSlug,\n    taskStatus,\n    workflowConfig,\n  } = error.args\n\n  if (taskConfig?.onFail) {\n    await taskConfig.onFail({\n      input,\n      job,\n      req,\n      taskStatus,\n    })\n  }\n\n  const errorJSON = {\n    name: error.name,\n    cancelled: Boolean('cancelled' in error && error.cancelled),\n    message: error.message,\n    stack: error.stack,\n  }\n\n  const currentDate = getCurrentDate()\n\n  if (job.waitUntil) {\n    // Check if waitUntil is in the past\n    const waitUntil = new Date(job.waitUntil)\n    if (waitUntil < currentDate) {\n      // Outdated waitUntil, remove it\n      delete job.waitUntil\n    }\n  }\n\n  let maxRetries: number = 0\n\n  if (retriesConfig?.attempts === undefined || retriesConfig?.attempts === null) {\n    // Inherit retries from workflow config, if they are undefined and the workflow config has retries configured\n    if (workflowConfig.retries !== undefined && workflowConfig.retries !== null) {\n      maxRetries =\n        typeof workflowConfig.retries === 'object'\n          ? typeof workflowConfig.retries.attempts === 'number'\n            ? workflowConfig.retries.attempts\n            : 0\n          : workflowConfig.retries\n    } else {\n      maxRetries = 0\n    }\n  } else {\n    maxRetries = retriesConfig.attempts\n  }\n\n  const taskLogToPush: JobLog = {\n    id: new ObjectId().toHexString(),\n    completedAt: currentDate.toISOString(),\n    error: errorJSON,\n    executedAt: executedAt.toISOString(),\n    input,\n    output: output ?? {},\n    parent: req.payload.config.jobs.addParentToTaskLog ? parent : undefined,\n    state: 'failed',\n    taskID,\n    taskSlug,\n  }\n\n  if (!taskStatus?.complete && (taskStatus?.totalTried ?? 0) >= maxRetries) {\n    /**\n     * Task reached max retries => workflow will not retry\n     */\n\n    await updateJob({\n      error: errorJSON,\n      hasError: true,\n      log: {\n        $push: taskLogToPush,\n      } as any,\n      processing: false,\n      totalTried: (job.totalTried ?? 0) + 1,\n      waitUntil: job.waitUntil,\n    })\n\n    if (!silent || (typeof silent === 'object' && !silent.error)) {\n      req.payload.logger.error({\n        err: error,\n        job,\n        msg: `Error running task ${taskID}. Attempt ${job.totalTried} - max retries reached`,\n        taskSlug,\n      })\n    }\n    return {\n      hasFinalError: true,\n    }\n  }\n\n  /**\n   * Task can retry:\n   * - If workflow can retry, allow it to retry\n   * - If workflow reached max retries, do not retry and set final error\n   */\n\n  // First set task waitUntil - if the workflow waitUntil is later, it will be updated later\n  const taskWaitUntil: Date = calculateBackoffWaitUntil({\n    retriesConfig,\n    totalTried: taskStatus?.totalTried ?? 0,\n  })\n\n  // Update job's waitUntil only if this waitUntil is later than the current one\n  if (!job.waitUntil || taskWaitUntil > new Date(job.waitUntil)) {\n    job.waitUntil = taskWaitUntil.toISOString()\n  }\n\n  const { hasFinalError, maxWorkflowRetries, waitUntil } = getWorkflowRetryBehavior({\n    job,\n    retriesConfig: workflowConfig.retries,\n  })\n\n  if (!silent || (typeof silent === 'object' && !silent.error)) {\n    req.payload.logger.error({\n      err: error,\n      job,\n      msg: `Error running task ${taskID}. Attempt ${job.totalTried + 1}${maxWorkflowRetries !== undefined ? '/' + (maxWorkflowRetries + 1) : ''}`,\n      taskSlug,\n    })\n  }\n\n  // Update job's waitUntil only if this waitUntil is later than the current one\n  if (waitUntil && (!job.waitUntil || waitUntil > new Date(job.waitUntil))) {\n    job.waitUntil = waitUntil.toISOString()\n  }\n\n  // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n  // we need to ensure the job is updated to reflect the error\n  await updateJob({\n    error: hasFinalError ? errorJSON : undefined,\n    hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n    log: {\n      $push: taskLogToPush,\n    } as any,\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n    waitUntil: job.waitUntil,\n  })\n\n  return {\n    hasFinalError,\n  }\n}\n"],"names":["ObjectIdImport","getCurrentDate","calculateBackoffWaitUntil","getWorkflowRetryBehavior","ObjectId","default","handleTaskError","error","req","silent","updateJob","executedAt","input","job","output","parent","retriesConfig","taskConfig","taskID","taskSlug","taskStatus","workflowConfig","args","onFail","errorJSON","name","cancelled","Boolean","message","stack","currentDate","waitUntil","Date","maxRetries","attempts","undefined","retries","taskLogToPush","id","toHexString","completedAt","toISOString","payload","config","jobs","addParentToTaskLog","state","complete","totalTried","hasError","log","$push","processing","logger","err","msg","hasFinalError","taskWaitUntil","maxWorkflowRetries"],"mappings":"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"}