{"version":3,"sources":["../../../src/queues/errors/handleWorkflowError.ts"],"sourcesContent":["import type { PayloadRequest } from '../../index.js'\nimport type { RunJobsSilent } from '../localAPI.js'\nimport type { UpdateJobFunction } from '../operations/runJobs/runJob/getUpdateJobFunction.js'\nimport type { WorkflowError } from './index.js'\n\nimport { getCurrentDate } from '../utilities/getCurrentDate.js'\nimport { getWorkflowRetryBehavior } from './getWorkflowRetryBehavior.js'\n\n/**\n * This is called if a workflow catches an error. It determines if it's a final error\n * or not and handles logging.\n * A Workflow error = error that happens anywhere in between running tasks.\n *\n * This function assumes that the error is not a TaskError, but a WorkflowError. If a task errors,\n * only a TaskError should be thrown, not a WorkflowError.\n */\nexport async function handleWorkflowError({\n  error,\n  req,\n  silent = false,\n  updateJob,\n}: {\n  error: WorkflowError\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n}): Promise<{\n  hasFinalError: boolean\n}> {\n  const { job, workflowConfig } = error.args\n\n  const errorJSON = {\n    name: error.name,\n    cancelled: Boolean('cancelled' in error && error.cancelled),\n    message: error.message,\n    stack: error.stack,\n  }\n\n  const { hasFinalError, maxWorkflowRetries, waitUntil } = getWorkflowRetryBehavior({\n    job,\n    retriesConfig: workflowConfig.retries!,\n  })\n\n  if (!hasFinalError) {\n    if (job.waitUntil) {\n      // Check if waitUntil is in the past\n      const waitUntil = new Date(job.waitUntil)\n      if (waitUntil < getCurrentDate()) {\n        // Outdated waitUntil, remove it\n        delete job.waitUntil\n      }\n    }\n\n    // Update job's waitUntil only if this waitUntil is later than the current one\n    if (waitUntil && (!job.waitUntil || waitUntil > new Date(job.waitUntil))) {\n      job.waitUntil = waitUntil.toISOString()\n    }\n  }\n\n  const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n\n  if (!silent || (typeof silent === 'object' && !silent.error)) {\n    req.payload.logger.error({\n      err: error,\n      msg: `Error running job ${jobLabel} id: ${job.id} attempt ${job.totalTried + 1}${maxWorkflowRetries !== undefined ? '/' + (maxWorkflowRetries + 1) : ''}`,\n    })\n  }\n\n  // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n  // we need to ensure the job is updated to reflect the error\n  await updateJob({\n    error: errorJSON,\n    hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n    waitUntil: job.waitUntil,\n  })\n\n  return {\n    hasFinalError,\n  }\n}\n"],"names":["getCurrentDate","getWorkflowRetryBehavior","handleWorkflowError","error","req","silent","updateJob","job","workflowConfig","args","errorJSON","name","cancelled","Boolean","message","stack","hasFinalError","maxWorkflowRetries","waitUntil","retriesConfig","retries","Date","toISOString","jobLabel","workflowSlug","taskSlug","payload","logger","err","msg","id","totalTried","undefined","hasError","processing"],"mappings":"AAKA,SAASA,cAAc,QAAQ,iCAAgC;AAC/D,SAASC,wBAAwB,QAAQ,gCAA+B;AAExE;;;;;;;CAOC,GACD,OAAO,eAAeC,oBAAoB,EACxCC,KAAK,EACLC,GAAG,EACHC,SAAS,KAAK,EACdC,SAAS,EAcV;IAGC,MAAM,EAAEC,GAAG,EAAEC,cAAc,EAAE,GAAGL,MAAMM,IAAI;IAE1C,MAAMC,YAAY;QAChBC,MAAMR,MAAMQ,IAAI;QAChBC,WAAWC,QAAQ,eAAeV,SAASA,MAAMS,SAAS;QAC1DE,SAASX,MAAMW,OAAO;QACtBC,OAAOZ,MAAMY,KAAK;IACpB;IAEA,MAAM,EAAEC,aAAa,EAAEC,kBAAkB,EAAEC,SAAS,EAAE,GAAGjB,yBAAyB;QAChFM;QACAY,eAAeX,eAAeY,OAAO;IACvC;IAEA,IAAI,CAACJ,eAAe;QAClB,IAAIT,IAAIW,SAAS,EAAE;YACjB,oCAAoC;YACpC,MAAMA,YAAY,IAAIG,KAAKd,IAAIW,SAAS;YACxC,IAAIA,YAAYlB,kBAAkB;gBAChC,gCAAgC;gBAChC,OAAOO,IAAIW,SAAS;YACtB;QACF;QAEA,8EAA8E;QAC9E,IAAIA,aAAc,CAAA,CAACX,IAAIW,SAAS,IAAIA,YAAY,IAAIG,KAAKd,IAAIW,SAAS,CAAA,GAAI;YACxEX,IAAIW,SAAS,GAAGA,UAAUI,WAAW;QACvC;IACF;IAEA,MAAMC,WAAWhB,IAAIiB,YAAY,IAAI,CAAC,MAAM,EAAEjB,IAAIkB,QAAQ,EAAE;IAE5D,IAAI,CAACpB,UAAW,OAAOA,WAAW,YAAY,CAACA,OAAOF,KAAK,EAAG;QAC5DC,IAAIsB,OAAO,CAACC,MAAM,CAACxB,KAAK,CAAC;YACvByB,KAAKzB;YACL0B,KAAK,CAAC,kBAAkB,EAAEN,SAAS,KAAK,EAAEhB,IAAIuB,EAAE,CAAC,SAAS,EAAEvB,IAAIwB,UAAU,GAAG,IAAId,uBAAuBe,YAAY,MAAOf,CAAAA,qBAAqB,CAAA,IAAK,IAAI;QAC3J;IACF;IAEA,4HAA4H;IAC5H,4DAA4D;IAC5D,MAAMX,UAAU;QACdH,OAAOO;QACPuB,UAAUjB;QACVkB,YAAY;QACZH,YAAY,AAACxB,CAAAA,IAAIwB,UAAU,IAAI,CAAA,IAAK;QACpCb,WAAWX,IAAIW,SAAS;IAC1B;IAEA,OAAO;QACLF;IACF;AACF"}