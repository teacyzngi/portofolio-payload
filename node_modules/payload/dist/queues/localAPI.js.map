{"version":3,"sources":["../../src/queues/localAPI.ts"],"sourcesContent":["import type { BaseJob, RunningJobFromTask } from './config/types/workflowTypes.js'\n\nimport {\n  createLocalReq,\n  type Job,\n  type Payload,\n  type PayloadRequest,\n  type Sort,\n  type TypedJobs,\n  type Where,\n} from '../index.js'\nimport { jobAfterRead, jobsCollectionSlug } from './config/collection.js'\nimport { handleSchedules, type HandleSchedulesResult } from './operations/handleSchedules/index.js'\nimport { runJobs } from './operations/runJobs/index.js'\nimport { updateJob, updateJobs } from './utilities/updateJob.js'\n\nexport type RunJobsSilent =\n  | {\n      error?: boolean\n      info?: boolean\n    }\n  | boolean\nexport const getJobsLocalAPI = (payload: Payload) => ({\n  handleSchedules: async (args?: {\n    /**\n     * If you want to schedule jobs from all queues, set this to true.\n     * If you set this to true, the `queue` property will be ignored.\n     *\n     * @default false\n     */\n    allQueues?: boolean\n    // By default, schedule all queues - only scheduling jobs scheduled to be added to the `default` queue would not make sense\n    // here, as you'd usually specify a different queue than `default` here, especially if this is used in combination with autorun.\n    // The `queue` property for setting up schedules is required, and not optional.\n    /**\n     * If you want to only schedule jobs that are set to schedule in a specific queue, set this to the queue name.\n     *\n     * @default jobs from the `default` queue will be executed.\n     */\n    queue?: string\n    req?: PayloadRequest\n  }): Promise<HandleSchedulesResult> => {\n    const newReq: PayloadRequest = args?.req ?? (await createLocalReq({}, payload))\n\n    return await handleSchedules({\n      allQueues: args?.allQueues,\n      queue: args?.queue,\n      req: newReq,\n    })\n  },\n  queue: async <\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] | keyof TypedJobs['workflows'],\n  >(\n    args:\n      | {\n          input: TypedJobs['tasks'][TTaskOrWorkflowSlug]['input']\n          meta?: BaseJob['meta']\n          queue?: string\n          req?: PayloadRequest\n          // TTaskOrWorkflowlug with keyof TypedJobs['workflows'] removed:\n          task: TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] ? TTaskOrWorkflowSlug : never\n          waitUntil?: Date\n          workflow?: never\n        }\n      | {\n          input: TypedJobs['workflows'][TTaskOrWorkflowSlug]['input']\n          meta?: BaseJob['meta']\n          queue?: string\n          req?: PayloadRequest\n          task?: never\n          waitUntil?: Date\n          workflow: TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n            ? TTaskOrWorkflowSlug\n            : never\n        },\n  ): Promise<\n    TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n      ? Job<TTaskOrWorkflowSlug>\n      : RunningJobFromTask<TTaskOrWorkflowSlug>\n  > => {\n    let queue: string | undefined = undefined\n\n    // If user specifies queue, use that\n    if (args.queue) {\n      queue = args.queue\n    } else if (args.workflow) {\n      // Otherwise, if there is a workflow specified, and it has a default queue to use,\n      // use that\n      const workflow = payload.config.jobs?.workflows?.find(({ slug }) => slug === args.workflow)\n      if (workflow?.queue) {\n        queue = workflow.queue\n      }\n    }\n\n    const data: Partial<Job> = {\n      input: args.input,\n    }\n\n    if (queue) {\n      data.queue = queue\n    }\n    if (args.waitUntil) {\n      data.waitUntil = args.waitUntil?.toISOString()\n    }\n    if (args.workflow) {\n      data.workflowSlug = args.workflow as string\n    }\n    if (args.task) {\n      data.taskSlug = args.task as string\n    }\n\n    if (args.meta) {\n      data.meta = args.meta\n    }\n\n    type ReturnType = TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n      ? Job<TTaskOrWorkflowSlug>\n      : RunningJobFromTask<TTaskOrWorkflowSlug> // Type assertion is still needed here\n\n    if (payload?.config?.jobs?.depth || payload?.config?.jobs?.runHooks) {\n      return (await payload.create({\n        collection: jobsCollectionSlug,\n        data,\n        depth: payload.config.jobs.depth ?? 0,\n        req: args.req,\n      })) as ReturnType\n    } else {\n      return jobAfterRead({\n        config: payload.config,\n        doc: await payload.db.create({\n          collection: jobsCollectionSlug,\n          data,\n          req: args.req,\n        }),\n      }) as unknown as ReturnType\n    }\n  },\n\n  run: async (args?: {\n    /**\n     * If you want to run jobs from all queues, set this to true.\n     * If you set this to true, the `queue` property will be ignored.\n     *\n     * @default false\n     */\n    allQueues?: boolean\n    /**\n     * The maximum number of jobs to run in this invocation\n     *\n     * @default 10\n     */\n    limit?: number\n    overrideAccess?: boolean\n    /**\n     * Adjust the job processing order using a Payload sort string.\n     *\n     * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n     */\n    processingOrder?: Sort\n    /**\n     * If you want to run jobs from a specific queue, set this to the queue name.\n     *\n     * @default jobs from the `default` queue will be executed.\n     */\n    queue?: string\n    req?: PayloadRequest\n    /**\n     * By default, jobs are run in parallel.\n     * If you want to run them in sequence, set this to true.\n     */\n    sequential?: boolean\n    /**\n     * If set to true, the job system will not log any output to the console (for both info and error logs).\n     * Can be an option for more granular control over logging.\n     *\n     * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n     *\n     * @default false\n     */\n    silent?: RunJobsSilent\n    where?: Where\n  }): Promise<ReturnType<typeof runJobs>> => {\n    const newReq: PayloadRequest = args?.req ?? (await createLocalReq({}, payload))\n\n    return await runJobs({\n      allQueues: args?.allQueues,\n      limit: args?.limit,\n      overrideAccess: args?.overrideAccess !== false,\n      processingOrder: args?.processingOrder,\n      queue: args?.queue,\n      req: newReq,\n      sequential: args?.sequential,\n      silent: args?.silent,\n      where: args?.where,\n    })\n  },\n\n  runByID: async (args: {\n    id: number | string\n    overrideAccess?: boolean\n    req?: PayloadRequest\n    /**\n     * If set to true, the job system will not log any output to the console (for both info and error logs).\n     * Can be an option for more granular control over logging.\n     *\n     * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n     *\n     * @default false\n     */\n    silent?: RunJobsSilent\n  }): Promise<ReturnType<typeof runJobs>> => {\n    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    return await runJobs({\n      id: args.id,\n      overrideAccess: args.overrideAccess !== false,\n      req: newReq,\n      silent: args.silent,\n    })\n  },\n\n  cancel: async (args: {\n    overrideAccess?: boolean\n    queue?: string\n    req?: PayloadRequest\n    where: Where\n  }): Promise<void> => {\n    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    const and: Where[] = [\n      args.where,\n      {\n        completedAt: {\n          exists: false,\n        },\n      },\n      {\n        hasError: {\n          not_equals: true,\n        },\n      },\n    ]\n\n    if (args.queue) {\n      and.push({\n        queue: {\n          equals: args.queue,\n        },\n      })\n    }\n\n    await updateJobs({\n      data: {\n        completedAt: null,\n        error: {\n          cancelled: true,\n        },\n        hasError: true,\n        processing: false,\n        waitUntil: null,\n      },\n      depth: 0, // No depth, since we're not returning\n      disableTransaction: true,\n      req: newReq,\n      returning: false,\n      where: { and },\n    })\n  },\n\n  cancelByID: async (args: {\n    id: number | string\n    overrideAccess?: boolean\n    req?: PayloadRequest\n  }): Promise<void> => {\n    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    await updateJob({\n      id: args.id,\n      data: {\n        completedAt: null,\n        error: {\n          cancelled: true,\n        },\n        hasError: true,\n        processing: false,\n        waitUntil: null,\n      },\n      depth: 0, // No depth, since we're not returning\n      disableTransaction: true,\n      req: newReq,\n      returning: false,\n    })\n  },\n})\n"],"names":["createLocalReq","jobAfterRead","jobsCollectionSlug","handleSchedules","runJobs","updateJob","updateJobs","getJobsLocalAPI","payload","args","newReq","req","allQueues","queue","undefined","workflow","config","jobs","workflows","find","slug","data","input","waitUntil","toISOString","workflowSlug","task","taskSlug","meta","depth","runHooks","create","collection","doc","db","run","limit","overrideAccess","processingOrder","sequential","silent","where","runByID","id","cancel","and","completedAt","exists","hasError","not_equals","push","equals","error","cancelled","processing","disableTransaction","returning","cancelByID"],"mappings":"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"}