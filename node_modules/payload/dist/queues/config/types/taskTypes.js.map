{"version":3,"sources":["../../../../src/queues/config/types/taskTypes.ts"],"sourcesContent":["import type { Field, Job, PayloadRequest, StringKeyOf, TypedJobs } from '../../../index.js'\nimport type { ScheduleConfig } from './index.js'\nimport type { SingleTaskStatus } from './workflowTypes.js'\n\nexport type TaskInputOutput = {\n  input: object\n  output: object\n}\nexport type TaskHandlerResult<\n  TTaskSlugOrInputOutput extends keyof TypedJobs['tasks'] | TaskInputOutput,\n> =\n  | {\n      errorMessage?: string\n      state: 'failed'\n    }\n  | {\n      output: TTaskSlugOrInputOutput extends keyof TypedJobs['tasks']\n        ? TypedJobs['tasks'][TTaskSlugOrInputOutput]['output']\n        : TTaskSlugOrInputOutput extends TaskInputOutput // Check if it's actually TaskInputOutput type\n          ? TTaskSlugOrInputOutput['output']\n          : never\n      state?: 'succeeded'\n    }\n\nexport type TaskHandlerArgs<\n  TTaskSlugOrInputOutput extends keyof TypedJobs['tasks'] | TaskInputOutput,\n  TWorkflowSlug extends keyof TypedJobs['workflows'] = string,\n> = {\n  /**\n   * Use this function to run a sub-task from within another task.\n   */\n  inlineTask: RunInlineTaskFunction\n  input: TTaskSlugOrInputOutput extends keyof TypedJobs['tasks']\n    ? TypedJobs['tasks'][TTaskSlugOrInputOutput]['input']\n    : TTaskSlugOrInputOutput extends TaskInputOutput // Check if it's actually TaskInputOutput type\n      ? TTaskSlugOrInputOutput['input']\n      : never\n  job: Job<TWorkflowSlug>\n  req: PayloadRequest\n  tasks: RunTaskFunctions\n}\n\n/**\n * Inline tasks in JSON workflows have no input, as they can just get the input from job.taskStatus\n */\nexport type TaskHandlerArgsNoInput<TWorkflowInput extends false | object = false> = {\n  job: Job<TWorkflowInput>\n  req: PayloadRequest\n}\n\nexport type TaskHandler<\n  TTaskSlugOrInputOutput extends keyof TypedJobs['tasks'] | TaskInputOutput,\n  TWorkflowSlug extends keyof TypedJobs['workflows'] = string,\n> = (\n  args: TaskHandlerArgs<TTaskSlugOrInputOutput, TWorkflowSlug>,\n) => Promise<TaskHandlerResult<TTaskSlugOrInputOutput>> | TaskHandlerResult<TTaskSlugOrInputOutput>\n\n/**\n * @todo rename to TaskSlug in 4.0, similar to CollectionSlug\n */\nexport type TaskType = StringKeyOf<TypedJobs['tasks']>\n\n// Extracts the type of `input` corresponding to each task\nexport type TaskInput<T extends keyof TypedJobs['tasks']> = TypedJobs['tasks'][T]['input']\n\nexport type TaskOutput<T extends keyof TypedJobs['tasks']> = TypedJobs['tasks'][T]['output']\n\nexport type TaskHandlerResults = {\n  [TTaskSlug in keyof TypedJobs['tasks']]: {\n    [id: string]: TaskHandlerResult<TTaskSlug>\n  }\n}\n\n// Helper type to create correct argument type for the function corresponding to each task.\nexport type RunTaskFunctionArgs<TTaskSlug extends keyof TypedJobs['tasks']> = {\n  input?: TaskInput<TTaskSlug>\n  /**\n   * Specify the number of times that this task should be retried if it fails for any reason.\n   * If this is undefined, the task will either inherit the retries from the workflow or have no retries.\n   * If this is 0, the task will not be retried.\n   *\n   * @default By default, tasks are not retried and `retries` is `undefined`.\n   */\n  retries?: number | RetryConfig | undefined\n}\n\nexport type RunTaskFunction<TTaskSlug extends keyof TypedJobs['tasks']> = (\n  taskID: string,\n  taskArgs?: RunTaskFunctionArgs<TTaskSlug>,\n) => Promise<TaskOutput<TTaskSlug>>\n\nexport type RunTaskFunctions = {\n  [TTaskSlug in keyof TypedJobs['tasks']]: RunTaskFunction<TTaskSlug>\n}\n\ntype MaybePromise<T> = Promise<T> | T\n\nexport type RunInlineTaskFunction = <TTaskInput extends object, TTaskOutput extends object>(\n  taskID: string,\n  taskArgs: {\n    input?: TTaskInput\n    /**\n     * Specify the number of times that this task should be retried if it fails for any reason.\n     * If this is undefined, the task will either inherit the retries from the workflow or have no retries.\n     * If this is 0, the task will not be retried.\n     *\n     * @default By default, tasks are not retried and `retries` is `undefined`.\n     */\n    retries?: number | RetryConfig | undefined\n    // This is the same as TaskHandler, but typed out explicitly in order to improve type inference\n    task: (args: {\n      inlineTask: RunInlineTaskFunction\n      input: TTaskInput\n      job: Job<any>\n      req: PayloadRequest\n      tasks: RunTaskFunctions\n    }) => MaybePromise<\n      | {\n          errorMessage?: string\n          state: 'failed'\n        }\n      | {\n          output: TTaskOutput\n          state?: 'succeeded'\n        }\n    >\n  },\n) => Promise<TTaskOutput>\n\nexport type TaskCallbackArgs = {\n  /**\n   * Input data passed to the task\n   */\n  input?: object\n  job: Job\n  req: PayloadRequest\n  taskStatus: null | SingleTaskStatus<string>\n}\n\nexport type ShouldRestoreFn = (\n  args: { taskStatus: SingleTaskStatus<string> } & Omit<TaskCallbackArgs, 'taskStatus'>,\n) => boolean | Promise<boolean>\nexport type TaskCallbackFn = (args: TaskCallbackArgs) => Promise<void> | void\n\nexport type RetryConfig = {\n  /**\n   * This controls how many times the task should be retried if it fails.\n   *\n   * @default undefined - attempts are either inherited from the workflow retry config or set to 0.\n   */\n  attempts?: number\n  /**\n   * The backoff strategy to use when retrying the task. This determines how long to wait before retrying the task.\n   *\n   * If this is set on a single task, the longest backoff time of a task will determine the time until the entire workflow is retried.\n   */\n  backoff?: {\n    /**\n     * Base delay between running jobs in ms\n     */\n    delay?: number\n    /**\n     * @default fixed\n     *\n     * The backoff strategy to use when retrying the task. This determines how long to wait before retrying the task.\n     * If fixed (default) is used, the delay will be the same between each retry.\n     *\n     * If exponential is used, the delay will increase exponentially with each retry.\n     *\n     * @example\n     * delay = 1000\n     * attempts = 3\n     * type = 'fixed'\n     *\n     * The task will be retried 3 times with a delay of 1000ms between each retry.\n     *\n     * @example\n     * delay = 1000\n     * attempts = 3\n     * type = 'exponential'\n     *\n     * The task will be retried 3 times with a delay of 1000ms, 2000ms, and 4000ms between each retry.\n     */\n    type: 'exponential' | 'fixed'\n  }\n  /**\n   * This controls whether the task output should be restored if the task previously succeeded and the workflow is being retried.\n   *\n   * If this is set to false, the task will be re-run even if it previously succeeded, ignoring the maximum number of retries.\n   *\n   * If this is set to true, the task will only be re-run if it previously failed.\n   *\n   * If this is a function, the return value of the function will determine whether the task should be re-run. This can be used for more complex restore logic,\n   * e.g you may want to re-run a task up until a certain point and then restore it, or only re-run a task if the input has changed.\n   *\n   * @default true - the task output will be restored if the task previously succeeded.\n   */\n  shouldRestore?: boolean | ShouldRestoreFn\n}\n\nexport type TaskConfig<\n  TTaskSlugOrInputOutput extends keyof TypedJobs['tasks'] | TaskInputOutput = TaskType,\n> = {\n  /**\n   * The function that should be responsible for running the job.\n   * You can either pass a string-based path to the job function file, or the job function itself.\n   *\n   * If you are using large dependencies within your job, you might prefer to pass the string path\n   * because that will avoid bundling large dependencies in your Next.js app. Passing a string path is an advanced feature\n   * that may require a sophisticated build pipeline in order to work.\n   */\n  handler: string | TaskHandler<TTaskSlugOrInputOutput>\n  /**\n   * Define the input field schema - payload will generate a type for this schema.\n   */\n  inputSchema?: Field[]\n  /**\n   * You can use interfaceName to change the name of the interface that is generated for this task. By default, this is \"Task\" + the capitalized task slug.\n   */\n  interfaceName?: string\n  /**\n   * Define a human-friendly label for this task.\n   */\n  label?: string\n  /**\n   * Function to be executed if the task fails.\n   */\n  onFail?: TaskCallbackFn\n  /**\n   * Function to be executed if the task succeeds.\n   */\n  onSuccess?: TaskCallbackFn\n  /**\n   * Define the output field schema - payload will generate a type for this schema.\n   */\n  outputSchema?: Field[]\n  /**\n   * Specify the number of times that this step should be retried if it fails.\n   * If this is undefined, the task will either inherit the retries from the workflow or have no retries.\n   * If this is 0, the task will not be retried.\n   *\n   * @default By default, tasks are not retried and `retries` is `undefined`.\n   */\n  retries?: number | RetryConfig | undefined\n  /**\n   * Allows automatically scheduling this task to run regularly at a specified interval.\n   */\n  schedule?: ScheduleConfig[]\n  /**\n   * Define a slug-based name for this job. This slug needs to be unique among both tasks and workflows.\n   */\n  slug: TTaskSlugOrInputOutput extends keyof TypedJobs['tasks'] ? TTaskSlugOrInputOutput : string\n}\n"],"names":[],"mappings":"AAwMA,WAoDC"}