{"version":3,"sources":["../../../../src/queues/config/types/index.ts"],"sourcesContent":["import type { CollectionConfig, Job } from '../../../index.js'\nimport type { Payload, PayloadRequest, Sort } from '../../../types/index.js'\nimport type { RunJobsSilent } from '../../localAPI.js'\nimport type { RunJobsArgs } from '../../operations/runJobs/index.js'\nimport type { JobStats } from '../global.js'\nimport type { TaskConfig } from './taskTypes.js'\nimport type { WorkflowConfig } from './workflowTypes.js'\n\nexport type AutorunCronConfig = {\n  /**\n   * If you want to autoRUn jobs from all queues, set this to true.\n   * If you set this to true, the `queue` property will be ignored.\n   *\n   * @default false\n   */\n  allQueues?: boolean\n  /**\n   * The cron schedule for the job.\n   * @default '* * * * *' (every minute).\n   *\n   * @example\n   *     ┌───────────── (optional) second (0 - 59)\n   *     │ ┌───────────── minute (0 - 59)\n   *     │ │ ┌───────────── hour (0 - 23)\n   *     │ │ │ ┌───────────── day of the month (1 - 31)\n   *     │ │ │ │ ┌───────────── month (1 - 12)\n   *     │ │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n   *     │ │ │ │ │ │\n   *     │ │ │ │ │ │\n   *  - '* 0 * * * *' every hour at minute 0\n   *  - '* 0 0 * * *' daily at midnight\n   *  - '* 0 0 * * 0' weekly at midnight on Sundays\n   *  - '* 0 0 1 * *' monthly at midnight on the 1st day of the month\n   *  - '* 0/5 * * * *' every 5 minutes\n   *  - '* * * * * *' every second\n   */\n  cron?: string\n  /**\n   * By default, the autorun will attempt to schedule jobs for tasks and workflows that have a `schedule` property, given\n   * the queue name is the same.\n   *\n   * Set this to `true` to disable the scheduling of jobs automatically.\n   *\n   * @default false\n   */\n  disableScheduling?: boolean\n  /**\n   * The limit for the job. This can be overridden by the user. Defaults to 10.\n   */\n  limit?: number\n  /**\n   * The queue name for the job.\n   *\n   * @default 'default'\n   */\n  queue?: string\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n}\n\nexport type RunJobAccessArgs = {\n  req: PayloadRequest\n}\n\nexport type RunJobAccess = (args: RunJobAccessArgs) => boolean | Promise<boolean>\n\nexport type SanitizedJobsConfig = {\n  /**\n   * If set to `true`, the job system is enabled and a payload-jobs collection exists.\n   * This property is automatically set during sanitization.\n   */\n  enabled?: boolean\n  /**\n   * If set to `true`, at least one task or workflow has scheduling enabled.\n   * This property is automatically set during sanitization.\n   */\n  scheduling?: boolean\n  /**\n   * If set to `true`, a payload-job-stats global exists.\n   * This property is automatically set during sanitization.\n   */\n  stats?: boolean\n} & JobsConfig\nexport type JobsConfig = {\n  /**\n   * Specify access control to determine who can interact with jobs.\n   */\n  access?: {\n    /**\n     * By default, all logged-in users can trigger jobs.\n     */\n    run?: RunJobAccess\n  }\n  /** Adds information about the parent job to the task log. This is useful for debugging and tracking the flow of tasks.\n   *\n   * In 4.0, this will default to `true`.\n   *\n   * @default false\n   */\n  addParentToTaskLog?: boolean\n  /**\n   * Allows you to configure cron jobs that automatically run queued jobs\n   * at specified intervals. Note that this does not _queue_ new jobs - only\n   * _runs_ jobs that are already in the specified queue.\n   *\n   * @remark this property should not be used on serverless platforms like Vercel\n   */\n  autoRun?:\n    | ((payload: Payload) => AutorunCronConfig[] | Promise<AutorunCronConfig[]>)\n    | AutorunCronConfig[]\n  /**\n   * Determine whether or not to delete a job after it has successfully completed.\n   */\n  deleteJobOnComplete?: boolean\n  /**\n   * Specify depth for retrieving jobs from the queue.\n   * This should be as low as possible in order for job retrieval\n   * to be as efficient as possible. Setting it to anything higher than\n   * 0 will drastically affect performance, as less efficient database\n   * queries will be used.\n   *\n   * @default 0\n   */\n  depth?: number\n  /**\n   * Override any settings on the default Jobs collection. Accepts the default collection and allows you to return\n   * a new collection.\n   */\n  jobsCollectionOverrides?: (args: { defaultJobsCollection: CollectionConfig }) => CollectionConfig\n  /**\n   * Adjust the job processing order using a Payload sort string. This can be set globally or per queue.\n   *\n   * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n   *\n   * @default all jobs for all queues will be executed in FIFO order.\n   */\n  processingOrder?:\n    | ((args: RunJobsArgs) => Promise<Sort> | Sort)\n    | {\n        default?: Sort\n        queues: {\n          [queue: string]: Sort\n        }\n      }\n    | Sort\n  /**\n   * By default, the job system uses direct database calls for optimal performance.\n   * If you added custom hooks to your jobs collection, you can set this to true to\n   * use the standard Payload API for all job operations. This is discouraged, as it will\n   * drastically affect performance.\n   *\n   * @default false\n   * @deprecated - this will be removed in 4.0\n   */\n  runHooks?: boolean\n  /**\n   * A function that will be executed before Payload picks up jobs which are configured by the `jobs.autorun` function.\n   * If this function returns true, jobs will be queried and picked up. If it returns false, jobs will not be run.\n   * @default undefined - if this function is not defined, jobs will be run - as if () => true was passed.\n   * @param payload\n   * @returns boolean\n   */\n  shouldAutoRun?: (payload: Payload) => boolean | Promise<boolean>\n  /**\n   * Define all possible tasks here\n   */\n  tasks?: TaskConfig<any>[]\n  /**\n   * Define all the workflows here. Workflows orchestrate the flow of multiple tasks.\n   */\n  workflows?: WorkflowConfig<any>[]\n}\n\nexport type Queueable = {\n  scheduleConfig: ScheduleConfig\n  taskConfig?: TaskConfig\n  // If not set, queue it immediately\n  waitUntil?: Date\n  workflowConfig?: WorkflowConfig\n}\n\ntype OptionalPromise<T> = Promise<T> | T\n\nexport type BeforeScheduleFn = (args: {\n  defaultBeforeSchedule: BeforeScheduleFn\n  /**\n   * payload-job-stats global data\n   */\n  jobStats: JobStats\n  queueable: Queueable\n  req: PayloadRequest\n}) => OptionalPromise<{\n  input?: object\n  shouldSchedule: boolean\n  waitUntil?: Date\n}>\n\nexport type AfterScheduleFn = (\n  args: {\n    defaultAfterSchedule: AfterScheduleFn\n    /**\n     * payload-job-stats global data. If the global does not exist, it will be null.\n     */\n    jobStats: JobStats | null\n    queueable: Queueable\n    req: PayloadRequest\n  } & (\n    | {\n        error: Error\n        job?: never\n        status: 'error'\n      }\n    | {\n        error?: never\n        job: Job\n        status: 'success'\n      }\n    | {\n        error?: never\n        job?: never\n        /**\n         * If the beforeSchedule hook returned `shouldSchedule: false`, this will be called with status `skipped`.\n         */\n        status: 'skipped'\n      }\n  ),\n) => OptionalPromise<void>\n\nexport type ScheduleConfig = {\n  /**\n   * The cron for scheduling the job.\n   *\n   * @example\n   *     ┌───────────── (optional) second (0 - 59)\n   *     │ ┌───────────── minute (0 - 59)\n   *     │ │ ┌───────────── hour (0 - 23)\n   *     │ │ │ ┌───────────── day of the month (1 - 31)\n   *     │ │ │ │ ┌───────────── month (1 - 12)\n   *     │ │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)\n   *     │ │ │ │ │ │\n   *     │ │ │ │ │ │\n   *  - '* 0 * * * *' every hour at minute 0\n   *  - '* 0 0 * * *' daily at midnight\n   *  - '* 0 0 * * 0' weekly at midnight on Sundays\n   *  - '* 0 0 1 * *' monthly at midnight on the 1st day of the month\n   *  - '* 0/5 * * * *' every 5 minutes\n   *  - '* * * * * *' every second\n   */\n  cron: string\n  hooks?: {\n    /**\n     * Functions that will be executed after the job has been successfully scheduled.\n     *\n     * @default By default, global update?? Unless global update should happen before\n     */\n    afterSchedule?: AfterScheduleFn\n    /**\n     * Functions that will be executed before the job is scheduled.\n     * You can use this to control whether or not the job should be scheduled, or what input\n     * data should be passed to the job.\n     *\n     * @default By default, this has one function that returns { shouldSchedule: true } if the following conditions are met:\n     * - There currently is no job of the same type in the specified queue that is currently running\n     * - There currently is no job of the same type in the specified queue that is scheduled to run in the future\n     * - There currently is no job of the same type in the specified queue that failed previously but can be retried\n     */\n    beforeSchedule?: BeforeScheduleFn\n  }\n  /**\n   * Queue to which the scheduled job will be added.\n   */\n  queue: string\n}\n"],"names":[],"mappings":"AA2OA,WA4CC"}