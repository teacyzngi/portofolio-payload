{"version":3,"sources":["../../../src/queues/config/generateJobsJSONSchemas.ts"],"sourcesContent":["import type { I18n } from '@payloadcms/translations'\nimport type { JSONSchema4 } from 'json-schema'\n\nimport type { SanitizedConfig } from '../../config/types.js'\nimport type { JobsConfig } from './types/index.js'\n\nimport { fieldsToJSONSchema } from '../../utilities/configToJSONSchema.js'\nimport { flattenAllFields } from '../../utilities/flattenAllFields.js'\nexport function generateJobsJSONSchemas(\n  config: SanitizedConfig,\n  jobsConfig: JobsConfig,\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  /**\n   * Used for relationship fields, to determine whether to use a string or number type for the ID.\n   * While there is a default ID field type set by the db adapter, they can differ on a collection-level\n   * if they have custom ID fields.\n   */\n  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },\n  i18n?: I18n,\n): {\n  definitions?: Map<string, JSONSchema4>\n  properties?: { tasks: JSONSchema4 }\n} {\n  const properties: { tasks: JSONSchema4; workflows: JSONSchema4 } = {\n    tasks: {},\n    workflows: {},\n  }\n  const definitions: Map<string, JSONSchema4> = new Map()\n\n  if (jobsConfig?.tasks?.length) {\n    for (const task of jobsConfig.tasks) {\n      const fullTaskJsonSchema: JSONSchema4 = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n          input: {},\n          output: {},\n        },\n        required: [],\n      }\n      if (task?.inputSchema?.length) {\n        const inputJsonSchema = fieldsToJSONSchema(\n          collectionIDFieldTypes,\n          flattenAllFields({ fields: task.inputSchema }),\n          interfaceNameDefinitions,\n          config,\n          i18n,\n        )\n\n        const fullInputJsonSchema: JSONSchema4 = {\n          type: 'object',\n          additionalProperties: false,\n          properties: inputJsonSchema.properties,\n          required: inputJsonSchema.required,\n        }\n\n        fullTaskJsonSchema.properties!.input = fullInputJsonSchema\n        ;(fullTaskJsonSchema.required as string[]).push('input')\n      }\n      if (task?.outputSchema?.length) {\n        const outputJsonSchema = fieldsToJSONSchema(\n          collectionIDFieldTypes,\n          flattenAllFields({ fields: task.outputSchema }),\n          interfaceNameDefinitions,\n          config,\n          i18n,\n        )\n\n        const fullOutputJsonSchema: JSONSchema4 = {\n          type: 'object',\n          additionalProperties: false,\n          properties: outputJsonSchema.properties,\n          required: outputJsonSchema.required,\n        }\n\n        fullTaskJsonSchema.properties!.output = fullOutputJsonSchema\n        ;(fullTaskJsonSchema.required as string[]).push('output')\n      }\n\n      const normalizedTaskSlug = task.slug[0].toUpperCase() + task.slug.slice(1)\n\n      definitions.set(task.interfaceName ?? `Task${normalizedTaskSlug}`, fullTaskJsonSchema)\n    }\n    // Now add properties.tasks definition that references the types in definitions keyed by task slug:\n    properties.tasks = {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        ...Object.fromEntries(\n          (jobsConfig.tasks ?? []).map((task) => {\n            const normalizedTaskSlug = task.slug[0].toUpperCase() + task.slug.slice(1)\n\n            const toReturn: JSONSchema4 = {\n              $ref: task.interfaceName\n                ? `#/definitions/${task.interfaceName}`\n                : `#/definitions/Task${normalizedTaskSlug}`,\n            }\n\n            return [task.slug, toReturn]\n          }),\n        ),\n        inline: {\n          type: 'object',\n          additionalProperties: false,\n          properties: {\n            input: {},\n            output: {},\n          },\n          required: ['input', 'output'],\n        },\n      },\n      required: [...(jobsConfig.tasks ?? []).map((task) => task.slug), 'inline'],\n    }\n  }\n\n  if (jobsConfig?.workflows?.length) {\n    for (const workflow of jobsConfig.workflows) {\n      const fullWorkflowJsonSchema: JSONSchema4 = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n          input: {},\n        },\n        required: [],\n      }\n\n      if (workflow?.inputSchema?.length) {\n        const inputJsonSchema = fieldsToJSONSchema(\n          collectionIDFieldTypes,\n          flattenAllFields({ fields: workflow.inputSchema }),\n          interfaceNameDefinitions,\n          config,\n          i18n,\n        )\n\n        const fullInputJsonSchema: JSONSchema4 = {\n          type: 'object',\n          additionalProperties: false,\n          properties: inputJsonSchema.properties,\n          required: inputJsonSchema.required,\n        }\n\n        fullWorkflowJsonSchema.properties!.input = fullInputJsonSchema\n        ;(fullWorkflowJsonSchema.required as string[]).push('input')\n      }\n      const normalizedWorkflowSlug = workflow.slug[0].toUpperCase() + workflow.slug.slice(1)\n\n      definitions.set(\n        workflow.interfaceName ?? `Workflow${normalizedWorkflowSlug}`,\n        fullWorkflowJsonSchema,\n      )\n\n      properties.workflows = {\n        type: 'object',\n        additionalProperties: false,\n        properties: Object.fromEntries(\n          jobsConfig.workflows.map((workflow) => {\n            const normalizedWorkflowSlug = workflow.slug[0].toUpperCase() + workflow.slug.slice(1)\n\n            const toReturn: JSONSchema4 = {\n              $ref: workflow.interfaceName\n                ? `#/definitions/${workflow.interfaceName}`\n                : `#/definitions/Workflow${normalizedWorkflowSlug}`,\n            }\n\n            return [workflow.slug, toReturn]\n          }),\n        ),\n        required: jobsConfig.workflows.map((workflow) => workflow.slug),\n      }\n    }\n  }\n\n  return {\n    definitions,\n    properties,\n  }\n}\n"],"names":["fieldsToJSONSchema","flattenAllFields","generateJobsJSONSchemas","config","jobsConfig","interfaceNameDefinitions","collectionIDFieldTypes","i18n","properties","tasks","workflows","definitions","Map","length","task","fullTaskJsonSchema","type","additionalProperties","input","output","required","inputSchema","inputJsonSchema","fields","fullInputJsonSchema","push","outputSchema","outputJsonSchema","fullOutputJsonSchema","normalizedTaskSlug","slug","toUpperCase","slice","set","interfaceName","Object","fromEntries","map","toReturn","$ref","inline","workflow","fullWorkflowJsonSchema","normalizedWorkflowSlug"],"mappings":"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"}