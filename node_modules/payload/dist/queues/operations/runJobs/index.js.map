{"version":3,"sources":["../../../../src/queues/operations/runJobs/index.ts"],"sourcesContent":["import type { Job } from '../../../index.js'\nimport type { PayloadRequest, Sort, Where } from '../../../types/index.js'\nimport type { WorkflowJSON } from '../../config/types/workflowJSONTypes.js'\nimport type { WorkflowConfig, WorkflowHandler } from '../../config/types/workflowTypes.js'\nimport type { RunJobsSilent } from '../../localAPI.js'\nimport type { RunJobResult } from './runJob/index.js'\n\nimport { Forbidden } from '../../../errors/Forbidden.js'\nimport { isolateObjectProperty } from '../../../utilities/isolateObjectProperty.js'\nimport { jobsCollectionSlug } from '../../config/collection.js'\nimport { JobCancelledError } from '../../errors/index.js'\nimport { getCurrentDate } from '../../utilities/getCurrentDate.js'\nimport { updateJob, updateJobs } from '../../utilities/updateJob.js'\nimport { getUpdateJobFunction } from './runJob/getUpdateJobFunction.js'\nimport { importHandlerPath } from './runJob/importHandlerPath.js'\nimport { runJob } from './runJob/index.js'\nimport { runJSONJob } from './runJSONJob/index.js'\n\nexport type RunJobsArgs = {\n  /**\n   * If you want to run jobs from all queues, set this to true.\n   * If you set this to true, the `queue` property will be ignored.\n   *\n   * @default false\n   */\n  allQueues?: boolean\n  /**\n   * ID of the job to run\n   */\n  id?: number | string\n  /**\n   * The maximum number of jobs to run in this invocation\n   *\n   * @default 10\n   */\n  limit?: number\n  overrideAccess?: boolean\n  /**\n   * Adjust the job processing order\n   *\n   * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n   *\n   * @default all jobs for all queues will be executed in FIFO order.\n   */\n  processingOrder?: Sort\n  /**\n   * If you want to run jobs from a specific queue, set this to the queue name.\n   *\n   * @default jobs from the `default` queue will be executed.\n   */\n  queue?: string\n  req: PayloadRequest\n  /**\n   * By default, jobs are run in parallel.\n   * If you want to run them in sequence, set this to true.\n   */\n  sequential?: boolean\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  where?: Where\n}\n\nexport type RunJobsResult = {\n  jobStatus?: Record<string, RunJobResult>\n  /**\n   * If this is false, there for sure are no jobs remaining, regardless of the limit\n   */\n  noJobsRemaining?: boolean\n  /**\n   * Out of the jobs that were queried & processed (within the set limit), how many are remaining and retryable?\n   */\n  remainingJobsFromQueried: number\n}\n\nexport const runJobs = async (args: RunJobsArgs): Promise<RunJobsResult> => {\n  const {\n    id,\n    allQueues = false,\n    limit = 10,\n    overrideAccess,\n    processingOrder,\n    queue = 'default',\n    req,\n    req: {\n      payload,\n      payload: {\n        config: { jobs: jobsConfig },\n      },\n    },\n    sequential,\n    silent = false,\n    where: whereFromProps,\n  } = args\n\n  if (!overrideAccess) {\n    const accessFn = jobsConfig?.access?.run ?? (() => true)\n    const hasAccess = await accessFn({ req })\n    if (!hasAccess) {\n      throw new Forbidden(req.t)\n    }\n  }\n  const and: Where[] = [\n    {\n      completedAt: {\n        exists: false,\n      },\n    },\n    {\n      hasError: {\n        not_equals: true,\n      },\n    },\n    {\n      processing: {\n        equals: false,\n      },\n    },\n    {\n      or: [\n        {\n          waitUntil: {\n            exists: false,\n          },\n        },\n        {\n          waitUntil: {\n            less_than: getCurrentDate().toISOString(),\n          },\n        },\n      ],\n    },\n  ]\n\n  if (allQueues !== true) {\n    and.push({\n      queue: {\n        equals: queue ?? 'default',\n      },\n    })\n  }\n\n  if (whereFromProps) {\n    and.push(whereFromProps)\n  }\n\n  // Find all jobs and ensure we set job to processing: true as early as possible to reduce the chance of\n  // the same job being picked up by another worker\n  let jobs: Job[] = []\n\n  if (id) {\n    // Only one job to run\n    const job = await updateJob({\n      id,\n      data: {\n        processing: true,\n      },\n      depth: jobsConfig.depth,\n      disableTransaction: true,\n      req,\n      returning: true,\n    })\n    if (job) {\n      jobs = [job]\n    }\n  } else {\n    let defaultProcessingOrder: Sort =\n      payload.collections[jobsCollectionSlug]?.config.defaultSort ?? 'createdAt'\n\n    const processingOrderConfig = jobsConfig.processingOrder\n    if (typeof processingOrderConfig === 'function') {\n      defaultProcessingOrder = await processingOrderConfig(args)\n    } else if (typeof processingOrderConfig === 'object' && !Array.isArray(processingOrderConfig)) {\n      if (\n        !allQueues &&\n        queue &&\n        processingOrderConfig.queues &&\n        processingOrderConfig.queues[queue]\n      ) {\n        defaultProcessingOrder = processingOrderConfig.queues[queue]\n      } else if (processingOrderConfig.default) {\n        defaultProcessingOrder = processingOrderConfig.default\n      }\n    } else if (typeof processingOrderConfig === 'string') {\n      defaultProcessingOrder = processingOrderConfig\n    }\n    const updatedDocs = await updateJobs({\n      data: {\n        processing: true,\n      },\n      depth: jobsConfig.depth,\n      disableTransaction: true,\n      limit,\n      req,\n      returning: true,\n      sort: processingOrder ?? defaultProcessingOrder,\n      where: { and },\n    })\n\n    if (updatedDocs) {\n      jobs = updatedDocs\n    }\n  }\n\n  /**\n   * Just for logging purposes, we want to know how many jobs are new and how many are existing (= already been tried).\n   * This is only for logs - in the end we still want to run all jobs, regardless of whether they are new or existing.\n   */\n  const { existingJobs, newJobs } = jobs.reduce(\n    (acc, job) => {\n      if (job.totalTried > 0) {\n        acc.existingJobs.push(job)\n      } else {\n        acc.newJobs.push(job)\n      }\n      return acc\n    },\n    { existingJobs: [] as Job[], newJobs: [] as Job[] },\n  )\n\n  if (!jobs.length) {\n    return {\n      noJobsRemaining: true,\n      remainingJobsFromQueried: 0,\n    }\n  }\n\n  if (!silent || (typeof silent === 'object' && !silent.info)) {\n    payload.logger.info({\n      msg: `Running ${jobs.length} jobs.`,\n      new: newJobs?.length,\n      retrying: existingJobs?.length,\n    })\n  }\n\n  const successfullyCompletedJobs: (number | string)[] = []\n\n  const runSingleJob = async (\n    job: Job,\n  ): Promise<{\n    id: number | string\n    result: RunJobResult\n  }> => {\n    if (!job.workflowSlug && !job.taskSlug) {\n      throw new Error('Job must have either a workflowSlug or a taskSlug')\n    }\n    const jobReq = isolateObjectProperty(req, 'transactionID')\n\n    const workflowConfig: WorkflowConfig =\n      job.workflowSlug && jobsConfig.workflows?.length\n        ? jobsConfig.workflows.find(({ slug }) => slug === job.workflowSlug)!\n        : {\n            slug: 'singleTask',\n            handler: async ({ job, tasks }) => {\n              await tasks[job.taskSlug as string]!('1', {\n                input: job.input,\n              })\n            },\n          }\n\n    if (!workflowConfig) {\n      return {\n        id: job.id,\n        result: {\n          status: 'error',\n        },\n      } // Skip jobs with no workflow configuration\n    }\n\n    try {\n      const updateJob = getUpdateJobFunction(job, jobReq)\n\n      // the runner will either be passed to the config\n      // OR it will be a path, which we will need to import via eval to avoid\n      // Next.js compiler dynamic import expression errors\n      let workflowHandler: WorkflowHandler | WorkflowJSON\n      if (\n        typeof workflowConfig.handler === 'function' ||\n        (typeof workflowConfig.handler === 'object' && Array.isArray(workflowConfig.handler))\n      ) {\n        workflowHandler = workflowConfig.handler\n      } else {\n        workflowHandler = await importHandlerPath<typeof workflowHandler>(workflowConfig.handler)\n\n        if (!workflowHandler) {\n          const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n          const errorMessage = `Can't find runner while importing with the path ${workflowConfig.handler} in job type ${jobLabel}.`\n          if (!silent || (typeof silent === 'object' && !silent.error)) {\n            payload.logger.error(errorMessage)\n          }\n\n          await updateJob({\n            error: {\n              error: errorMessage,\n            },\n            hasError: true,\n            processing: false,\n          })\n\n          return {\n            id: job.id,\n            result: {\n              status: 'error-reached-max-retries',\n            },\n          }\n        }\n      }\n\n      if (typeof workflowHandler === 'function') {\n        const result = await runJob({\n          job,\n          req: jobReq,\n          silent,\n          updateJob,\n          workflowConfig,\n          workflowHandler,\n        })\n\n        if (result.status === 'success') {\n          successfullyCompletedJobs.push(job.id)\n        }\n\n        return { id: job.id, result }\n      } else {\n        const result = await runJSONJob({\n          job,\n          req: jobReq,\n          silent,\n          updateJob,\n          workflowConfig,\n          workflowHandler,\n        })\n\n        if (result.status === 'success') {\n          successfullyCompletedJobs.push(job.id)\n        }\n\n        return { id: job.id, result }\n      }\n    } catch (error) {\n      if (error instanceof JobCancelledError) {\n        return {\n          id: job.id,\n          result: {\n            status: 'error-reached-max-retries',\n          },\n        }\n      }\n      throw error\n    }\n  }\n\n  let resultsArray: { id: number | string; result: RunJobResult }[] = []\n  if (sequential) {\n    for (const job of jobs) {\n      const result = await runSingleJob(job)\n      if (result) {\n        resultsArray.push(result)\n      }\n    }\n  } else {\n    const jobPromises = jobs.map(runSingleJob)\n    resultsArray = (await Promise.all(jobPromises)) as {\n      id: number | string\n      result: RunJobResult\n    }[]\n  }\n\n  if (jobsConfig.deleteJobOnComplete && successfullyCompletedJobs.length) {\n    try {\n      if (jobsConfig.runHooks) {\n        await payload.delete({\n          collection: jobsCollectionSlug,\n          depth: 0, // can be 0 since we're not returning anything\n          disableTransaction: true,\n          where: { id: { in: successfullyCompletedJobs } },\n        })\n      } else {\n        await payload.db.deleteMany({\n          collection: jobsCollectionSlug,\n          where: { id: { in: successfullyCompletedJobs } },\n        })\n      }\n    } catch (err) {\n      if (!silent || (typeof silent === 'object' && !silent.error)) {\n        payload.logger.error({\n          err,\n          msg: `Failed to delete jobs ${successfullyCompletedJobs.join(', ')} on complete`,\n        })\n      }\n    }\n  }\n\n  const resultsObject: RunJobsResult['jobStatus'] = resultsArray.reduce(\n    (acc, cur) => {\n      if (cur !== null) {\n        // Check if there's a valid result to include\n        acc[cur.id] = cur.result\n      }\n      return acc\n    },\n    {} as Record<string, RunJobResult>,\n  )\n\n  let remainingJobsFromQueried = 0\n  for (const jobID in resultsObject) {\n    const jobResult = resultsObject[jobID]\n    if (jobResult?.status === 'error') {\n      remainingJobsFromQueried++ // Can be retried\n    }\n  }\n\n  return {\n    jobStatus: resultsObject,\n    remainingJobsFromQueried,\n  }\n}\n"],"names":["Forbidden","isolateObjectProperty","jobsCollectionSlug","JobCancelledError","getCurrentDate","updateJob","updateJobs","getUpdateJobFunction","importHandlerPath","runJob","runJSONJob","runJobs","args","id","allQueues","limit","overrideAccess","processingOrder","queue","req","payload","config","jobs","jobsConfig","sequential","silent","where","whereFromProps","accessFn","access","run","hasAccess","t","and","completedAt","exists","hasError","not_equals","processing","equals","or","waitUntil","less_than","toISOString","push","job","data","depth","disableTransaction","returning","defaultProcessingOrder","collections","defaultSort","processingOrderConfig","Array","isArray","queues","default","updatedDocs","sort","existingJobs","newJobs","reduce","acc","totalTried","length","noJobsRemaining","remainingJobsFromQueried","info","logger","msg","new","retrying","successfullyCompletedJobs","runSingleJob","workflowSlug","taskSlug","Error","jobReq","workflowConfig","workflows","find","slug","handler","tasks","input","result","status","workflowHandler","jobLabel","errorMessage","error","resultsArray","jobPromises","map","Promise","all","deleteJobOnComplete","runHooks","delete","collection","in","db","deleteMany","err","join","resultsObject","cur","jobID","jobResult","jobStatus"],"mappings":"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"}