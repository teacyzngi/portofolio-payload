{"version":3,"sources":["../../../../../src/queues/operations/runJobs/runJob/importHandlerPath.ts"],"sourcesContent":["import { pathToFileURL } from 'url'\n\nimport type { TaskConfig, TaskHandler, TaskType } from '../../../config/types/taskTypes.js'\n\n/**\n * Imports a handler function from a given path.\n */\nexport async function importHandlerPath<T>(path: string): Promise<T> {\n  let runner!: T\n  const [runnerPath, runnerImportName] = path.split('#')\n\n  let runnerModule\n  try {\n    // We need to check for `require` for compatibility with outdated frameworks that do not\n    // properly support ESM, like Jest. This is not done to support projects without \"type\": \"module\" set\n    runnerModule =\n      typeof require === 'function'\n        ? await eval(`require('${runnerPath!.replaceAll('\\\\', '/')}')`)\n        : await eval(`import('${pathToFileURL(runnerPath!).href}')`)\n  } catch (e) {\n    throw new Error(\n      `Error importing job queue handler module for path ${path}. This is an advanced feature that may require a sophisticated build pipeline, especially when using it in production or within Next.js, e.g. by calling opening the /api/payload-jobs/run endpoint. You will have to transpile the handler files separately and ensure they are available in the same location when the job is run. If you're using an endpoint to execute your jobs, it's recommended to define your handlers as functions directly in your Payload Config, or use import paths handlers outside of Next.js. Import Error: \\n${e instanceof Error ? e.message : 'Unknown error'}`,\n    )\n  }\n\n  // If the path has indicated an #exportName, try to get it\n  if (runnerImportName && runnerModule[runnerImportName]) {\n    runner = runnerModule[runnerImportName]\n  }\n\n  // If there is a default export, use it\n  if (!runner && runnerModule.default) {\n    runner = runnerModule.default\n  }\n\n  // Finally, use whatever was imported\n  if (!runner) {\n    runner = runnerModule\n  }\n\n  return runner\n}\n\n/**\n * The `handler` property of a task config can either be a function or a path to a module that exports a function.\n * This function resolves the handler to a function, either by importing it from the path or returning the function directly\n * if it is already a function.\n */\nexport async function getTaskHandlerFromConfig(taskConfig?: TaskConfig) {\n  if (!taskConfig) {\n    throw new Error('Task config is required to get the task handler')\n  }\n  if (typeof taskConfig.handler === 'function') {\n    return taskConfig.handler\n  } else {\n    return await importHandlerPath<TaskHandler<TaskType>>(taskConfig.handler)\n  }\n}\n"],"names":["pathToFileURL","importHandlerPath","path","runner","runnerPath","runnerImportName","split","runnerModule","require","eval","replaceAll","href","e","Error","message","default","getTaskHandlerFromConfig","taskConfig","handler"],"mappings":"AAAA,SAASA,aAAa,QAAQ,MAAK;AAInC;;CAEC,GACD,OAAO,eAAeC,kBAAqBC,IAAY;IACrD,IAAIC;IACJ,MAAM,CAACC,YAAYC,iBAAiB,GAAGH,KAAKI,KAAK,CAAC;IAElD,IAAIC;IACJ,IAAI;QACF,wFAAwF;QACxF,qGAAqG;QACrGA,eACE,OAAOC,YAAY,aACf,MAAMC,KAAK,CAAC,SAAS,EAAEL,WAAYM,UAAU,CAAC,MAAM,KAAK,EAAE,CAAC,IAC5D,MAAMD,KAAK,CAAC,QAAQ,EAAET,cAAcI,YAAaO,IAAI,CAAC,EAAE,CAAC;IACjE,EAAE,OAAOC,GAAG;QACV,MAAM,IAAIC,MACR,CAAC,kDAAkD,EAAEX,KAAK,+gBAA+gB,EAAEU,aAAaC,QAAQD,EAAEE,OAAO,GAAG,iBAAiB;IAEjoB;IAEA,0DAA0D;IAC1D,IAAIT,oBAAoBE,YAAY,CAACF,iBAAiB,EAAE;QACtDF,SAASI,YAAY,CAACF,iBAAiB;IACzC;IAEA,uCAAuC;IACvC,IAAI,CAACF,UAAUI,aAAaQ,OAAO,EAAE;QACnCZ,SAASI,aAAaQ,OAAO;IAC/B;IAEA,qCAAqC;IACrC,IAAI,CAACZ,QAAQ;QACXA,SAASI;IACX;IAEA,OAAOJ;AACT;AAEA;;;;CAIC,GACD,OAAO,eAAea,yBAAyBC,UAAuB;IACpE,IAAI,CAACA,YAAY;QACf,MAAM,IAAIJ,MAAM;IAClB;IACA,IAAI,OAAOI,WAAWC,OAAO,KAAK,YAAY;QAC5C,OAAOD,WAAWC,OAAO;IAC3B,OAAO;QACL,OAAO,MAAMjB,kBAAyCgB,WAAWC,OAAO;IAC1E;AACF"}