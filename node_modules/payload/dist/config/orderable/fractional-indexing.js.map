{"version":3,"sources":["../../../src/config/orderable/fractional-indexing.js"],"sourcesContent":["// @ts-no-check\n\n/**\n * THIS FILE IS COPIED FROM:\n * https://github.com/rocicorp/fractional-indexing/blob/main/src/index.js\n *\n * I AM NOT INSTALLING THAT LIBRARY BECAUSE JEST COMPLAINS ABOUT THE ESM MODULE AND THE TESTS FAIL.\n * DO NOT MODIFY IT\n * ALSO, I'M DISABLING TS WITH `@ts-no-check` BECAUSE THEY DON'T USE STRICT NULL CHECKS IN THAT REPOSITORY\n */\n\n// License: CC0 (no rights reserved).\n\n// This is based on https://observablehq.com/@dgreensp/implementing-fractional-indexing\n\nexport const BASE_36_DIGITS = '0123456789abcdefghijklmnopqrstuvwxyz'\n\n// `a` may be empty string, `b` is null or non-empty string.\n// `a < b` lexicographically if `b` is non-null.\n// no trailing zeros allowed.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string} a\n * @param {string | null | undefined} b\n * @param {string} digits\n * @returns {string}\n */\nfunction midpoint(a, b, digits) {\n  const zero = digits[0]\n  if (b != null && a >= b) {\n    throw new Error(a + ' >= ' + b)\n  }\n  if (a.slice(-1) === zero || (b && b.slice(-1) === zero)) {\n    throw new Error('trailing zero')\n  }\n  if (b) {\n    // remove longest common prefix.  pad `a` with 0s as we\n    // go.  note that we don't need to pad `b`, because it can't\n    // end before `a` while traversing the common prefix.\n    let n = 0\n    while ((a[n] || zero) === b[n]) {\n      n++\n    }\n    if (n > 0) {\n      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits)\n    }\n  }\n  // first digits (or lack of digit) are different\n  const digitA = a ? digits.indexOf(a[0]) : 0\n  const digitB = b != null ? digits.indexOf(b[0]) : digits.length\n  if (digitB - digitA > 1) {\n    const midDigit = Math.round(0.5 * (digitA + digitB))\n    return digits[midDigit]\n  } else {\n    // first digits are consecutive\n    if (b && b.length > 1) {\n      return b.slice(0, 1)\n    } else {\n      // `b` is null or has length 1 (a single digit).\n      // the first digit of `a` is the previous digit to `b`,\n      // or 9 if `b` is null.\n      // given, for example, midpoint('49', '5'), return\n      // '4' + midpoint('9', null), which will become\n      // '4' + '9' + midpoint('', null), which is '495'\n      return digits[digitA] + midpoint(a.slice(1), null, digits)\n    }\n  }\n}\n\n/**\n * @param {string} int\n * @return {void}\n */\n\nfunction validateInteger(int) {\n  if (int.length !== getIntegerLength(int[0])) {\n    throw new Error('invalid integer part of order key: ' + int)\n  }\n}\n\n/**\n * @param {string} head\n * @return {number}\n */\n\nfunction getIntegerLength(head) {\n  if (head >= 'a' && head <= 'z') {\n    return head.charCodeAt(0) - 'a'.charCodeAt(0) + 2\n  } else if (head >= 'A' && head <= 'Z') {\n    return 'Z'.charCodeAt(0) - head.charCodeAt(0) + 2\n  } else {\n    throw new Error('invalid order key head: ' + head)\n  }\n}\n\n/**\n * @param {string} key\n * @return {string}\n */\n\nfunction getIntegerPart(key) {\n  const integerPartLength = getIntegerLength(key[0])\n  if (integerPartLength > key.length) {\n    throw new Error('invalid order key: ' + key)\n  }\n  return key.slice(0, integerPartLength)\n}\n\n/**\n * @param {string} key\n * @param {string} digits\n * @return {void}\n */\n\nfunction validateOrderKey(key, digits) {\n  if (key === 'A' + digits[0].repeat(26)) {\n    throw new Error('invalid order key: ' + key)\n  }\n  // getIntegerPart will throw if the first character is bad,\n  // or the key is too short.  we'd call it to check these things\n  // even if we didn't need the result\n  const i = getIntegerPart(key)\n  const f = key.slice(i.length)\n  if (f.slice(-1) === digits[0]) {\n    throw new Error('invalid order key: ' + key)\n  }\n}\n\n// note that this may return null, as there is a largest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\nfunction incrementInteger(x, digits) {\n  validateInteger(x)\n  const [head, ...digs] = x.split('')\n  let carry = true\n  for (let i = digs.length - 1; carry && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) + 1\n    if (d === digits.length) {\n      digs[i] = digits[0]\n    } else {\n      digs[i] = digits[d]\n      carry = false\n    }\n  }\n  if (carry) {\n    if (head === 'Z') {\n      return 'a' + digits[0]\n    }\n    if (head === 'z') {\n      return null\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) + 1)\n    if (h > 'a') {\n      digs.push(digits[0])\n    } else {\n      digs.pop()\n    }\n    return h + digs.join('')\n  } else {\n    return head + digs.join('')\n  }\n}\n\n// note that this may return null, as there is a smallest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\n\nfunction decrementInteger(x, digits) {\n  validateInteger(x)\n  const [head, ...digs] = x.split('')\n  let borrow = true\n  for (let i = digs.length - 1; borrow && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) - 1\n    if (d === -1) {\n      digs[i] = digits.slice(-1)\n    } else {\n      digs[i] = digits[d]\n      borrow = false\n    }\n  }\n  if (borrow) {\n    if (head === 'a') {\n      return 'Z' + digits.slice(-1)\n    }\n    if (head === 'A') {\n      return null\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) - 1)\n    if (h < 'Z') {\n      digs.push(digits.slice(-1))\n    } else {\n      digs.pop()\n    }\n    return h + digs.join('')\n  } else {\n    return head + digs.join('')\n  }\n}\n\n// `a` is an order key or null (START).\n// `b` is an order key or null (END).\n// `a < b` lexicographically if both are non-null.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {string=} digits\n * @return {string}\n */\nexport function generateKeyBetween(a, b, digits = BASE_36_DIGITS) {\n  if (a != null) {\n    validateOrderKey(a, digits)\n  }\n  if (b != null) {\n    validateOrderKey(b, digits)\n  }\n  if (a != null && b != null && a >= b) {\n    throw new Error(a + ' >= ' + b)\n  }\n  if (a == null) {\n    if (b == null) {\n      return 'a' + digits[0]\n    }\n\n    const ib = getIntegerPart(b)\n    const fb = b.slice(ib.length)\n    if (ib === 'A' + digits[0].repeat(26)) {\n      return ib + midpoint('', fb, digits)\n    }\n    if (ib < b) {\n      return ib\n    }\n    const res = decrementInteger(ib, digits)\n    if (res == null) {\n      throw new Error('cannot decrement any more')\n    }\n    return res\n  }\n\n  if (b == null) {\n    const ia = getIntegerPart(a)\n    const fa = a.slice(ia.length)\n    const i = incrementInteger(ia, digits)\n    return i == null ? ia + midpoint(fa, null, digits) : i\n  }\n\n  const ia = getIntegerPart(a)\n  const fa = a.slice(ia.length)\n  const ib = getIntegerPart(b)\n  const fb = b.slice(ib.length)\n  if (ia === ib) {\n    return ia + midpoint(fa, fb, digits)\n  }\n  const i = incrementInteger(ia, digits)\n  if (i == null) {\n    throw new Error('cannot increment any more')\n  }\n  if (i < b) {\n    return i\n  }\n  return ia + midpoint(fa, null, digits)\n}\n\n/**\n * same preconditions as generateKeysBetween.\n * n >= 0.\n * Returns an array of n distinct keys in sorted order.\n * If a and b are both null, returns [a0, a1, ...]\n * If one or the other is null, returns consecutive \"integer\"\n * keys.  Otherwise, returns relatively short keys between\n * a and b.\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {number} n\n * @param {string} digits\n * @return {string[]}\n */\nexport function generateNKeysBetween(a, b, n, digits = BASE_36_DIGITS) {\n  if (n === 0) {\n    return []\n  }\n  if (n === 1) {\n    return [generateKeyBetween(a, b, digits)]\n  }\n  if (b == null) {\n    let c = generateKeyBetween(a, b, digits)\n    const result = [c]\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(c, b, digits)\n      result.push(c)\n    }\n    return result\n  }\n  if (a == null) {\n    let c = generateKeyBetween(a, b, digits)\n    const result = [c]\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(a, c, digits)\n      result.push(c)\n    }\n    result.reverse()\n    return result\n  }\n  const mid = Math.floor(n / 2)\n  const c = generateKeyBetween(a, b, digits)\n  return [\n    ...generateNKeysBetween(a, c, mid, digits),\n    c,\n    ...generateNKeysBetween(c, b, n - mid - 1, digits),\n  ]\n}\n"],"names":["BASE_36_DIGITS","midpoint","a","b","digits","zero","Error","slice","n","digitA","indexOf","digitB","length","midDigit","Math","round","validateInteger","int","getIntegerLength","head","charCodeAt","getIntegerPart","key","integerPartLength","validateOrderKey","repeat","i","f","incrementInteger","x","digs","split","carry","d","h","String","fromCharCode","push","pop","join","decrementInteger","borrow","generateKeyBetween","ib","fb","res","ia","fa","generateNKeysBetween","c","result","reverse","mid","floor"],"mappings":"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"}