{"version":3,"sources":["../../../src/config/orderable/index.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { BeforeChangeHook, CollectionConfig } from '../../collections/config/types.js'\nimport type { Field } from '../../fields/config/types.js'\nimport type { Endpoint, PayloadHandler, SanitizedConfig } from '../types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { APIError } from '../../errors/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { traverseFields } from '../../utilities/traverseFields.js'\nimport { generateKeyBetween, generateNKeysBetween } from './fractional-indexing.js'\n\n/**\n * This function creates:\n * - N fields per collection, named `_order` or `_<collection>_<joinField>_order`\n * - 1 hook per collection\n * - 1 endpoint per app\n *\n * Also, if collection.defaultSort or joinField.defaultSort is not set, it will be set to the orderable field.\n */\nexport const setupOrderable = (config: SanitizedConfig) => {\n  const fieldsToAdd = new Map<CollectionConfig, string[]>()\n\n  config.collections.forEach((collection) => {\n    if (collection.orderable) {\n      const currentFields = fieldsToAdd.get(collection) || []\n      fieldsToAdd.set(collection, [...currentFields, '_order'])\n      collection.defaultSort = collection.defaultSort ?? '_order'\n    }\n\n    traverseFields({\n      callback: ({ field, parentRef, ref }) => {\n        if (field.type === 'array' || field.type === 'blocks') {\n          return false\n        }\n        if (field.type === 'group' || field.type === 'tab') {\n          // @ts-expect-error ref is untyped\n          const parentPrefix = parentRef?.prefix ? `${parentRef.prefix}_` : ''\n          // @ts-expect-error ref is untyped\n          ref.prefix = `${parentPrefix}${field.name}`\n        }\n        if (field.type === 'join' && field.orderable === true) {\n          if (Array.isArray(field.collection)) {\n            throw new APIError(\n              'Orderable joins must target a single collection',\n              httpStatus.BAD_REQUEST,\n              {},\n              true,\n            )\n          }\n          const relationshipCollection = config.collections.find((c) => c.slug === field.collection)\n          if (!relationshipCollection) {\n            return false\n          }\n          field.defaultSort = field.defaultSort ?? `_${field.collection}_${field.name}_order`\n          const currentFields = fieldsToAdd.get(relationshipCollection) || []\n          // @ts-expect-error ref is untyped\n          const prefix = parentRef?.prefix ? `${parentRef.prefix}_` : ''\n          fieldsToAdd.set(relationshipCollection, [\n            ...currentFields,\n            `_${field.collection}_${prefix}${field.name}_order`,\n          ])\n        }\n      },\n      fields: collection.fields,\n    })\n  })\n\n  Array.from(fieldsToAdd.entries()).forEach(([collection, orderableFields]) => {\n    addOrderableFieldsAndHook(collection, orderableFields)\n  })\n\n  if (fieldsToAdd.size > 0) {\n    addOrderableEndpoint(config)\n  }\n}\n\nexport const addOrderableFieldsAndHook = (\n  collection: CollectionConfig,\n  orderableFieldNames: string[],\n) => {\n  // 1. Add field\n  orderableFieldNames.forEach((orderableFieldName) => {\n    const orderField: Field = {\n      name: orderableFieldName,\n      type: 'text',\n      admin: {\n        disableBulkEdit: true,\n        disabled: true,\n        disableGroupBy: true,\n        disableListColumn: true,\n        disableListFilter: true,\n        hidden: true,\n        readOnly: true,\n      },\n      hooks: {\n        beforeDuplicate: [\n          ({ siblingData }) => {\n            delete siblingData[orderableFieldName]\n          },\n        ],\n      },\n      index: true,\n    }\n\n    collection.fields.unshift(orderField)\n  })\n\n  // 2. Add hook\n  if (!collection.hooks) {\n    collection.hooks = {}\n  }\n  if (!collection.hooks.beforeChange) {\n    collection.hooks.beforeChange = []\n  }\n\n  const orderBeforeChangeHook: BeforeChangeHook = async ({ data, originalDoc, req }) => {\n    for (const orderableFieldName of orderableFieldNames) {\n      if (!data[orderableFieldName] && !originalDoc?.[orderableFieldName]) {\n        const lastDoc = await req.payload.find({\n          collection: collection.slug,\n          depth: 0,\n          limit: 1,\n          pagination: false,\n          req,\n          select: { [orderableFieldName]: true },\n          sort: `-${orderableFieldName}`,\n          where: {\n            [orderableFieldName]: {\n              exists: true,\n            },\n          },\n        })\n\n        const lastOrderValue = lastDoc.docs[0]?.[orderableFieldName] || null\n        data[orderableFieldName] = generateKeyBetween(lastOrderValue, null)\n      }\n    }\n\n    return data\n  }\n\n  collection.hooks.beforeChange.push(orderBeforeChangeHook)\n}\n\n/**\n * The body of the reorder endpoint.\n * @internal\n */\nexport type OrderableEndpointBody = {\n  collectionSlug: string\n  docsToMove: string[]\n  newKeyWillBe: 'greater' | 'less'\n  orderableFieldName: string\n  target: {\n    id: string\n    key: string\n  }\n}\n\nexport const addOrderableEndpoint = (config: SanitizedConfig) => {\n  // 3. Add endpoint\n  const reorderHandler: PayloadHandler = async (req) => {\n    const body = (await req.json?.()) as OrderableEndpointBody\n\n    const { collectionSlug, docsToMove, newKeyWillBe, orderableFieldName, target } = body\n\n    if (!Array.isArray(docsToMove) || docsToMove.length === 0) {\n      return new Response(JSON.stringify({ error: 'docsToMove must be a non-empty array' }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 400,\n      })\n    }\n    if (newKeyWillBe !== 'greater' && newKeyWillBe !== 'less') {\n      return new Response(JSON.stringify({ error: 'newKeyWillBe must be \"greater\" or \"less\"' }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 400,\n      })\n    }\n    const collection = config.collections.find((c) => c.slug === collectionSlug)\n    if (!collection) {\n      return new Response(JSON.stringify({ error: `Collection ${collectionSlug} not found` }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 400,\n      })\n    }\n    if (typeof orderableFieldName !== 'string') {\n      return new Response(JSON.stringify({ error: 'orderableFieldName must be a string' }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 400,\n      })\n    }\n\n    // Prevent reordering if user doesn't have editing permissions\n    if (collection.access?.update) {\n      await executeAccess(\n        {\n          // Currently only one doc can be moved at a time. We should review this if we want to allow\n          // multiple docs to be moved at once in the future.\n          id: docsToMove[0],\n          data: {},\n          req,\n        },\n        collection.access.update,\n      )\n    }\n    /**\n     * If there is no target.key, we can assume the user enabled `orderable`\n     * on a collection with existing documents, and that this is the first\n     * time they tried to reorder them. Therefore, we perform a one-time\n     * migration by setting the key value for all documents. We do this\n     * instead of enforcing `required` and `unique` at the database schema\n     * level, so that users don't have to run a migration when they enable\n     * `orderable` on a collection with existing documents.\n     */\n    if (!target.key) {\n      const { docs } = await req.payload.find({\n        collection: collection.slug,\n        depth: 0,\n        limit: 0,\n        req,\n        select: { [orderableFieldName]: true },\n        where: {\n          [orderableFieldName]: {\n            exists: false,\n          },\n        },\n      })\n      await initTransaction(req)\n      // We cannot update all documents in a single operation with `payload.update`,\n      // because they would all end up with the same order key (`a0`).\n      try {\n        for (const doc of docs) {\n          await req.payload.update({\n            id: doc.id,\n            collection: collection.slug,\n            data: {\n              // no data needed since the order hooks will handle this\n            },\n            depth: 0,\n            req,\n          })\n          await commitTransaction(req)\n        }\n      } catch (e) {\n        await killTransaction(req)\n        if (e instanceof Error) {\n          throw new APIError(e.message, httpStatus.INTERNAL_SERVER_ERROR)\n        }\n      }\n\n      return new Response(JSON.stringify({ message: 'initial migration', success: true }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 200,\n      })\n    }\n\n    if (\n      typeof target !== 'object' ||\n      typeof target.id === 'undefined' ||\n      typeof target.key !== 'string'\n    ) {\n      return new Response(JSON.stringify({ error: 'target must be an object with id' }), {\n        headers: { 'Content-Type': 'application/json' },\n        status: 400,\n      })\n    }\n\n    const targetId = target.id\n    let targetKey = target.key\n\n    // If targetKey = pending, we need to find its current key.\n    // This can only happen if the user reorders rows quickly with a slow connection.\n    if (targetKey === 'pending') {\n      const beforeDoc = await req.payload.findByID({\n        id: targetId,\n        collection: collection.slug,\n        depth: 0,\n        select: { [orderableFieldName]: true },\n      })\n      targetKey = beforeDoc?.[orderableFieldName] || null\n    }\n\n    // The reason the endpoint does not receive this docId as an argument is that there\n    // are situations where the user may not see or know what the next or previous one is. For\n    // example, access control restrictions, if docBefore is the last one on the page, etc.\n    const adjacentDoc = await req.payload.find({\n      collection: collection.slug,\n      depth: 0,\n      limit: 1,\n      pagination: false,\n      select: { [orderableFieldName]: true },\n      sort: newKeyWillBe === 'greater' ? orderableFieldName : `-${orderableFieldName}`,\n      where: {\n        [orderableFieldName]: {\n          [newKeyWillBe === 'greater' ? 'greater_than' : 'less_than']: targetKey,\n        },\n      },\n    })\n    const adjacentDocKey = adjacentDoc.docs?.[0]?.[orderableFieldName] || null\n\n    // Currently N (= docsToMove.length) is always 1. Maybe in the future we will\n    // allow dragging and reordering multiple documents at once via the UI.\n    const orderValues =\n      newKeyWillBe === 'greater'\n        ? generateNKeysBetween(targetKey, adjacentDocKey, docsToMove.length)\n        : generateNKeysBetween(adjacentDocKey, targetKey, docsToMove.length)\n\n    // Update each document with its new order value\n    for (const [index, id] of docsToMove.entries()) {\n      await req.payload.update({\n        id,\n        collection: collection.slug,\n        data: {\n          [orderableFieldName]: orderValues[index],\n        },\n        depth: 0,\n        req,\n      })\n    }\n\n    return new Response(JSON.stringify({ orderValues, success: true }), {\n      headers: { 'Content-Type': 'application/json' },\n      status: 200,\n    })\n  }\n\n  const reorderEndpoint: Endpoint = {\n    handler: reorderHandler,\n    method: 'post',\n    path: '/reorder',\n  }\n\n  if (!config.endpoints) {\n    config.endpoints = []\n  }\n\n  config.endpoints.push(reorderEndpoint)\n}\n"],"names":["status","httpStatus","executeAccess","APIError","commitTransaction","initTransaction","killTransaction","traverseFields","generateKeyBetween","generateNKeysBetween","setupOrderable","config","fieldsToAdd","Map","collections","forEach","collection","orderable","currentFields","get","set","defaultSort","callback","field","parentRef","ref","type","parentPrefix","prefix","name","Array","isArray","BAD_REQUEST","relationshipCollection","find","c","slug","fields","from","entries","orderableFields","addOrderableFieldsAndHook","size","addOrderableEndpoint","orderableFieldNames","orderableFieldName","orderField","admin","disableBulkEdit","disabled","disableGroupBy","disableListColumn","disableListFilter","hidden","readOnly","hooks","beforeDuplicate","siblingData","index","unshift","beforeChange","orderBeforeChangeHook","data","originalDoc","req","lastDoc","payload","depth","limit","pagination","select","sort","where","exists","lastOrderValue","docs","push","reorderHandler","body","json","collectionSlug","docsToMove","newKeyWillBe","target","length","Response","JSON","stringify","error","headers","access","update","id","key","doc","e","Error","message","INTERNAL_SERVER_ERROR","success","targetId","targetKey","beforeDoc","findByID","adjacentDoc","adjacentDocKey","orderValues","reorderEndpoint","handler","method","path","endpoints"],"mappings":"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"}