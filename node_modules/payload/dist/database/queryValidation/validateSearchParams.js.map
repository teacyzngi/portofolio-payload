{"version":3,"sources":["../../../src/database/queryValidation/validateSearchParams.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { FlattenedField } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { PayloadRequest, WhereField } from '../../types/index.js'\nimport type { EntityPolicies, PathToQuery } from './types.js'\n\nimport { fieldAffectsData } from '../../fields/config/types.js'\nimport { getEntityPolicies } from '../../utilities/getEntityPolicies.js'\nimport { isolateObjectProperty } from '../../utilities/isolateObjectProperty.js'\nimport { getLocalizedPaths } from '../getLocalizedPaths.js'\nimport { validateQueryPaths } from './validateQueryPaths.js'\n\ntype Args = {\n  collectionConfig?: SanitizedCollectionConfig\n  constraint: WhereField\n  errors: { path: string }[]\n  fields: FlattenedField[]\n  globalConfig?: SanitizedGlobalConfig\n  operator: string\n  overrideAccess: boolean\n  parentIsLocalized?: boolean\n  path: string\n  policies: EntityPolicies\n  polymorphicJoin?: boolean\n  req: PayloadRequest\n  val: unknown\n  versionFields?: FlattenedField[]\n}\n\n/**\n * Validate the Payload key / value / operator\n */\nexport async function validateSearchParam({\n  collectionConfig,\n  constraint,\n  errors,\n  fields,\n  globalConfig,\n  operator,\n  overrideAccess,\n  parentIsLocalized,\n  path: incomingPath,\n  policies,\n  polymorphicJoin,\n  req,\n  val,\n  versionFields,\n}: Args): Promise<void> {\n  // Replace GraphQL nested field double underscore formatting\n  let sanitizedPath\n  if (incomingPath === '_id') {\n    sanitizedPath = 'id'\n  } else {\n    sanitizedPath = incomingPath.replace(/__/g, '.')\n  }\n  let paths: PathToQuery[] = []\n  const { slug } = (collectionConfig || globalConfig)!\n\n  const blockPolicies = {}\n\n  if (globalConfig && !policies.globals![slug]) {\n    policies.globals![slug] = await getEntityPolicies({\n      type: 'global',\n      blockPolicies,\n      entity: globalConfig,\n      operations: ['read'],\n      req,\n    })\n  }\n\n  if (sanitizedPath !== 'id') {\n    paths = getLocalizedPaths({\n      collectionSlug: collectionConfig?.slug,\n      fields,\n      globalSlug: globalConfig?.slug,\n      incomingPath: sanitizedPath,\n      locale: req.locale!,\n      overrideAccess,\n      parentIsLocalized,\n      payload: req.payload,\n    })\n  }\n  const promises: Promise<void>[] = []\n\n  // Sanitize relation.otherRelation.id to relation.otherRelation\n  if (paths.at(-1)?.path === 'id') {\n    const previousField = paths.at(-2)?.field\n    if (\n      previousField &&\n      (previousField.type === 'relationship' || previousField.type === 'upload') &&\n      typeof previousField.relationTo === 'string'\n    ) {\n      paths.pop()\n    }\n  }\n\n  promises.push(\n    ...paths.map(async ({ collectionSlug, field, invalid, path }, i) => {\n      if (invalid) {\n        if (!polymorphicJoin) {\n          errors.push({ path })\n        }\n\n        return\n      }\n\n      // where: { relatedPosts: { equals: 1}} -> { 'relatedPosts.id': { equals: 1}}\n      if (field.type === 'join' && path === incomingPath) {\n        constraint[`${path}.id` as keyof WhereField] = constraint[path as keyof WhereField]\n        delete constraint[path as keyof WhereField]\n      }\n\n      if ('virtual' in field && field.virtual) {\n        if (field.virtual === true) {\n          errors.push({ path })\n        }\n      }\n\n      if (polymorphicJoin && path === 'relationTo') {\n        return\n      }\n\n      if (!overrideAccess && fieldAffectsData(field)) {\n        if (collectionSlug) {\n          if (!policies.collections![collectionSlug]) {\n            policies.collections![collectionSlug] = await getEntityPolicies({\n              type: 'collection',\n              blockPolicies,\n              entity: req.payload.collections[collectionSlug]!.config,\n              operations: ['read'],\n              req: isolateObjectProperty(req, 'transactionID'),\n            })\n          }\n\n          if (\n            ['hash', 'salt'].includes(incomingPath) &&\n            collectionConfig!.auth &&\n            !collectionConfig!.auth?.disableLocalStrategy\n          ) {\n            errors.push({ path: incomingPath })\n          }\n        }\n        let fieldPath = path\n        // remove locale from end of path\n        if (path.endsWith(`.${req.locale}`)) {\n          fieldPath = path.slice(0, -(req.locale!.length + 1))\n        }\n        // remove \".value\" from ends of polymorphic relationship paths\n        if (\n          (field.type === 'relationship' || field.type === 'upload') &&\n          Array.isArray(field.relationTo)\n        ) {\n          fieldPath = fieldPath.replace('.value', '')\n        }\n\n        const entityType: 'collections' | 'globals' = globalConfig ? 'globals' : 'collections'\n        const entitySlug = collectionSlug || globalConfig!.slug\n        const segments = fieldPath.split('.')\n\n        let fieldAccess: any\n\n        if (versionFields) {\n          fieldAccess = policies[entityType]![entitySlug]!.fields\n\n          if (\n            segments[0] === 'parent' ||\n            segments[0] === 'version' ||\n            segments[0] === 'snapshot' ||\n            segments[0] === 'latest'\n          ) {\n            segments.shift()\n          }\n        } else {\n          fieldAccess = policies[entityType]![entitySlug]!.fields\n        }\n\n        if (segments.length) {\n          segments.forEach((segment) => {\n            if (fieldAccess[segment]) {\n              if ('fields' in fieldAccess[segment]) {\n                fieldAccess = fieldAccess[segment].fields\n              } else {\n                fieldAccess = fieldAccess[segment]\n              }\n            }\n          })\n\n          if (!fieldAccess?.read?.permission) {\n            errors.push({ path: fieldPath })\n          }\n        }\n      }\n\n      if (i > 1) {\n        // Remove top collection and reverse array\n        // to work backwards from top\n        const pathsToQuery = paths.slice(1).reverse()\n\n        pathsToQuery.forEach(\n          ({ collectionSlug: pathCollectionSlug, path: subPath }, pathToQueryIndex) => {\n            // On the \"deepest\" collection,\n            // validate query of the relationship\n            if (pathToQueryIndex === 0) {\n              promises.push(\n                validateQueryPaths({\n                  collectionConfig: req.payload.collections[pathCollectionSlug!]!.config,\n                  errors,\n                  globalConfig: undefined,\n                  overrideAccess,\n                  policies,\n                  req,\n                  where: {\n                    [subPath]: {\n                      [operator]: val,\n                    },\n                  },\n                }),\n              )\n            }\n          },\n        )\n      }\n    }),\n  )\n  await Promise.all(promises)\n}\n"],"names":["fieldAffectsData","getEntityPolicies","isolateObjectProperty","getLocalizedPaths","validateQueryPaths","validateSearchParam","collectionConfig","constraint","errors","fields","globalConfig","operator","overrideAccess","parentIsLocalized","path","incomingPath","policies","polymorphicJoin","req","val","versionFields","sanitizedPath","replace","paths","slug","blockPolicies","globals","type","entity","operations","collectionSlug","globalSlug","locale","payload","promises","at","previousField","field","relationTo","pop","push","map","invalid","i","virtual","collections","config","includes","auth","disableLocalStrategy","fieldPath","endsWith","slice","length","Array","isArray","entityType","entitySlug","segments","split","fieldAccess","shift","forEach","segment","read","permission","pathsToQuery","reverse","pathCollectionSlug","subPath","pathToQueryIndex","undefined","where","Promise","all"],"mappings":"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"}