{"version":3,"sources":["../../src/uploads/generateFileData.ts"],"sourcesContent":["import type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs/promises'\nimport sanitize from 'sanitize-filename'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'\n\nimport { FileRetrievalError, FileUploadError, Forbidden, MissingFile } from '../errors/index.js'\nimport { canResizeImage } from './canResizeImage.js'\nimport { checkFileRestrictions } from './checkFileRestrictions.js'\nimport { cropImage } from './cropImage.js'\nimport { getExternalFile } from './getExternalFile.js'\nimport { getFileByPath } from './getFileByPath.js'\nimport { getImageSize } from './getImageSize.js'\nimport { getSafeFileName } from './getSafeFilename.js'\nimport { resizeAndTransformImageSizes } from './imageResizer.js'\nimport { isImage } from './isImage.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\ntype Args<T> = {\n  collection: Collection\n  config: SanitizedConfig\n  data: T\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc?: T\n  overwriteExistingFiles?: boolean\n  req: PayloadRequest\n  throwOnMissingFile?: boolean\n}\n\ntype Result<T> = Promise<{\n  data: T\n  files: FileToSave[]\n}>\n\nconst shouldReupload = (\n  uploadEdits: UploadEdits,\n  fileData: Record<string, unknown> | undefined,\n) => {\n  if (!fileData) {\n    return false\n  }\n\n  if (uploadEdits.crop || uploadEdits.heightInPixels || uploadEdits.widthInPixels) {\n    return true\n  }\n\n  // Since uploadEdits always has focalPoint, compare to the value in the data if it was changed\n  if (uploadEdits.focalPoint) {\n    const incomingFocalX = uploadEdits.focalPoint.x\n    const incomingFocalY = uploadEdits.focalPoint.y\n\n    const currentFocalX = 'focalX' in fileData && fileData.focalX\n    const currentFocalY = 'focalY' in fileData && fileData.focalY\n\n    const isEqual = incomingFocalX === currentFocalX && incomingFocalY === currentFocalY\n    return !isEqual\n  }\n\n  return false\n}\n\nexport const generateFileData = async <T>({\n  collection: { config: collectionConfig },\n  data,\n  isDuplicating,\n  operation,\n  originalDoc,\n  overwriteExistingFiles,\n  req,\n  throwOnMissingFile,\n}: Args<T>): Result<T> => {\n  if (!collectionConfig.upload) {\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  const { sharp } = req.payload.config\n\n  let file = req.file\n\n  const uploadEdits = parseUploadEditsFromReqOrIncomingData({\n    data,\n    isDuplicating,\n    operation,\n    originalDoc,\n    req,\n  })\n\n  const {\n    constructorOptions,\n    disableLocalStorage,\n    focalPoint: focalPointEnabled = true,\n    formatOptions,\n    imageSizes,\n    resizeOptions,\n    staticDir,\n    trimOptions,\n    withMetadata,\n  } = collectionConfig.upload\n\n  const staticPath = staticDir\n\n  const incomingFileData = isDuplicating ? originalDoc : data\n\n  if (\n    !file &&\n    (isDuplicating || shouldReupload(uploadEdits, incomingFileData as Record<string, unknown>))\n  ) {\n    const { filename, url } = incomingFileData as unknown as FileData\n\n    if (filename && (filename.includes('../') || filename.includes('..\\\\'))) {\n      throw new Forbidden(req.t)\n    }\n\n    try {\n      if (url && url.startsWith('/') && !disableLocalStorage) {\n        const filePath = `${staticPath}/${filename}`\n        const response = await getFileByPath(filePath)\n        file = response\n        overwriteExistingFiles = true\n      } else if (filename && url) {\n        file = await getExternalFile({\n          data: incomingFileData as unknown as FileData,\n          req,\n          uploadConfig: collectionConfig.upload,\n        })\n        overwriteExistingFiles = true\n      }\n    } catch (err: unknown) {\n      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)\n    }\n  }\n\n  if (isDuplicating) {\n    overwriteExistingFiles = false\n  }\n\n  if (!file) {\n    if (throwOnMissingFile) {\n      throw new MissingFile(req.t)\n    }\n\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  await checkFileRestrictions({\n    collection: collectionConfig,\n    file,\n    req,\n  })\n\n  if (!disableLocalStorage) {\n    await fs.mkdir(staticPath!, { recursive: true })\n  }\n\n  let newData = data\n  const filesToSave: FileToSave[] = []\n  const fileData: Partial<FileData> = {}\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const cropData =\n    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined\n\n  try {\n    const fileSupportsResize = canResizeImage(file.mimetype)\n    let fsSafeName: string\n    let sharpFile: Sharp | undefined\n    let dimensions: ProbedImageSize | undefined\n    let fileBuffer!: { data: Buffer; info: OutputInfo }\n    let ext\n    let mime: string\n    const fileHasAdjustments =\n      fileSupportsResize &&\n      Boolean(\n        resizeOptions || formatOptions || trimOptions || constructorOptions || file.tempFilePath,\n      )\n\n    const sharpOptions: SharpOptions = { ...constructorOptions }\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {\n      if (file.tempFilePath) {\n        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      } else {\n        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      }\n\n      if (fileHasAdjustments) {\n        if (resizeOptions) {\n          sharpFile = sharpFile.resize(resizeOptions)\n        }\n        if (formatOptions) {\n          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)\n        }\n        if (trimOptions) {\n          sharpFile = sharpFile.trim(trimOptions)\n        }\n      }\n    }\n\n    if (fileSupportsResize || isImage(file.mimetype)) {\n      dimensions = await getImageSize(file)\n      fileData.width = dimensions.width\n      fileData.height = dimensions.height\n    }\n\n    if (sharpFile) {\n      const metadata = await sharpFile.metadata()\n      sharpFile = await optionallyAppendMetadata({\n        req,\n        sharpFile,\n        withMetadata: withMetadata!,\n      })\n      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })\n      ;({ ext, mime } = (await fileTypeFromBuffer(fileBuffer.data))!) // This is getting an incorrect gif height back.\n      fileData.width = fileBuffer.info.width\n      fileData.height = fileBuffer.info.height\n      fileData.filesize = fileBuffer.info.size\n\n      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages\n      if (metadata.pages) {\n        fileData.height = fileBuffer.info.height / metadata.pages\n        fileData.filesize = fileBuffer.data.length\n      }\n    } else {\n      mime = file.mimetype\n      fileData.filesize = file.size\n\n      if (file.name.includes('.')) {\n        ext = file.name.split('.').pop()?.split('?')[0]\n      } else {\n        ext = ''\n      }\n    }\n\n    // Adjust SVG mime type. fromBuffer modifies it.\n    if (mime === 'application/xml' && ext === 'svg') {\n      mime = 'image/svg+xml'\n    }\n    fileData.mimeType = mime\n\n    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)\n    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`\n\n    if (!overwriteExistingFiles) {\n      fsSafeName = await getSafeFileName({\n        collectionSlug: collectionConfig.slug,\n        desiredFilename: fsSafeName,\n        req,\n        staticPath: staticPath!,\n      })\n    }\n\n    fileData.filename = fsSafeName\n    let fileForResize = file\n\n    if (cropData && sharp) {\n      const { data: croppedImage, info } = await cropImage({\n        cropData,\n        dimensions: dimensions!,\n        file,\n        heightInPixels: uploadEdits.heightInPixels!,\n        req,\n        sharp,\n        widthInPixels: uploadEdits.widthInPixels!,\n        withMetadata,\n      })\n\n      // Apply resize after cropping to ensure it conforms to resizeOptions\n      if (resizeOptions && !resizeOptions.withoutEnlargement) {\n        const resizedAfterCrop = await sharp(croppedImage)\n          .resize({\n            fit: resizeOptions?.fit || 'cover',\n            height: resizeOptions?.height,\n            position: resizeOptions?.position || 'center',\n            width: resizeOptions?.width,\n          })\n          .toBuffer({ resolveWithObject: true })\n\n        filesToSave.push({\n          buffer: resizedAfterCrop.data,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...fileForResize,\n          data: resizedAfterCrop.data,\n          size: resizedAfterCrop.info.size,\n        }\n\n        fileData.width = resizedAfterCrop.info.width\n        fileData.height = resizedAfterCrop.info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile!.metadata()\n          fileData.height = metadata.pages\n            ? resizedAfterCrop.info.height / metadata.pages\n            : resizedAfterCrop.info.height\n        }\n        fileData.filesize = resizedAfterCrop.info.size\n      } else {\n        // If resizeOptions is not present, just save the cropped image\n        filesToSave.push({\n          buffer: croppedImage,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...file,\n          data: croppedImage,\n          size: info.size,\n        }\n\n        fileData.width = info.width\n        fileData.height = info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile!.metadata()\n          fileData.height = metadata.pages ? info.height / metadata.pages : info.height\n        }\n        fileData.filesize = info.size\n      }\n\n      if (file.tempFilePath) {\n        await fs.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path\n      } else {\n        req.file = fileForResize\n      }\n    } else {\n      filesToSave.push({\n        buffer: fileBuffer?.data || file.data,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      // If using temp files and the image is being resized, write the file to the temp path\n      if (fileBuffer?.data || file.data.length > 0) {\n        if (file.tempFilePath) {\n          await fs.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path\n        } else {\n          // Assign the _possibly modified_ file to the request object\n          req.file = {\n            ...file,\n            data: fileBuffer?.data || file.data,\n            size: fileBuffer?.info.size,\n          }\n        }\n      }\n    }\n\n    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {\n      req.payloadUploadSizes = {}\n      const { focalPoint, sizeData, sizesToSave } = await resizeAndTransformImageSizes({\n        config: collectionConfig,\n        dimensions: !cropData\n          ? dimensions!\n          : {\n              ...dimensions,\n              height: fileData.height!,\n              width: fileData.width!,\n            },\n        file: fileForResize,\n        mimeType: fileData.mimeType,\n        req,\n        savedFilename: fsSafeName || file.name,\n        sharp,\n        staticPath: staticPath!,\n        uploadEdits,\n        withMetadata,\n      })\n\n      fileData.sizes = sizeData\n      fileData.focalX = focalPoint?.x\n      fileData.focalY = focalPoint?.y\n      filesToSave.push(...sizesToSave)\n    }\n  } catch (err) {\n    req.payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n\n  newData = {\n    ...newData,\n    ...fileData,\n  }\n\n  return {\n    data: newData,\n    files: filesToSave,\n  }\n}\n\n/**\n * Parse upload edits from req or incoming data\n */\nfunction parseUploadEditsFromReqOrIncomingData(args: {\n  data: unknown\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc: unknown\n  req: PayloadRequest\n}): UploadEdits {\n  const { data, isDuplicating, operation, originalDoc, req } = args\n\n  // Get intended focal point change from query string or incoming data\n  const uploadEdits =\n    req.query?.uploadEdits && typeof req.query.uploadEdits === 'object'\n      ? (req.query.uploadEdits as UploadEdits)\n      : {}\n\n  if (uploadEdits.focalPoint) {\n    return uploadEdits\n  }\n\n  const incomingData = data as FileData\n  const origDoc = originalDoc as FileData\n\n  if (origDoc && 'focalX' in origDoc && 'focalY' in origDoc) {\n    // If no change in focal point, return undefined.\n    // This prevents a refocal operation triggered from admin, because it always sends the focal point.\n    if (incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {\n      return undefined!\n    }\n\n    if (isDuplicating) {\n      uploadEdits.focalPoint = {\n        x: incomingData?.focalX || origDoc.focalX!,\n        y: incomingData?.focalY || origDoc.focalX!,\n      }\n    }\n  }\n\n  if (incomingData?.focalX && incomingData?.focalY) {\n    uploadEdits.focalPoint = {\n      x: incomingData.focalX,\n      y: incomingData.focalY,\n    }\n    return uploadEdits\n  }\n\n  // If no focal point is set, default to center\n  if (operation === 'create') {\n    uploadEdits.focalPoint = {\n      x: 50,\n      y: 50,\n    }\n  }\n\n  return uploadEdits\n}\n"],"names":["fileTypeFromBuffer","fs","sanitize","FileRetrievalError","FileUploadError","Forbidden","MissingFile","canResizeImage","checkFileRestrictions","cropImage","getExternalFile","getFileByPath","getImageSize","getSafeFileName","resizeAndTransformImageSizes","isImage","optionallyAppendMetadata","shouldReupload","uploadEdits","fileData","crop","heightInPixels","widthInPixels","focalPoint","incomingFocalX","x","incomingFocalY","y","currentFocalX","focalX","currentFocalY","focalY","isEqual","generateFileData","collection","config","collectionConfig","data","isDuplicating","operation","originalDoc","overwriteExistingFiles","req","throwOnMissingFile","upload","files","sharp","payload","file","parseUploadEditsFromReqOrIncomingData","constructorOptions","disableLocalStorage","focalPointEnabled","formatOptions","imageSizes","resizeOptions","staticDir","trimOptions","withMetadata","staticPath","incomingFileData","filename","url","includes","t","startsWith","filePath","response","uploadConfig","err","Error","message","undefined","mkdir","recursive","newData","filesToSave","fileIsAnimatedType","mimetype","cropData","fileSupportsResize","fsSafeName","sharpFile","dimensions","fileBuffer","ext","mime","fileHasAdjustments","Boolean","tempFilePath","sharpOptions","animated","rotate","resize","toFormat","format","options","trim","width","height","metadata","toBuffer","resolveWithObject","info","filesize","size","pages","length","name","split","pop","mimeType","baseFilename","substring","lastIndexOf","collectionSlug","slug","desiredFilename","fileForResize","croppedImage","withoutEnlargement","resizedAfterCrop","fit","position","push","buffer","path","writeFile","Array","isArray","payloadUploadSizes","sizeData","sizesToSave","savedFilename","sizes","logger","error","args","query","incomingData","origDoc"],"mappings":"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"}