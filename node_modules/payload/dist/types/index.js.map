{"version":3,"sources":["../../src/types/index.ts"],"sourcesContent":["import type { I18n, TFunction } from '@payloadcms/translations'\nimport type DataLoader from 'dataloader'\nimport type { OptionalKeys, RequiredKeys } from 'ts-essentials'\nimport type { URL } from 'url'\n\nimport type {\n  DataFromCollectionSlug,\n  TypeWithID,\n  TypeWithTimestamps,\n} from '../collections/config/types.js'\nimport type payload from '../index.js'\nimport type {\n  CollectionSlug,\n  DataFromGlobalSlug,\n  GlobalSlug,\n  Payload,\n  RequestContext,\n  TypedCollectionJoins,\n  TypedCollectionSelect,\n  TypedLocale,\n  TypedUser,\n} from '../index.js'\nimport type { Operator } from './constants.js'\nexport type { Payload } from '../index.js'\n\nexport type CustomPayloadRequestProperties = {\n  context: RequestContext\n  /** The locale that should be used for a field when it is not translated to the requested locale */\n  fallbackLocale?: string | string[]\n  i18n: I18n\n  /**\n   * The requested locale if specified\n   * Only available for localized collections\n   *\n   * Suppressing warning below as it is a valid use case - won't be an issue if generated types exist\n   */\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  locale?: 'all' | TypedLocale\n  /**\n   * The payload object\n   */\n  payload: typeof payload\n  /**\n   * The context in which the request is being made\n   */\n  payloadAPI: 'GraphQL' | 'local' | 'REST'\n  /** Optimized document loader */\n  payloadDataLoader: {\n    /**\n     * Wraps `payload.find` with a cache to deduplicate requests\n     * @experimental This is may be replaced by a more robust cache strategy in future versions\n     * By calling this method with the same arguments many times in one request, it will only be handled one time\n     * const result = await req.payloadDataLoader.find({\n     *  collection,\n     *  req,\n     *  where: findWhere,\n     * })\n     */\n    find: Payload['find']\n  } & DataLoader<string, TypeWithID>\n  /** Resized versions of the image that was uploaded during this request */\n  payloadUploadSizes?: Record<string, Buffer>\n  /** Query params on the request */\n  query: Record<string, unknown>\n  /** Any response headers that are required to be set when a response is sent */\n  responseHeaders?: Headers\n  /** The route parameters\n   * @example\n   * /:collection/:id -> /posts/123\n   * { collection: 'posts', id: '123' }\n   */\n  routeParams?: Record<string, unknown>\n  /** Translate function - duplicate of i18n.t */\n  t: TFunction\n  /**\n   * Identifier for the database transaction for interactions in a single, all-or-nothing operation.\n   * Can also be used to ensure consistency when multiple operations try to create a transaction concurrently on the same request.\n   */\n  transactionID?: number | Promise<number | string> | string\n  /**\n   * Used to ensure consistency when multiple operations try to create a transaction concurrently on the same request\n   * @deprecated This is not used anywhere, instead `transactionID` is used for the above. Will be removed in next major version.\n   */\n  transactionIDPromise?: Promise<void>\n  /** The signed-in user */\n  user: null | TypedUser\n} & Pick<\n  URL,\n  'hash' | 'host' | 'href' | 'origin' | 'pathname' | 'port' | 'protocol' | 'search' | 'searchParams'\n>\ntype PayloadRequestData = {\n  /**\n   * Data from the request body\n   *\n   * Within Payload operations, i.e. hooks, data will be there\n   * BUT in custom endpoints it will not be, you will need to\n   * use either:\n   *  1. `const data = await req.json()`\n   *\n   *  2. import { addDataAndFileToRequest } from 'payload'\n   *    `await addDataAndFileToRequest(req)`\n   * */\n  data?: JsonObject\n  /** The file on the request, same rules apply as the `data` property */\n  file?: {\n    /**\n     * Context of the file when it was uploaded via client side.\n     */\n    clientUploadContext?: unknown\n    data: Buffer\n    mimetype: string\n    name: string\n    size: number\n    tempFilePath?: string\n  }\n}\nexport type PayloadRequest = CustomPayloadRequestProperties &\n  Partial<Request> &\n  PayloadRequestData &\n  Required<Pick<Request, 'headers'>>\n\nexport type { Operator }\n\n// Makes it so things like passing new Date() will error\nexport type JsonValue = JsonArray | JsonObject | unknown //Date | JsonArray | JsonObject | boolean | null | number | string // TODO: Evaluate proper, strong type for this\n\nexport type JsonArray = Array<JsonValue>\n\nexport interface JsonObject {\n  [key: string]: any\n}\n\nexport type WhereField = {\n  // any json-serializable value\n  [key in Operator]?: JsonValue\n}\n\nexport type Where = {\n  [key: string]: Where[] | WhereField\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  and?: Where[]\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  or?: Where[]\n}\n\nexport type Sort = Array<string> | string\n\ntype SerializableValue = boolean | number | object | string\nexport type DefaultValue =\n  | ((args: {\n      locale?: TypedLocale\n      req: PayloadRequest\n      user: PayloadRequest['user']\n    }) => SerializableValue)\n  | SerializableValue\n\n/**\n * Applies pagination for join fields for including collection relationships\n */\nexport type JoinQuery<TSlug extends CollectionSlug = string> =\n  TypedCollectionJoins[TSlug] extends Record<string, string>\n    ?\n        | false\n        | Partial<{\n            [K in keyof TypedCollectionJoins[TSlug]]:\n              | {\n                  count?: boolean\n                  limit?: number\n                  page?: number\n                  sort?: string\n                  where?: Where\n                }\n              | false\n          }>\n    : never\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Document = any\n\nexport type Operation = 'create' | 'delete' | 'read' | 'update'\nexport type VersionOperations = 'readVersions'\nexport type AuthOperations = 'unlock'\nexport type AllOperations = AuthOperations | Operation | VersionOperations\n\nexport function docHasTimestamps(doc: any): doc is TypeWithTimestamps {\n  return doc?.createdAt && doc?.updatedAt\n}\n\nexport type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N // This is a commonly used trick to detect 'any'\nexport type IsAny<T> = IfAny<T, true, false>\nexport type ReplaceAny<T, DefaultType> = IsAny<T> extends true ? DefaultType : T\n\nexport type SelectIncludeType = {\n  [k: string]: SelectIncludeType | true\n}\n\nexport type SelectExcludeType = {\n  [k: string]: false | SelectExcludeType\n}\n\nexport type SelectMode = 'exclude' | 'include'\n\nexport type SelectType = SelectExcludeType | SelectIncludeType\n\nexport type ApplyDisableErrors<T, DisableErrors = false> = false extends DisableErrors\n  ? T\n  : null | T\n\nexport type TransformDataWithSelect<\n  Data extends Record<string, any>,\n  Select extends SelectType,\n> = Select extends never\n  ? Data\n  : string extends keyof Select\n    ? Data\n    : // START Handle types when they aren't generated\n      // For example in any package in this repository outside of tests / plugins\n      // This stil gives us autocomplete when using include select mode, i.e select: {title :true} returns type {title: any, id: string | number}\n      string extends keyof Omit<Data, 'id'>\n      ? Select extends SelectIncludeType\n        ? {\n            [K in Data extends TypeWithID ? 'id' | keyof Select : keyof Select]: K extends 'id'\n              ? number | string\n              : unknown\n          }\n        : Data\n      : // END Handle types when they aren't generated\n        // Handle include mode\n        Select extends SelectIncludeType\n        ? {\n            [K in keyof Data as K extends keyof Select\n              ? Select[K] extends object | true\n                ? K\n                : never\n              : // select 'id' always\n                K extends 'id'\n                ? K\n                : never]: Data[K]\n          }\n        : // Handle exclude mode\n          {\n            [K in keyof Data as K extends keyof Select\n              ? Select[K] extends object | undefined\n                ? K\n                : never\n              : K]: Data[K]\n          }\n\nexport type TransformCollectionWithSelect<\n  TSlug extends CollectionSlug,\n  TSelect extends SelectType,\n> = TSelect extends SelectType\n  ? TransformDataWithSelect<DataFromCollectionSlug<TSlug>, TSelect>\n  : DataFromCollectionSlug<TSlug>\n\nexport type TransformGlobalWithSelect<\n  TSlug extends GlobalSlug,\n  TSelect extends SelectType,\n> = TSelect extends SelectType\n  ? TransformDataWithSelect<DataFromGlobalSlug<TSlug>, TSelect>\n  : DataFromGlobalSlug<TSlug>\n\nexport type PopulateType = Partial<TypedCollectionSelect>\n\nexport type ResolvedFilterOptions = { [collection: string]: Where }\n\nexport type PickPreserveOptional<T, K extends keyof T> = Partial<\n  Pick<T, Extract<K, OptionalKeys<T>>>\n> &\n  Pick<T, Extract<K, RequiredKeys<T>>>\n"],"names":["docHasTimestamps","doc","createdAt","updatedAt"],"mappings":"AAwLA,OAAO,SAASA,iBAAiBC,GAAQ;IACvC,OAAOA,KAAKC,aAAaD,KAAKE;AAChC"}