{"version":3,"sources":["../../../../src/fields/hooks/beforeValidate/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, JsonValue, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName, valueIsValueWithRelation } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { getExistingRowDoc } from '../beforeChange/getExistingRowDoc.js'\nimport { getFallbackValue } from './getFallbackValue.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: T\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n}\n\n// This function is responsible for the following actions, in order:\n// - Sanitize incoming data\n// - Execute field hooks\n// - Execute field access control\n// - Merge original document data into incoming data\n// - Compute default values for undefined fields\n\nexport const promise = async <T>({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  fieldIndex,\n  global,\n  operation,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingFields,\n}: Args<T>): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    if (field.name === 'id') {\n      if (field.type === 'number' && typeof siblingData[field.name] === 'string') {\n        const value = siblingData[field.name] as string\n\n        siblingData[field.name] = parseFloat(value)\n      }\n\n      if (\n        field.type === 'text' &&\n        typeof siblingData[field.name]?.toString === 'function' &&\n        typeof siblingData[field.name] !== 'string'\n      ) {\n        siblingData[field.name] = siblingData[field.name].toString()\n      }\n    }\n\n    // Sanitize incoming data\n    switch (field.type) {\n      case 'array':\n      case 'blocks': {\n        // Handle cases of arrays being intentionally set to 0\n        if (siblingData[field.name] === '0' || siblingData[field.name] === 0) {\n          siblingData[field.name] = []\n        }\n\n        break\n      }\n\n      case 'checkbox': {\n        if (siblingData[field.name] === 'true') {\n          siblingData[field.name] = true\n        }\n        if (siblingData[field.name] === 'false') {\n          siblingData[field.name] = false\n        }\n        if (siblingData[field.name] === '') {\n          siblingData[field.name] = false\n        }\n\n        break\n      }\n\n      case 'number': {\n        if (typeof siblingData[field.name] === 'string') {\n          const value = siblingData[field.name] as string\n          const trimmed = value.trim()\n          siblingData[field.name] = trimmed.length === 0 ? null : parseFloat(trimmed)\n        }\n\n        break\n      }\n\n      case 'point': {\n        if (Array.isArray(siblingData[field.name])) {\n          siblingData[field.name] = (siblingData[field.name] as string[]).map((coordinate, i) => {\n            if (typeof coordinate === 'string') {\n              const value = siblingData[field.name][i] as string\n              const trimmed = value.trim()\n              return trimmed.length === 0 ? null : parseFloat(trimmed)\n            }\n            return coordinate\n          })\n        }\n\n        break\n      }\n      case 'relationship':\n      case 'upload': {\n        if (\n          siblingData[field.name] === '' ||\n          siblingData[field.name] === 'none' ||\n          siblingData[field.name] === 'null' ||\n          siblingData[field.name] === null\n        ) {\n          if (field.hasMany === true) {\n            siblingData[field.name] = []\n          } else {\n            siblingData[field.name] = null\n          }\n        }\n\n        const value = siblingData[field.name]\n\n        if (Array.isArray(field.relationTo)) {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: { relationTo: string; value: JsonValue }, i) => {\n              const relatedCollection = req.payload.collections?.[relatedDoc.relationTo]?.config\n\n              if (\n                typeof relatedDoc.value === 'object' &&\n                relatedDoc.value &&\n                'id' in relatedDoc.value\n              ) {\n                relatedDoc.value = relatedDoc.value.id\n              }\n\n              if (relatedCollection?.fields) {\n                const relationshipIDField = relatedCollection.fields.find(\n                  (collectionField) =>\n                    fieldAffectsData(collectionField) && collectionField.name === 'id',\n                )\n                if (relationshipIDField?.type === 'number') {\n                  siblingData[field.name][i] = {\n                    ...relatedDoc,\n                    value: parseFloat(relatedDoc.value as string),\n                  }\n                }\n              }\n            })\n          }\n          if (field.hasMany !== true && valueIsValueWithRelation(value)) {\n            const relatedCollection = req.payload.collections?.[value.relationTo]?.config\n\n            if (typeof value.value === 'object' && value.value && 'id' in value.value) {\n              value.value = (value.value as TypeWithID).id\n            }\n\n            if (relatedCollection?.fields) {\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name] = { ...value, value: parseFloat(value.value as string) }\n              }\n            }\n          }\n        } else {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: unknown, i) => {\n              const relatedCollection = Array.isArray(field.relationTo)\n                ? undefined\n                : req.payload.collections?.[field.relationTo]?.config\n\n              if (typeof relatedDoc === 'object' && relatedDoc && 'id' in relatedDoc) {\n                value[i] = relatedDoc.id\n              }\n\n              if (relatedCollection?.fields) {\n                const relationshipIDField = relatedCollection.fields.find(\n                  (collectionField) =>\n                    fieldAffectsData(collectionField) && collectionField.name === 'id',\n                )\n                if (relationshipIDField?.type === 'number') {\n                  siblingData[field.name][i] = parseFloat(relatedDoc as string)\n                }\n              }\n            })\n          }\n          if (field.hasMany !== true && value) {\n            const relatedCollection = req.payload.collections?.[field.relationTo]?.config\n\n            if (typeof value === 'object' && value && 'id' in value) {\n              siblingData[field.name] = value.id\n            }\n\n            if (relatedCollection?.fields) {\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name] = parseFloat(value as string)\n              }\n            }\n          }\n        }\n        break\n      }\n      case 'richText': {\n        if (typeof siblingData[field.name] === 'string') {\n          try {\n            const richTextJSON = JSON.parse(siblingData[field.name] as string)\n            siblingData[field.name] = richTextJSON\n          } catch {\n            // Disregard this data as it is not valid.\n            // Will be reported to user by field validation\n          }\n        }\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n\n    // ensure the fallback value is only computed one time\n    // either here or when access control returns false\n    const fallbackResult: { executed: boolean; value: unknown } = {\n      executed: false,\n      value: undefined,\n    }\n    if (typeof siblingData[field.name!] === 'undefined') {\n      fallbackResult.value = await getFallbackValue({ field, req, siblingDoc })\n      fallbackResult.executed = true\n    }\n\n    // Execute hooks\n    if ('hooks' in field && field.hooks?.beforeValidate) {\n      for (const hook of field.hooks.beforeValidate) {\n        const hookedValue = await hook({\n          blockData,\n          collection,\n          context,\n          data: data as Partial<T>,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          overrideAccess,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          siblingFields: siblingFields!,\n          value:\n            typeof siblingData[field.name] === 'undefined'\n              ? fallbackResult.value\n              : siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }\n    }\n\n    // Execute access control\n    if (field.access && field.access[operation]) {\n      const result = overrideAccess\n        ? true\n        : await field.access[operation]({\n            id,\n            blockData,\n            data: data as Partial<T>,\n            doc,\n            req,\n            siblingData,\n          })\n\n      if (!result) {\n        delete siblingData[field.name!]\n      }\n    }\n\n    if (typeof siblingData[field.name!] === 'undefined') {\n      siblingData[field.name!] = !fallbackResult.executed\n        ? await getFallbackValue({ field, req, siblingDoc })\n        : fallbackResult.value\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises: Promise<void>[] = []\n\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              id,\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              overrideAccess,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              req,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises: Promise<void>[] = []\n\n        rows.forEach((row, rowIndex) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          if (block) {\n            ;(row as JsonObject).blockType = blockTypeToMatch\n\n            promises.push(\n              traverseFields({\n                id,\n                blockData: row,\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                overrideAccess,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                req,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    case 'group': {\n      let groupSiblingData = siblingData\n      let groupSiblingDoc = siblingDoc\n\n      const isNamedGroup = fieldAffectsData(field)\n\n      if (isNamedGroup) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        groupSiblingData = siblingData[field.name] as Record<string, unknown>\n        groupSiblingDoc = siblingDoc[field.name] as Record<string, unknown>\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: isNamedGroup ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedGroup ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: groupSiblingData,\n        siblingDoc: groupSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeValidate?.length) {\n        for (const hook of editor.hooks.beforeValidate) {\n          const hookedValue = await hook({\n            collection,\n            context,\n            data: data as Partial<T>,\n            field,\n            global,\n            indexPath: indexPathSegments,\n            operation,\n            originalDoc: doc,\n            overrideAccess,\n            parentIsLocalized,\n            path: pathSegments,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingData[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData\n      let tabSiblingDoc\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as Record<string, unknown>\n        tabSiblingDoc = siblingDoc[field.name] as Record<string, unknown>\n      } else {\n        tabSiblingData = siblingData\n        tabSiblingDoc = siblingDoc\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","valueIsValueWithRelation","getFieldPathsModified","getFieldPaths","getExistingRowDoc","getFallbackValue","traverseFields","promise","id","blockData","collection","context","data","doc","field","fieldIndex","global","operation","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingFields","indexPath","path","schemaPath","index","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","name","type","value","parseFloat","toString","trimmed","trim","length","Array","isArray","coordinate","i","hasMany","relationTo","forEach","relatedDoc","relatedCollection","payload","collections","config","fields","relationshipIDField","find","collectionField","undefined","richTextJSON","JSON","parse","fallbackResult","executed","hooks","beforeValidate","hook","hookedValue","originalDoc","previousSiblingDoc","previousValue","access","result","rows","promises","row","rowIndex","push","localized","Promise","all","rowSiblingDoc","blockTypeToMatch","blockType","block","blocks","blockReferences","curBlock","slug","groupSiblingData","groupSiblingDoc","isNamedGroup","editor","Error","tabSiblingData","tabSiblingDoc","isNamedTab","tabs","tab"],"mappings":"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"}