{"version":3,"sources":["../../../../src/fields/hooks/beforeChange/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, TabAsField, Validate } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { type RequestContext, validateBlocksFilterOptions } from '../../../index.js'\nimport { deepMergeWithSourceArrays } from '../../../utilities/deepMerge.js'\nimport { getTranslatedLabel } from '../../../utilities/getTranslatedLabel.js'\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { getExistingRowDoc } from './getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\nfunction buildFieldLabel(parentLabel: string, label: string | undefined): string {\n  if (!label) {\n    return parentLabel\n  }\n  const capitalizedLabel = label.charAt(0).toUpperCase() + label.slice(1)\n  return parentLabel && capitalizedLabel\n    ? `${parentLabel} > ${capitalizedLabel}`\n    : capitalizedLabel || parentLabel\n}\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  docWithLocales: JsonObject\n  errors: ValidationFieldError[]\n  field: Field | TabAsField\n  fieldIndex: number\n  /**\n   * Built up labels of parent fields\n   *\n   * @example \"Group Field > Tab Field > Text Field\"\n   */\n  fieldLabelPath: string\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void> | void)[]\n  operation: Operation\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingDocWithLocales?: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n  skipValidation: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Run condition\n// - Execute field hooks\n// - Validate data\n// - Transform data for storage\n// - beforeDuplicate hooks (if duplicate)\n// - Unflatten locales\n\nexport const promise = async ({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  field,\n  fieldIndex,\n  fieldLabelPath,\n  global,\n  mergeLocaleActions,\n  operation,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  siblingFields,\n  skipValidation,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const { localization } = req.payload.config\n  const defaultLocale = localization ? localization?.defaultLocale : 'en'\n  const operationLocale = req.locale || defaultLocale\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  const passesCondition = field.admin?.condition\n    ? Boolean(\n        field.admin.condition(data, siblingData, {\n          blockData: blockData!,\n          operation,\n          path: pathSegments,\n          user: req.user,\n        }),\n      )\n    : true\n  let skipValidationFromHere = skipValidation || !passesCondition\n\n  if (fieldAffectsData(field)) {\n    // skip validation if the field is localized and the incoming data is null\n    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && operationLocale !== defaultLocale) {\n      if (['array', 'blocks'].includes(field.type) && siblingData[field.name!] === null) {\n        skipValidationFromHere = true\n      }\n    }\n\n    // Execute hooks\n    if ('hooks' in field && field.hooks?.beforeChange) {\n      for (const hook of field.hooks.beforeChange) {\n        const hookedValue = await hook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          siblingDocWithLocales,\n          siblingFields: siblingFields!,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }\n    }\n\n    // Validate\n    if (!skipValidationFromHere && 'validate' in field && field.validate) {\n      const valueToValidate = siblingData[field.name]\n      let jsonError: object\n\n      if (field.type === 'json' && typeof siblingData[field.name] === 'string') {\n        try {\n          JSON.parse(siblingData[field.name] as string)\n        } catch (e) {\n          jsonError = e as object\n        }\n      }\n\n      const validateFn: Validate<object, object, object, object> = field.validate as Validate<\n        object,\n        object,\n        object,\n        object\n      >\n\n      const validationResult = await validateFn(valueToValidate as never, {\n        ...field,\n        id,\n        blockData: blockData!,\n        collectionSlug: collection?.slug,\n        data: deepMergeWithSourceArrays(doc, data),\n        event: 'submit',\n        // @ts-expect-error\n        jsonError,\n        operation,\n        overrideAccess,\n        path: pathSegments,\n        preferences: { fields: {} },\n        previousValue: siblingDoc[field.name],\n        req,\n        siblingData: deepMergeWithSourceArrays(siblingDoc, siblingData),\n      })\n\n      if (typeof validationResult === 'string') {\n        let filterOptionsError = false\n\n        if (field.type === 'blocks' && field.filterOptions) {\n          // Re-run filteroptions. If the validation error is due to filteroptions, we need to add error paths to all the blocks\n          // that are no longer valid\n          const validationResult = await validateBlocksFilterOptions({\n            id,\n            data,\n            filterOptions: field.filterOptions,\n            req,\n            siblingData,\n            value: siblingData[field.name],\n          })\n          if (validationResult?.invalidBlockSlugs?.length) {\n            filterOptionsError = true\n            let rowIndex = -1\n            for (const block of siblingData[field.name] as JsonObject[]) {\n              rowIndex++\n              if (validationResult.invalidBlockSlugs.includes(block.blockType as string)) {\n                const blockConfigOrSlug = (field.blockReferences ?? field.blocks).find(\n                  (blockFromField) =>\n                    typeof blockFromField === 'string'\n                      ? blockFromField === block.blockType\n                      : blockFromField.slug === block.blockType,\n                ) as Block | undefined\n                const blockConfig =\n                  typeof blockConfigOrSlug !== 'string'\n                    ? blockConfigOrSlug\n                    : req.payload.config?.blocks?.[blockConfigOrSlug]\n\n                const blockLabelPath =\n                  field?.label === false\n                    ? fieldLabelPath\n                    : buildFieldLabel(\n                        fieldLabelPath,\n                        `${getTranslatedLabel(field?.label || field?.name, req.i18n)} > ${req.t('fields:block')} ${rowIndex + 1} (${getTranslatedLabel(blockConfig?.labels?.singular || block.blockType, req.i18n)})`,\n                      )\n\n                errors.push({\n                  label: blockLabelPath,\n                  message: req.t('validation:invalidBlock', { block: block.blockType }),\n                  path: `${path}.${rowIndex}.id`,\n                })\n              }\n            }\n          }\n        }\n\n        if (!filterOptionsError) {\n          // If the error is due to block filterOptions, we want to push the errors for each individual block, not the blocks\n          // field itself => only push the error if the field is not a block field with validation failure due to filterOptions\n          const fieldLabel = buildFieldLabel(\n            fieldLabelPath,\n            getTranslatedLabel(field?.label || field?.name, req.i18n),\n          )\n\n          errors.push({\n            label: fieldLabel,\n            message: validationResult,\n            path,\n          })\n        }\n      }\n    }\n\n    // Push merge locale action if applicable\n    if (localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n      mergeLocaleActions.push(() => {\n        const localeData: Record<string, unknown> = {}\n\n        for (const locale of localization.localeCodes) {\n          const fieldValue =\n            locale === req.locale\n              ? siblingData[field.name!]\n              : siblingDocWithLocales?.[field.name!]?.[locale]\n\n          // update locale value if it's not undefined\n          if (typeof fieldValue !== 'undefined') {\n            localeData[locale] = fieldValue\n          }\n        }\n\n        // If there are locales with data, set the data\n        if (Object.keys(localeData).length > 0) {\n          siblingData[field.name!] = localeData\n        }\n      })\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises: Promise<void>[] = []\n\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              id,\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              docWithLocales,\n              errors,\n              fieldLabelPath:\n                field?.label === false\n                  ? fieldLabelPath\n                  : buildFieldLabel(\n                      fieldLabelPath,\n                      `${getTranslatedLabel(field?.label || field?.name, req.i18n)} ${rowIndex + 1}`,\n                    ),\n              fields: field.fields,\n              global,\n              mergeLocaleActions,\n              operation,\n              overrideAccess,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              req,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n              siblingDocWithLocales: getExistingRowDoc(\n                row as JsonObject,\n                siblingDocWithLocales?.[field.name],\n              ),\n              skipValidation: skipValidationFromHere,\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n      if (Array.isArray(rows)) {\n        const promises: Promise<void>[] = []\n\n        rows.forEach((row, rowIndex) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n\n          const rowSiblingDocWithLocales = getExistingRowDoc(\n            row as JsonObject,\n            siblingDocWithLocales ? siblingDocWithLocales[field.name] : {},\n          )\n\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          const blockLabelPath =\n            field?.label === false\n              ? fieldLabelPath\n              : buildFieldLabel(\n                  fieldLabelPath,\n                  `${getTranslatedLabel(field?.label || field?.name, req.i18n)} > ${req.t('fields:block')} ${rowIndex + 1} (${getTranslatedLabel(block?.labels?.singular || blockTypeToMatch, req.i18n)})`,\n                )\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                id,\n                blockData: row,\n                collection,\n                context,\n                data,\n                doc,\n                docWithLocales,\n                errors,\n                fieldLabelPath: blockLabelPath,\n\n                fields: block.fields,\n                global,\n                mergeLocaleActions,\n                operation,\n                overrideAccess,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                req,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n                siblingDocWithLocales: rowSiblingDocWithLocales,\n                skipValidation: skipValidationFromHere,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field.type === 'row' || field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(\n                fieldLabelPath,\n                getTranslatedLabel(field?.label || field?.type, req.i18n),\n              ),\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales: siblingDocWithLocales!,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'group': {\n      let groupSiblingData = siblingData\n      let groupSiblingDoc = siblingDoc\n      let groupSiblingDocWithLocales = siblingDocWithLocales\n\n      const isNamedGroup = fieldAffectsData(field)\n\n      if (isNamedGroup) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        if (typeof siblingDocWithLocales![field.name] !== 'object') {\n          siblingDocWithLocales![field.name] = {}\n        }\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        if (typeof siblingDocWithLocales![field.name] !== 'object') {\n          siblingDocWithLocales![field.name] = {}\n        }\n\n        groupSiblingData = siblingData[field.name] as JsonObject\n        groupSiblingDoc = siblingDoc[field.name] as JsonObject\n        groupSiblingDocWithLocales = siblingDocWithLocales![field.name] as JsonObject\n      }\n\n      const fallbackLabel = field?.label || (isNamedGroup ? field.name : field?.type)\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(fieldLabelPath, getTranslatedLabel(fallbackLabel, req.i18n)),\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        overrideAccess,\n        parentIndexPath: isNamedGroup ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedGroup ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: groupSiblingData,\n        siblingDoc: groupSiblingDoc,\n        siblingDocWithLocales: groupSiblingDocWithLocales!,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'point': {\n      // Transform point data for storage\n      if (\n        Array.isArray(siblingData[field.name]) &&\n        siblingData[field.name][0] !== null &&\n        siblingData[field.name][1] !== null\n      ) {\n        siblingData[field.name] = {\n          type: 'Point',\n          coordinates: [\n            parseFloat(siblingData[field.name][0]),\n            parseFloat(siblingData[field.name][1]),\n          ],\n        }\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeChange?.length) {\n        for (const hook of editor.hooks.beforeChange) {\n          const hookedValue = await hook({\n            collection,\n            context,\n            data,\n            docWithLocales,\n            errors,\n            field,\n            fieldLabelPath:\n              field?.label === false\n                ? fieldLabelPath\n                : buildFieldLabel(\n                    fieldLabelPath,\n                    getTranslatedLabel(field?.label || field?.name, req.i18n),\n                  ),\n            global,\n            indexPath: indexPathSegments,\n            mergeLocaleActions,\n            operation,\n            originalDoc: doc,\n            overrideAccess,\n            parentIsLocalized,\n            path: pathSegments,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingDoc[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            siblingDocWithLocales,\n            skipValidation,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabSiblingDocWithLocales = siblingDocWithLocales\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        if (typeof siblingDocWithLocales![field.name] !== 'object') {\n          siblingDocWithLocales![field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as JsonObject\n        tabSiblingDoc = siblingDoc[field.name] as JsonObject\n        tabSiblingDocWithLocales = siblingDocWithLocales![field.name] as JsonObject\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(\n                fieldLabelPath,\n                getTranslatedLabel(field?.label || field.name, req.i18n),\n              ),\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        overrideAccess,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n        siblingDocWithLocales: tabSiblingDocWithLocales!,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(fieldLabelPath, getTranslatedLabel(field?.label || '', req.i18n)),\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        mergeLocaleActions,\n        operation,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales: siblingDocWithLocales!,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","validateBlocksFilterOptions","deepMergeWithSourceArrays","getTranslatedLabel","fieldAffectsData","fieldShouldBeLocalized","tabHasName","getFieldPathsModified","getFieldPaths","getExistingRowDoc","traverseFields","buildFieldLabel","parentLabel","label","capitalizedLabel","charAt","toUpperCase","slice","promise","id","blockData","collection","context","data","doc","docWithLocales","errors","field","fieldIndex","fieldLabelPath","global","mergeLocaleActions","operation","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingDocWithLocales","siblingFields","skipValidation","indexPath","path","schemaPath","index","localization","payload","config","defaultLocale","operationLocale","locale","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","passesCondition","admin","condition","user","skipValidationFromHere","includes","type","name","hooks","beforeChange","hook","hookedValue","originalDoc","previousSiblingDoc","previousValue","value","undefined","validate","valueToValidate","jsonError","JSON","parse","e","validateFn","validationResult","collectionSlug","slug","event","preferences","fields","filterOptionsError","filterOptions","invalidBlockSlugs","length","rowIndex","block","blockType","blockConfigOrSlug","blockReferences","blocks","find","blockFromField","blockConfig","blockLabelPath","i18n","t","labels","singular","push","message","fieldLabel","localeData","localeCodes","fieldValue","Object","keys","rows","Array","isArray","promises","forEach","row","localized","Promise","all","rowSiblingDoc","rowSiblingDocWithLocales","blockTypeToMatch","curBlock","groupSiblingData","groupSiblingDoc","groupSiblingDocWithLocales","isNamedGroup","fallbackLabel","coordinates","parseFloat","editor","Error","tabSiblingData","tabSiblingDoc","tabSiblingDocWithLocales","isNamedTab","tabs","tab"],"mappings":"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"}