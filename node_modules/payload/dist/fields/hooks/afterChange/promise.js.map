{"version":3,"sources":["../../../../src/fields/hooks/afterChange/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  previousDoc: JsonObject\n  previousSiblingDoc: JsonObject\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n}\n\n// This function is responsible for the following actions, in order:\n// - Execute field hooks\n\nexport const promise = async ({\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  fieldIndex,\n  global,\n  operation,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingFields,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if ('hooks' in field && field.hooks?.afterChange) {\n      for (const hook of field.hooks.afterChange) {\n        const hookedValue = await hook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          path: pathSegments,\n          previousDoc,\n          previousSiblingDoc,\n          previousValue: previousDoc?.[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          siblingFields: siblingFields!,\n          value: siblingDoc?.[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingDoc[field.name] = hookedValue\n        }\n      }\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises: Promise<void>[] = []\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              previousDoc,\n              previousSiblingDoc: previousDoc?.[field.name]?.[rowIndex] || ({} as JsonObject),\n              req,\n              siblingData: siblingData?.[field.name]?.[rowIndex] || {},\n              siblingDoc: row ? { ...row } : {},\n            }),\n          )\n        })\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises: Promise<void>[] = []\n\n        rows.forEach((row, rowIndex) => {\n          const blockTypeToMatch = (row as JsonObject).blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                blockData: siblingData?.[field.name]?.[rowIndex],\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                previousDoc,\n                previousSiblingDoc: previousDoc?.[field.name]?.[rowIndex] || ({} as JsonObject),\n                req,\n                siblingData: siblingData?.[field.name]?.[rowIndex] || {},\n                siblingDoc: row ? { ...row } : {},\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (fieldAffectsData(field)) {\n        await traverseFields({\n          blockData,\n          collection,\n          context,\n          data,\n          doc,\n          fields: field.fields,\n          global,\n          operation,\n          parentIndexPath: '',\n          parentIsLocalized: parentIsLocalized || field.localized,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          previousDoc,\n          previousSiblingDoc: (previousDoc?.[field.name] as JsonObject) || {},\n          req,\n          siblingData: (siblingData?.[field.name] as JsonObject) || {},\n          siblingDoc: (siblingDoc?.[field.name] as JsonObject) || {},\n        })\n      } else {\n        await traverseFields({\n          blockData,\n          collection,\n          context,\n          data,\n          doc,\n          fields: field.fields,\n          global,\n          operation,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          previousDoc,\n          previousSiblingDoc: { ...previousSiblingDoc },\n          req,\n          siblingData: siblingData || {},\n          siblingDoc: { ...siblingDoc },\n        })\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field.editor\n\n      if (editor?.hooks?.afterChange?.length) {\n        for (const hook of editor.hooks.afterChange) {\n          const hookedValue = await hook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            indexPath: indexPathSegments,\n            operation,\n            originalDoc: doc,\n            parentIsLocalized,\n            path: pathSegments,\n            previousDoc,\n            previousSiblingDoc,\n            previousValue: previousDoc?.[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            value: siblingDoc?.[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabPreviousSiblingDoc = siblingDoc\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        tabSiblingData = (siblingData?.[field.name] ?? {}) as JsonObject\n        tabSiblingDoc = (siblingDoc?.[field.name] ?? {}) as JsonObject\n        tabPreviousSiblingDoc = (previousDoc?.[field.name] ?? {}) as JsonObject\n      }\n\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: tabPreviousSiblingDoc,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getFieldPathsModified","getFieldPaths","traverseFields","promise","blockData","collection","context","data","doc","field","fieldIndex","global","operation","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","previousDoc","previousSiblingDoc","req","siblingData","siblingDoc","siblingFields","indexPath","path","schemaPath","index","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","hooks","afterChange","hook","hookedValue","originalDoc","previousValue","name","value","undefined","type","rows","Array","isArray","promises","forEach","row","rowIndex","push","fields","localized","Promise","all","blockTypeToMatch","blockType","block","payload","blocks","blockReferences","find","curBlock","slug","editor","Error","length","tabSiblingData","tabSiblingDoc","tabPreviousSiblingDoc","isNamedTab","tabs","tab"],"mappings":"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"}