{"version":3,"sources":["../../src/fields/validations.ts"],"sourcesContent":["import Ajv from 'ajv'\nimport ObjectIdImport from 'bson-objectid'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nimport type { TFunction } from '@payloadcms/translations'\nimport type { JSONSchema4 } from 'json-schema'\n\nimport type { RichTextAdapter } from '../admin/types.js'\nimport type { CollectionSlug } from '../index.js'\nimport type { Where } from '../types/index.js'\nimport type {\n  ArrayField,\n  BlocksField,\n  CheckboxField,\n  CodeField,\n  DateField,\n  EmailField,\n  JSONField,\n  NumberField,\n  PointField,\n  RadioField,\n  RelationshipField,\n  RelationshipValue,\n  RelationshipValueMany,\n  RelationshipValueSingle,\n  RichTextField,\n  SelectField,\n  TextareaField,\n  TextField,\n  UploadField,\n  Validate,\n  ValueWithRelation,\n} from './config/types.js'\n\nimport { isNumber } from '../utilities/isNumber.js'\nimport { isValidID } from '../utilities/isValidID.js'\n\nexport type TextFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport type TextFieldManyValidation = Validate<string[], unknown, unknown, TextField>\n\nexport type TextFieldSingleValidation = Validate<string, unknown, unknown, TextField>\n\nexport const text: TextFieldValidation = (\n  value,\n  {\n    hasMany,\n    maxLength: fieldMaxLength,\n    maxRows,\n    minLength,\n    minRows,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength!: number\n\n  if (!required) {\n    if (value === undefined || value === null) {\n      return true\n    }\n  }\n\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  const stringsToValidate: string[] = Array.isArray(value) ? value : [value!]\n\n  for (const stringValue of stringsToValidate) {\n    const length = stringValue?.length || 0\n\n    if (typeof maxLength === 'number' && length > maxLength) {\n      return t('validation:shorterThanMax', { label: t('general:value'), maxLength, stringValue })\n    }\n\n    if (typeof minLength === 'number' && length < minLength) {\n      return t('validation:longerThanMin', { label: t('general:value'), minLength, stringValue })\n    }\n  }\n\n  if (required) {\n    if (!(typeof value === 'string' || Array.isArray(value)) || value?.length === 0) {\n      return t('validation:required')\n    }\n  }\n\n  return true\n}\n\nexport type PasswordFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport const password: PasswordFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength = 3,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength!: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type ConfirmPasswordFieldValidation = Validate<\n  string,\n  unknown,\n  { password: string },\n  TextField\n>\n\nexport const confirmPassword: ConfirmPasswordFieldValidation = (\n  value,\n  { req: { t }, required, siblingData },\n) => {\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (value && value !== siblingData.password) {\n    return t('fields:passwordsDoNotMatch')\n  }\n\n  return true\n}\n\nexport type EmailFieldValidation = Validate<string, unknown, { username?: string }, EmailField>\n\nexport const email: EmailFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { collections, config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  if (collectionSlug) {\n    const collection =\n      collections?.[collectionSlug]?.config ??\n      config.collections.find(({ slug }) => slug === collectionSlug)! // If this is run on the client, `collections` will be undefined, but `config.collections` will be available\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.username) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  /**\n   * Disallows emails with double quotes (e.g., \"user\"@example.com, user@\"example.com\", \"user@example.com\")\n   * Rejects spaces anywhere in the email (e.g., user @example.com, user@ example.com, user name@example.com)\n   * Prevents consecutive dots in the local or domain part (e.g., user..name@example.com, user@example..com)\n   * Disallows domains that start or end with a hyphen (e.g., user@-example.com, user@example-.com)\n   * Allows standard email formats (e.g., user@example.com, user.name+alias@example.co.uk, user-name@example.org)\n   * Allows domains with consecutive hyphens as long as they are not leading/trailing (e.g., user@ex--ample.com)\n   * Supports multiple subdomains (e.g., user@sub.domain.example.com)\n   */\n  const emailRegex =\n    /^(?!.*\\.\\.)[\\w!#$%&'*+/=?^`{|}~-](?:[\\w!#$%&'*+/=?^`{|}~.-]*[\\w!#$%&'*+/=?^`{|}~-])?@[a-z0-9](?:[a-z0-9-]*[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]*[a-z0-9])?)*\\.[a-z]{2,}$/i\n\n  if ((value && !emailRegex.test(value)) || (!value && required)) {\n    return t('validation:emailAddress')\n  }\n\n  return true\n}\n\nexport type UsernameFieldValidation = Validate<string, unknown, { email?: string }, TextField>\n\nexport const username: UsernameFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { collections, config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  let maxLength!: number\n\n  if (collectionSlug) {\n    const collection =\n      collections?.[collectionSlug]?.config ??\n      config.collections.find(({ slug }) => slug === collectionSlug)! // If this is run on the client, `collections` will be undefined, but `config.collections` will be available\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.email) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (!value && required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type TextareaFieldValidation = Validate<string, unknown, unknown, TextareaField>\n\nexport const textarea: TextareaFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength!: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type CodeFieldValidation = Validate<string, unknown, unknown, CodeField>\n\nexport const code: CodeFieldValidation = (value, { req: { t }, required }) => {\n  if (required && value === undefined) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type JSONFieldValidation = Validate<\n  string,\n  unknown,\n  unknown,\n  { jsonError?: string } & JSONField\n>\n\nexport const json: JSONFieldValidation = (\n  value,\n  { jsonError, jsonSchema, req: { t }, required },\n) => {\n  const isNotEmpty = (value: null | string | undefined) => {\n    if (value === undefined || value === null) {\n      return false\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false\n    }\n\n    if (typeof value === 'object' && Object.keys(value).length === 0) {\n      return false\n    }\n\n    return true\n  }\n\n  const fetchSchema = ({ schema, uri }: { schema: JSONSchema4; uri: string }) => {\n    if (uri && schema) {\n      return schema\n    }\n    return fetch(uri)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok')\n        }\n        return response.json()\n      })\n      .then((_json) => {\n        const json = _json as {\n          id: string\n        }\n        const jsonSchemaSanitizations = {\n          id: undefined,\n          $id: json.id,\n          $schema: 'http://json-schema.org/draft-07/schema#',\n        }\n\n        return Object.assign(json, jsonSchemaSanitizations)\n      })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (jsonError !== undefined) {\n    return t('validation:invalidInput')\n  }\n\n  if (jsonSchema && isNotEmpty(value)) {\n    try {\n      jsonSchema.schema = fetchSchema(jsonSchema)\n      const { schema } = jsonSchema\n      // @ts-expect-error missing types\n      const ajv = new Ajv()\n\n      if (!ajv.validate(schema, value)) {\n        return ajv.errorsText()\n      }\n    } catch (error) {\n      return error instanceof Error ? error.message : 'Unknown error'\n    }\n  }\n  return true\n}\n\nexport type CheckboxFieldValidation = Validate<boolean, unknown, unknown, CheckboxField>\n\nexport const checkbox: CheckboxFieldValidation = (value, { req: { t }, required }) => {\n  if ((value && typeof value !== 'boolean') || (required && typeof value !== 'boolean')) {\n    return t('validation:trueOrFalse')\n  }\n\n  return true\n}\n\nexport type DateFieldValidation = Validate<Date, unknown, unknown, DateField>\n\nexport const date: DateFieldValidation = (\n  value,\n  { name, req: { t }, required, siblingData, timezone },\n) => {\n  const validDate = value && !isNaN(Date.parse(value.toString()))\n\n  // We need to also check for the timezone data based on this field's config\n  // We cannot do this inside the timezone field validation as it's visually hidden\n  const hasRequiredTimezone = timezone && required\n  const selectedTimezone: string = siblingData?.[`${name}_tz` as keyof typeof siblingData]\n  // Always resolve to true if the field is not required, as timezone may be optional too then\n  const validTimezone = hasRequiredTimezone ? Boolean(selectedTimezone) : true\n\n  if (validDate && validTimezone) {\n    return true\n  }\n\n  if (validDate && !validTimezone) {\n    return t('validation:timezoneRequired')\n  }\n\n  if (value) {\n    return t('validation:notValidDate', { value })\n  }\n\n  if (required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RichTextFieldValidation = Validate<object, unknown, unknown, RichTextField>\n\nexport const richText: RichTextFieldValidation = async (value, options) => {\n  if (!options?.editor) {\n    throw new Error('richText field has no editor property.')\n  }\n  if (typeof options?.editor === 'function') {\n    throw new Error('Attempted to access unsanitized rich text editor.')\n  }\n\n  const editor: RichTextAdapter = options?.editor\n\n  return editor.validate(value, options)\n}\n\nconst validateArrayLength = (\n  value: unknown,\n  options: {\n    maxRows?: number\n    minRows?: number\n    required?: boolean\n    t: TFunction\n  },\n) => {\n  const { maxRows, minRows, required, t } = options\n\n  const arrayLength = Array.isArray(value) ? value.length : (value as number) || 0\n\n  if (!required && arrayLength === 0) {\n    return true\n  }\n\n  if (minRows && arrayLength < minRows) {\n    return t('validation:requiresAtLeast', { count: minRows, label: t('general:rows') })\n  }\n\n  if (maxRows && arrayLength > maxRows) {\n    return t('validation:requiresNoMoreThan', { count: maxRows, label: t('general:rows') })\n  }\n\n  if (required && !arrayLength) {\n    return t('validation:requiresAtLeast', { count: 1, label: t('general:row') })\n  }\n\n  return true\n}\n\nexport type NumberFieldValidation = Validate<number | number[], unknown, unknown, NumberField>\n\nexport type NumberFieldManyValidation = Validate<number[], unknown, unknown, NumberField>\n\nexport type NumberFieldSingleValidation = Validate<number, unknown, unknown, NumberField>\n\nexport const number: NumberFieldValidation = (\n  value,\n  { hasMany, max, maxRows, min, minRows, req: { t }, required },\n) => {\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (!value && !isNumber(value)) {\n    // if no value is present, validate based on required\n    if (required) {\n      return t('validation:required')\n    }\n    if (!required) {\n      return true\n    }\n  }\n\n  const numbersToValidate: number[] = Array.isArray(value) ? value : [value!]\n\n  for (const number of numbersToValidate) {\n    if (!isNumber(number)) {\n      return t('validation:enterNumber')\n    }\n\n    const numberValue = parseFloat(number as unknown as string)\n\n    if (typeof max === 'number' && numberValue > max) {\n      return t('validation:greaterThanMax', { label: t('general:value'), max, value })\n    }\n\n    if (typeof min === 'number' && numberValue < min) {\n      return t('validation:lessThanMin', { label: t('general:value'), min, value })\n    }\n  }\n\n  return true\n}\n\nexport type ArrayFieldValidation = Validate<unknown[], unknown, unknown, ArrayField>\n\nexport const array: ArrayFieldValidation = (value, { maxRows, minRows, req: { t }, required }) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nexport type BlocksFieldValidation = Validate<unknown, unknown, unknown, BlocksField>\n\n/**\n * This function validates the blocks in a blocks field against the provided filterOptions.\n * It will return a list of all block slugs found in the value, the allowed block slugs (if any),\n * and a list of invalid block slugs that are used despite being disallowed.\n *\n * @internal - this may break or be removed at any time\n */\nexport async function validateBlocksFilterOptions({\n  id,\n  data,\n  filterOptions,\n  req,\n  siblingData,\n  value,\n}: { value: Parameters<BlocksFieldValidation>[0] } & Pick<\n  Parameters<BlocksFieldValidation>[1],\n  'data' | 'filterOptions' | 'id' | 'req' | 'siblingData'\n>): Promise<{\n  /**\n   * All block slugs found in the value of the blocks field\n   */\n  allBlockSlugs: string[]\n  /**\n   * All block slugs that are allowed. If undefined, all blocks are allowed.\n   */\n  allowedBlockSlugs: string[] | undefined\n  /**\n   * A list of block slugs that are used despite being disallowed. If undefined, field passed validation.\n   */\n  invalidBlockSlugs: string[] | undefined\n}> {\n  const allBlockSlugs = Array.isArray(value)\n    ? (value as Array<{ blockType?: string }>)\n        .map((b) => b.blockType)\n        .filter((s): s is string => Boolean(s))\n    : []\n\n  // if undefined => all blocks allowed\n  let allowedBlockSlugs: string[] | undefined = undefined\n\n  if (typeof filterOptions === 'function') {\n    const result = await filterOptions({\n      id: id!, // original code asserted presence\n      data,\n      req,\n      siblingData,\n      user: req.user,\n    })\n    if (result !== true && Array.isArray(result)) {\n      allowedBlockSlugs = result\n    }\n  } else if (Array.isArray(filterOptions)) {\n    allowedBlockSlugs = filterOptions\n  }\n\n  const invalidBlockSlugs: string[] = []\n  if (allowedBlockSlugs) {\n    for (const blockSlug of allBlockSlugs) {\n      if (!allowedBlockSlugs.includes(blockSlug)) {\n        invalidBlockSlugs.push(blockSlug)\n      }\n    }\n  }\n\n  return {\n    allBlockSlugs,\n    allowedBlockSlugs,\n    invalidBlockSlugs,\n  }\n}\nexport const blocks: BlocksFieldValidation = async (\n  value,\n  { id, data, filterOptions, maxRows, minRows, req: { t }, req, required, siblingData },\n) => {\n  const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n  if (typeof lengthValidationResult === 'string') {\n    return lengthValidationResult\n  }\n\n  if (filterOptions) {\n    const { invalidBlockSlugs } = await validateBlocksFilterOptions({\n      id,\n      data,\n      filterOptions,\n      req,\n      siblingData,\n      value,\n    })\n    if (invalidBlockSlugs?.length) {\n      return t('validation:invalidBlocks', { blocks: invalidBlockSlugs.join(', ') })\n    }\n  }\n\n  return true\n}\n\nconst validateFilterOptions: Validate<\n  unknown,\n  unknown,\n  unknown,\n  RelationshipField | UploadField\n> = async (\n  value,\n  { id, blockData, data, filterOptions, relationTo, req, req: { t, user }, siblingData },\n) => {\n  if (typeof filterOptions !== 'undefined' && value) {\n    const options: {\n      [collection: string]: (number | string)[]\n    } = {}\n\n    const falseCollections: CollectionSlug[] = []\n    const collections = !Array.isArray(relationTo) ? [relationTo] : relationTo\n    const values = Array.isArray(value) ? value : [value]\n\n    for (const collection of collections) {\n      try {\n        let optionFilter =\n          typeof filterOptions === 'function'\n            ? await filterOptions({\n                id: id!,\n                blockData,\n                data,\n                relationTo: collection,\n                req,\n                siblingData,\n                user,\n              })\n            : filterOptions\n\n        if (optionFilter === true) {\n          optionFilter = null\n        }\n\n        const valueIDs: (number | string)[] = []\n\n        values.forEach((val) => {\n          if (typeof val === 'object') {\n            if (val?.value) {\n              valueIDs.push(val.value)\n            } else if (ObjectId.isValid(val)) {\n              valueIDs.push(new ObjectId(val).toHexString())\n            }\n          }\n\n          if (typeof val === 'string' || typeof val === 'number') {\n            valueIDs.push(val)\n          }\n        })\n\n        if (valueIDs.length > 0) {\n          const findWhere: Where = {\n            and: [{ id: { in: valueIDs } }],\n          }\n\n          // @ts-expect-error - I don't understand why optionFilter is inferred as `false | Where | null` instead of `boolean | Where | null`\n          if (optionFilter && optionFilter !== true) {\n            findWhere.and?.push(optionFilter)\n          }\n\n          if (optionFilter === false) {\n            falseCollections.push(collection)\n          }\n\n          const result = await req.payloadDataLoader.find({\n            collection,\n            depth: 0,\n            limit: 0,\n            pagination: false,\n            req,\n            where: findWhere,\n          })\n\n          options[collection] = result.docs.map((doc) => doc.id)\n        } else {\n          options[collection] = []\n        }\n      } catch (err) {\n        req.payload.logger.error({\n          err,\n          msg: `Error validating filter options for collection ${collection}`,\n        })\n        options[collection] = []\n      }\n    }\n\n    const invalidRelationships = values.filter((val) => {\n      let collection: string\n      let requestedID: number | string\n\n      if (typeof relationTo === 'string') {\n        collection = relationTo\n\n        if (typeof val === 'string' || typeof val === 'number') {\n          requestedID = val\n        }\n\n        if (typeof val === 'object' && ObjectId.isValid(val)) {\n          requestedID = new ObjectId(val).toHexString()\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collection = val.relationTo\n        requestedID = val.value\n      }\n\n      if (falseCollections.find((slug) => relationTo === slug)) {\n        return true\n      }\n\n      if (!options[collection!]) {\n        return true\n      }\n\n      return options[collection!]!.indexOf(requestedID!) === -1\n    })\n\n    if (invalidRelationships.length > 0) {\n      return invalidRelationships.reduce((err, invalid, i) => {\n        return `${err} ${JSON.stringify(invalid)}${\n          invalidRelationships.length === i + 1 ? ',' : ''\n        } `\n      }, t('validation:invalidSelections')) as string\n    }\n\n    return true\n  }\n\n  return true\n}\n\nexport type UploadFieldValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport type UploadFieldManyValidation = Validate<unknown[], unknown, unknown, UploadField>\n\nexport type UploadFieldSingleValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport const upload: UploadFieldValidation = async (value, options) => {\n  const {\n    event,\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug!]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  if (event === 'onChange') {\n    return true\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type RelationshipFieldValidation = Validate<\n  RelationshipValue,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldManyValidation = Validate<\n  RelationshipValueMany,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldSingleValidation = Validate<\n  RelationshipValueSingle,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport const relationship: RelationshipFieldValidation = async (value, options) => {\n  const {\n    event,\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID: number | string | undefined | ValueWithRelation\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug!]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID as number | string, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  if (event === 'onChange') {\n    return true\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type SelectFieldValidation = Validate<string | string[], unknown, unknown, SelectField>\n\nexport type SelectFieldManyValidation = Validate<string[], unknown, unknown, SelectField>\n\nexport type SelectFieldSingleValidation = Validate<string, unknown, unknown, SelectField>\n\nexport const select: SelectFieldValidation = (\n  value,\n  { data, filterOptions, hasMany, options, req, req: { t }, required, siblingData },\n) => {\n  const filteredOptions =\n    typeof filterOptions === 'function'\n      ? filterOptions({\n          data,\n          options,\n          req,\n          siblingData,\n        })\n      : options\n\n  if (\n    Array.isArray(value) &&\n    value.some(\n      (input) =>\n        !filteredOptions.some(\n          (option) => option === input || (typeof option !== 'string' && option?.value === input),\n        ),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    typeof value === 'string' &&\n    !filteredOptions.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    required &&\n    (typeof value === 'undefined' ||\n      value === null ||\n      (hasMany && Array.isArray(value) && (value as [])?.length === 0))\n  ) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RadioFieldValidation = Validate<unknown, unknown, unknown, RadioField>\n\nexport const radio: RadioFieldValidation = (value, { options, req: { t }, required }) => {\n  if (value) {\n    const valueMatchesOption = options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n    return valueMatchesOption || t('validation:invalidSelection')\n  }\n\n  return required ? t('validation:required') : true\n}\n\nexport type PointFieldValidation = Validate<\n  [number | string, number | string],\n  unknown,\n  unknown,\n  PointField\n>\n\nexport const point: PointFieldValidation = (value = ['', ''], { req: { t }, required }) => {\n  if (value === null) {\n    if (required) {\n      return t('validation:required')\n    }\n\n    return true\n  }\n\n  const lng = parseFloat(String(value[0]))\n  const lat = parseFloat(String(value[1]))\n  if (\n    required &&\n    ((value[0] && value[1] && typeof lng !== 'number' && typeof lat !== 'number') ||\n      Number.isNaN(lng) ||\n      Number.isNaN(lat) ||\n      (Array.isArray(value) && value.length !== 2))\n  ) {\n    return t('validation:requiresTwoNumbers')\n  }\n\n  if ((value[1] && Number.isNaN(lng)) || (value[0] && Number.isNaN(lat))) {\n    return t('validation:invalidInput')\n  }\n\n  // Validate longitude bounds (-180 to 180)\n  if (value[0] && !Number.isNaN(lng) && (lng < -180 || lng > 180)) {\n    return t('validation:longitudeOutOfBounds')\n  }\n\n  // Validate latitude bounds (-90 to 90)\n  if (value[1] && !Number.isNaN(lat) && (lat < -90 || lat > 90)) {\n    return t('validation:latitudeOutOfBounds')\n  }\n\n  return true\n}\n\n/**\n * Built-in field validations used by Payload\n *\n * These can be re-used in custom validations\n */\nexport const validations = {\n  array,\n  blocks,\n  checkbox,\n  code,\n  confirmPassword,\n  date,\n  email,\n  json,\n  number,\n  password,\n  point,\n  radio,\n  relationship,\n  richText,\n  select,\n  text,\n  textarea,\n  upload,\n}\n"],"names":["Ajv","ObjectIdImport","ObjectId","default","isNumber","isValidID","text","value","hasMany","maxLength","fieldMaxLength","maxRows","minLength","minRows","req","payload","config","t","required","undefined","lengthValidationResult","validateArrayLength","defaultMaxTextLength","stringsToValidate","Array","isArray","stringValue","length","label","password","confirmPassword","siblingData","email","collectionSlug","collections","collection","find","slug","auth","loginWithUsername","requireUsername","requireEmail","username","emailRegex","test","textarea","code","json","jsonError","jsonSchema","isNotEmpty","Object","keys","fetchSchema","schema","uri","fetch","then","response","ok","Error","_json","jsonSchemaSanitizations","id","$id","$schema","assign","ajv","validate","errorsText","error","message","checkbox","date","name","timezone","validDate","isNaN","Date","parse","toString","hasRequiredTimezone","selectedTimezone","validTimezone","Boolean","richText","options","editor","arrayLength","count","number","max","min","numbersToValidate","numberValue","parseFloat","array","validateBlocksFilterOptions","data","filterOptions","allBlockSlugs","map","b","blockType","filter","s","allowedBlockSlugs","result","user","invalidBlockSlugs","blockSlug","includes","push","blocks","join","validateFilterOptions","blockData","relationTo","falseCollections","values","optionFilter","valueIDs","forEach","val","isValid","toHexString","findWhere","and","in","payloadDataLoader","depth","limit","pagination","where","docs","doc","err","logger","msg","invalidRelationships","requestedID","indexOf","reduce","invalid","i","JSON","stringify","upload","event","idType","customIDType","db","defaultIDType","relationship","select","filteredOptions","some","input","option","radio","valueMatchesOption","point","lng","String","lat","Number","validations"],"mappings":"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"}