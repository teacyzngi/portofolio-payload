{"version":3,"sources":["../../../src/fields/config/sanitizeJoinField.ts"],"sourcesContent":["import type { SanitizedJoin, SanitizedJoins } from '../../collections/config/types.js'\nimport type { Config } from '../../config/types.js'\nimport type { FlattenedJoinField, JoinField } from './types.js'\n\nimport { APIError } from '../../errors/index.js'\nimport { InvalidFieldJoin } from '../../errors/InvalidFieldJoin.js'\nimport { flattenAllFields } from '../../utilities/flattenAllFields.js'\nimport { getFieldByPath } from '../../utilities/getFieldByPath.js'\n\nexport const sanitizeJoinField = ({\n  config,\n  field,\n  joinPath,\n  joins,\n  parentIsLocalized,\n  polymorphicJoins,\n  validateOnly,\n}: {\n  config: Config\n  field: FlattenedJoinField | JoinField\n  joinPath?: string\n  joins?: SanitizedJoins\n  parentIsLocalized: boolean\n  polymorphicJoins?: SanitizedJoin[]\n  validateOnly?: boolean\n}) => {\n  // the `joins` arg is not passed for globals or when recursing on fields that do not allow a join field\n  if (typeof joins === 'undefined') {\n    throw new APIError('Join fields cannot be added to arrays, blocks or globals.')\n  }\n  if (typeof field.maxDepth === 'undefined') {\n    field.maxDepth = 1\n  }\n  const join: SanitizedJoin = {\n    field,\n    joinPath: `${joinPath ? joinPath + '.' : ''}${field.name}`,\n    parentIsLocalized,\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    targetField: undefined,\n  }\n\n  if (Array.isArray(field.collection)) {\n    for (const collection of field.collection) {\n      const sanitizedField = {\n        ...field,\n        collection,\n      } as FlattenedJoinField\n\n      sanitizeJoinField({\n        config,\n        field: sanitizedField,\n        joinPath,\n        joins,\n        parentIsLocalized,\n        polymorphicJoins,\n        validateOnly: true,\n      })\n    }\n\n    if (Array.isArray(polymorphicJoins)) {\n      polymorphicJoins.push(join)\n    }\n\n    return\n  }\n\n  const joinCollection = config.collections?.find(\n    (collection) => collection.slug === field.collection,\n  )\n  if (!joinCollection) {\n    throw new InvalidFieldJoin(field)\n  }\n\n  const relationshipField = getFieldByPath({\n    fields: flattenAllFields({ cache: true, fields: joinCollection.fields }),\n    path: field.on,\n  })\n\n  if (\n    !relationshipField ||\n    (relationshipField.field.type !== 'relationship' && relationshipField.field.type !== 'upload')\n  ) {\n    throw new InvalidFieldJoin(join.field)\n  }\n\n  if (relationshipField.pathHasLocalized) {\n    join.getForeignPath = ({ locale }) => {\n      return relationshipField.localizedPath.replace('<locale>', locale!)\n    }\n  }\n\n  if (!relationshipField.field.index && !relationshipField.field.unique) {\n    relationshipField.field.index = true\n  }\n\n  if (validateOnly) {\n    return\n  }\n\n  join.targetField = relationshipField.field\n\n  // override the join field localized property to use whatever the relationship field has\n  // or if it's nested to a localized array / blocks / tabs / group\n  field.localized = relationshipField.field.localized\n  // override the join field hasMany property to use whatever the relationship field has\n  field.hasMany = relationshipField.field.hasMany\n\n  // @ts-expect-error converting JoinField to FlattenedJoinField to track targetField\n  field.targetField = join.targetField\n\n  if (!joins[field.collection]) {\n    joins[field.collection] = [join]\n  } else {\n    joins[field.collection]?.push(join)\n  }\n}\n"],"names":["APIError","InvalidFieldJoin","flattenAllFields","getFieldByPath","sanitizeJoinField","config","field","joinPath","joins","parentIsLocalized","polymorphicJoins","validateOnly","maxDepth","join","name","targetField","undefined","Array","isArray","collection","sanitizedField","push","joinCollection","collections","find","slug","relationshipField","fields","cache","path","on","type","pathHasLocalized","getForeignPath","locale","localizedPath","replace","index","unique","localized","hasMany"],"mappings":"AAIA,SAASA,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,gBAAgB,QAAQ,mCAAkC;AACnE,SAASC,gBAAgB,QAAQ,sCAAqC;AACtE,SAASC,cAAc,QAAQ,oCAAmC;AAElE,OAAO,MAAMC,oBAAoB,CAAC,EAChCC,MAAM,EACNC,KAAK,EACLC,QAAQ,EACRC,KAAK,EACLC,iBAAiB,EACjBC,gBAAgB,EAChBC,YAAY,EASb;IACC,uGAAuG;IACvG,IAAI,OAAOH,UAAU,aAAa;QAChC,MAAM,IAAIR,SAAS;IACrB;IACA,IAAI,OAAOM,MAAMM,QAAQ,KAAK,aAAa;QACzCN,MAAMM,QAAQ,GAAG;IACnB;IACA,MAAMC,OAAsB;QAC1BP;QACAC,UAAU,GAAGA,WAAWA,WAAW,MAAM,KAAKD,MAAMQ,IAAI,EAAE;QAC1DL;QACA,oFAAoF;QACpFM,aAAaC;IACf;IAEA,IAAIC,MAAMC,OAAO,CAACZ,MAAMa,UAAU,GAAG;QACnC,KAAK,MAAMA,cAAcb,MAAMa,UAAU,CAAE;YACzC,MAAMC,iBAAiB;gBACrB,GAAGd,KAAK;gBACRa;YACF;YAEAf,kBAAkB;gBAChBC;gBACAC,OAAOc;gBACPb;gBACAC;gBACAC;gBACAC;gBACAC,cAAc;YAChB;QACF;QAEA,IAAIM,MAAMC,OAAO,CAACR,mBAAmB;YACnCA,iBAAiBW,IAAI,CAACR;QACxB;QAEA;IACF;IAEA,MAAMS,iBAAiBjB,OAAOkB,WAAW,EAAEC,KACzC,CAACL,aAAeA,WAAWM,IAAI,KAAKnB,MAAMa,UAAU;IAEtD,IAAI,CAACG,gBAAgB;QACnB,MAAM,IAAIrB,iBAAiBK;IAC7B;IAEA,MAAMoB,oBAAoBvB,eAAe;QACvCwB,QAAQzB,iBAAiB;YAAE0B,OAAO;YAAMD,QAAQL,eAAeK,MAAM;QAAC;QACtEE,MAAMvB,MAAMwB,EAAE;IAChB;IAEA,IACE,CAACJ,qBACAA,kBAAkBpB,KAAK,CAACyB,IAAI,KAAK,kBAAkBL,kBAAkBpB,KAAK,CAACyB,IAAI,KAAK,UACrF;QACA,MAAM,IAAI9B,iBAAiBY,KAAKP,KAAK;IACvC;IAEA,IAAIoB,kBAAkBM,gBAAgB,EAAE;QACtCnB,KAAKoB,cAAc,GAAG,CAAC,EAAEC,MAAM,EAAE;YAC/B,OAAOR,kBAAkBS,aAAa,CAACC,OAAO,CAAC,YAAYF;QAC7D;IACF;IAEA,IAAI,CAACR,kBAAkBpB,KAAK,CAAC+B,KAAK,IAAI,CAACX,kBAAkBpB,KAAK,CAACgC,MAAM,EAAE;QACrEZ,kBAAkBpB,KAAK,CAAC+B,KAAK,GAAG;IAClC;IAEA,IAAI1B,cAAc;QAChB;IACF;IAEAE,KAAKE,WAAW,GAAGW,kBAAkBpB,KAAK;IAE1C,wFAAwF;IACxF,iEAAiE;IACjEA,MAAMiC,SAAS,GAAGb,kBAAkBpB,KAAK,CAACiC,SAAS;IACnD,sFAAsF;IACtFjC,MAAMkC,OAAO,GAAGd,kBAAkBpB,KAAK,CAACkC,OAAO;IAE/C,mFAAmF;IACnFlC,MAAMS,WAAW,GAAGF,KAAKE,WAAW;IAEpC,IAAI,CAACP,KAAK,CAACF,MAAMa,UAAU,CAAC,EAAE;QAC5BX,KAAK,CAACF,MAAMa,UAAU,CAAC,GAAG;YAACN;SAAK;IAClC,OAAO;QACLL,KAAK,CAACF,MAAMa,UAAU,CAAC,EAAEE,KAAKR;IAChC;AACF,EAAC"}