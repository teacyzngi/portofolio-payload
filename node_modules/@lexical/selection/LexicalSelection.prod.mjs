/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{$isTextNode as e,$getEditor as t,$isRootNode as n,$isTokenOrSegmented as o,$getCharacterOffsets as l,$isElementNode as r,$getNodeByKey as s,$getPreviousSelection as i,$createTextNode as c,$isRangeSelection as f,$getSelection as u,$caretRangeFromSelection as g,$createRangeSelection as a,INTERNAL_$isBlock as d,$setSelection as p,$isRootOrShadowRoot as h,$hasAncestor as y,$isLeafNode as m,$caretFromPoint as S,$isExtendableTextPointCaret as x,$extendCaretToRange as T,$isChildCaret as w,$isDecoratorNode as v}from"lexical";export{$cloneWithProperties,$selectAll}from"lexical";function N(e,...t){const n=new URL("https://lexical.dev/docs/error"),o=new URLSearchParams;o.append("code",e);for(const e of t)o.append("v",e);throw n.search=o.toString(),Error(`Minified Lexical error #${e}; visit ${n.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}const C=new Map;function P(e){let t=e;for(;null!=t;){if(t.nodeType===Node.TEXT_NODE)return t;t=t.firstChild}return null}function K(e){const t=e.parentNode;if(null==t)throw new Error("Should never happen");return[t,Array.from(t.childNodes).indexOf(e)]}function E(t,n,o,l,r){const s=n.getKey(),i=l.getKey(),c=document.createRange();let f=t.getElementByKey(s),u=t.getElementByKey(i),g=o,a=r;if(e(n)&&(f=P(f)),e(l)&&(u=P(u)),void 0===n||void 0===l||null===f||null===u)return null;"BR"===f.nodeName&&([f,g]=K(f)),"BR"===u.nodeName&&([u,a]=K(u));const d=f.firstChild;f===u&&null!=d&&"BR"===d.nodeName&&0===g&&0===a&&(a=1);try{c.setStart(f,g),c.setEnd(u,a)}catch(e){return null}return!c.collapsed||g===a&&s===i||(c.setStart(u,a),c.setEnd(f,g)),c}function k(e,t){const n=e.getRootElement();if(null===n)return[];const o=n.getBoundingClientRect(),l=getComputedStyle(n),r=parseFloat(l.paddingLeft)+parseFloat(l.paddingRight),s=Array.from(t.getClientRects());let i,c=s.length;s.sort(((e,t)=>{const n=e.top-t.top;return Math.abs(n)<=3?e.left-t.left:n}));for(let e=0;e<c;e++){const t=s[e],n=i&&i.top<=t.top&&i.top+i.height>t.top&&i.left+i.width>t.left,l=t.width+r===o.width;n||l?(s.splice(e--,1),c--):i=t}return s}function I(e){const t={};if(!e)return t;const n=e.split(";");for(const e of n)if(""!==e){const[n,o]=e.split(/:([^]+)/);n&&o&&(t[n.trim()]=o.trim())}return t}function B(e){let t=C.get(e);return void 0===t&&(t=I(e),C.set(e,t)),t}function F(e){let t="";for(const n in e)n&&(t+=`${n}: ${e[n]};`);return t}function b(e){const n=t().getElementByKey(e.getKey());if(null===n)return null;const o=n.ownerDocument.defaultView;return null===o?null:o.getComputedStyle(n)}function O(e){return b(n(e)?e:e.getParentOrThrow())}function R(e){const t=O(e);return null!==t&&"rtl"===t.direction}function z(e,t){const n=e.getStartEndPoints();if(t.isSelected(e)&&!o(t)&&null!==n){const[o,r]=n,s=e.isBackward(),i=o.getNode(),c=r.getNode(),f=t.is(i),u=t.is(c);if(f||u){const[n,o]=l(e),r=i.is(c),f=t.is(s?c:i),u=t.is(s?i:c);let g,a=0;if(r)a=n>o?o:n,g=n>o?n:o;else if(f){a=s?o:n,g=void 0}else if(u){a=0,g=s?n:o}t.__text=t.__text.slice(a,g)}}return t}function A(e){if("text"===e.type)return e.offset===e.getNode().getTextContentSize();const t=e.getNode();return r(t)||N(177),e.offset===t.getChildrenSize()}function M(t,o,l){let u=o.getNode(),g=l;if(r(u)){const e=u.getDescendantByIndex(o.offset);null!==e&&(u=e)}for(;g>0&&null!==u;){if(r(u)){const e=u.getLastDescendant();null!==e&&(u=e)}let l=u.getPreviousSibling(),a=0;if(null===l){let e=u.getParentOrThrow(),t=e.getPreviousSibling();for(;null===t;){if(e=e.getParent(),null===e){l=null;break}t=e.getPreviousSibling()}null!==e&&(a=e.isInline()?0:2,l=t)}let d=u.getTextContent();""===d&&r(u)&&!u.isInline()&&(d="\n\n");const p=d.length;if(!e(u)||g>=p){const e=u.getParent();u.remove(),null==e||0!==e.getChildrenSize()||n(e)||e.remove(),g-=p+a,u=l}else{const n=u.getKey(),l=t.getEditorState().read((()=>{const t=s(n);return e(t)&&t.isSimpleText()?t.getTextContent():null})),r=p-g,a=d.slice(0,r);if(null!==l&&l!==d){const e=i();let t=u;if(u.isSimpleText())u.setTextContent(l);else{const e=c(l);u.replace(e),t=e}if(f(e)&&e.isCollapsed()){const n=e.anchor.offset;t.select(n,n)}}else if(u.isSimpleText()){const e=o.key===n;let t=o.offset;t<g&&(t=p);const l=e?t-g:0,s=e?t:r;if(e&&0===l){const[e]=u.splitText(l,s);e.remove()}else{const[,e]=u.splitText(l,s);e.remove()}}else{const e=c(a);u.replace(e)}g=0}}}function L(e){const t=e.getStyle(),n=I(t);C.set(t,n)}function $(t,n){(f(t)?t.isCollapsed():e(t)||r(t))||N(280);const o=B(f(t)?t.style:e(t)?t.getStyle():t.getTextStyle()),l=Object.entries(n).reduce(((e,[n,l])=>("function"==typeof l?e[n]=l(o[n],t):null===l?delete e[n]:e[n]=l,e)),{...o}),s=F(l);f(t)||e(t)?t.setStyle(s):t.setTextStyle(s),C.set(s,l)}function _(e,t){if(f(e)&&e.isCollapsed()){$(e,t);const n=e.anchor.getNode();r(n)&&n.isEmpty()&&$(n,t)}D((e=>{$(e,t)}))}function D(t){const n=u();if(!n)return;const l=new Map;if(f(n))for(const e of g(n).getTextSlices())e&&l.set(e.caret.origin.getKey(),e.getSliceIndices());const r=n.getNodes();for(const n of r){if(!e(n)||!n.canHaveFormat())continue;const[r,i]=(s=n,l.get(s.getKey())||[0,s.getTextContentSize()]);if(i!==r)if(o(n)||0===r&&i===n.getTextContentSize())t(n);else{t(n.splitText(r,i)[0===r?0:1])}}var s;f(n)&&"text"===n.anchor.type&&"text"===n.focus.type&&n.anchor.key===n.focus.key&&U(n)}function U(e){if(e.isBackward()){const{anchor:t,focus:n}=e,{key:o,offset:l,type:r}=t;t.set(n.key,n.offset,n.type),n.set(o,l,r)}}function j(e,t){const n=e.getFormatType(),o=e.getIndent();n!==t.getFormatType()&&t.setFormat(n),o!==t.getIndent()&&t.setIndent(o)}function H(e,t,n=j){if(null===e)return;const o=e.getStartEndPoints(),l=new Map;let s=null;if(o){const[e,t]=o;s=a(),s.anchor.set(e.key,e.offset,e.type),s.focus.set(t.key,t.offset,t.type);const n=oe(e.getNode(),d),i=oe(t.getNode(),d);r(n)&&l.set(n.getKey(),n),r(i)&&l.set(i.getKey(),i)}for(const t of e.getNodes())if(r(t)&&d(t))l.set(t.getKey(),t);else if(null===o){const e=oe(t,d);r(e)&&l.set(e.getKey(),e)}for(const[e,o]of l){const l=t();n(o,l),o.replace(l,!0),s&&(e===s.anchor.key&&s.anchor.set(l.getKey(),s.anchor.offset,s.anchor.type),e===s.focus.key&&s.focus.set(l.getKey(),s.focus.offset,s.focus.type))}s&&e.is(u())&&p(s)}function V(e){return e.getNode().isAttached()}function W(e){let t=e;for(;null!==t&&!h(t);){const e=t.getLatest(),n=t.getParent();0===e.getChildrenSize()&&t.remove(!0),t=n}}function X(e,t,n=null){const o=e.getStartEndPoints(),l=o?o[0]:null,r=e.getNodes(),s=r.length;if(null!==l&&(0===s||1===s&&"element"===l.type&&0===l.getNode().getChildrenSize())){const e="text"===l.type?l.getNode().getParentOrThrow():l.getNode(),o=e.getChildren();let r=t();return r.setFormat(e.getFormatType()),r.setIndent(e.getIndent()),o.forEach((e=>r.append(e))),n&&(r=n.append(r)),void e.replace(r)}let i=null,c=[];for(let o=0;o<s;o++){const l=r[o];h(l)?(q(e,c,c.length,t,n),c=[],i=l):null===i||null!==i&&y(l,i)?c.push(l):(q(e,c,c.length,t,n),c=[l])}q(e,c,c.length,t,n)}function q(e,t,n,o,l=null){if(0===t.length)return;const s=t[0],c=new Map,u=[];let g=r(s)?s:s.getParentOrThrow();g.isInline()&&(g=g.getParentOrThrow());let a=!1;for(;null!==g;){const e=g.getPreviousSibling();if(null!==e){g=e,a=!0;break}if(g=g.getParentOrThrow(),h(g))break}const d=new Set;for(let e=0;e<n;e++){const n=t[e];r(n)&&0===n.getChildrenSize()&&d.add(n.getKey())}const y=new Set;for(let e=0;e<n;e++){const n=t[e];let l=n.getParent();if(null!==l&&l.isInline()&&(l=l.getParent()),null!==l&&m(n)&&!y.has(n.getKey())){const e=l.getKey();if(void 0===c.get(e)){const t=o();t.setFormat(l.getFormatType()),t.setIndent(l.getIndent()),u.push(t),c.set(e,t),l.getChildren().forEach((e=>{t.append(e),y.add(e.getKey()),r(e)&&e.getChildrenKeys().forEach((e=>y.add(e)))})),W(l)}}else if(d.has(n.getKey())){r(n)||N(179);const e=o();e.setFormat(n.getFormatType()),e.setIndent(n.getIndent()),u.push(e),n.remove(!0)}}if(null!==l)for(let e=0;e<u.length;e++){const t=u[e];l.append(t)}let S=null;if(h(g))if(a)if(null!==l)g.insertAfter(l);else for(let e=u.length-1;e>=0;e--){const t=u[e];g.insertAfter(t)}else{const e=g.getFirstChild();if(r(e)&&(g=e),null===e)if(l)g.append(l);else for(let e=0;e<u.length;e++){const t=u[e];g.append(t),S=t}else if(null!==l)e.insertBefore(l);else for(let t=0;t<u.length;t++){const n=u[t];e.insertBefore(n),S=n}}else if(l)g.insertAfter(l);else for(let e=u.length-1;e>=0;e--){const t=u[e];g.insertAfter(t),S=t}const x=i();f(x)&&V(x.anchor)&&V(x.focus)?p(x.clone()):null!==S?S.selectEnd():e.dirty=!0}function G(e){const t=J(e);return null!==t&&"vertical-rl"===t.writingMode}function J(e){const t=e.anchor.getNode();return r(t)?b(t):O(t)}function Q(e,t){let n=G(e)?!t:t;Z(e)&&(n=!n);const o=S(e.focus,n?"previous":"next");if(x(o))return!1;for(const e of T(o)){if(w(e))return!e.origin.isInline();if(!r(e.origin)){if(v(e.origin))return!0;break}}return!1}function Y(e,t,n,o){e.modify(t?"extend":"move",n,o)}function Z(e){const t=J(e);return null!==t&&"rtl"===t.direction}function ee(e,t,n){const o=Z(e);let l;l=G(e)||o?!n:n,Y(e,t,l,"character")}function te(e,t,n){const o=B(e.getStyle());return null!==o&&o[t]||n}function ne(t,n,o=""){let l=null;const r=t.getNodes(),s=t.anchor,i=t.focus,c=t.isBackward(),u=c?i.offset:s.offset,g=c?i.getNode():s.getNode();if(f(t)&&t.isCollapsed()&&""!==t.style){const e=B(t.style);if(null!==e&&n in e)return e[n]}for(let t=0;t<r.length;t++){const s=r[t];if((0===t||0!==u||!s.is(g))&&e(s)){const e=te(s,n,o);if(null===l)l=e;else if(l!==e){l="";break}}}return null===l?o:l}function oe(e,t){let n=e;for(;null!==n&&null!==n.getParent()&&!t(n);)n=n.getParentOrThrow();return t(n)?n:null}const le=M;export{L as $addNodeStyle,j as $copyBlockFormatIndent,U as $ensureForwardRangeSelection,D as $forEachSelectedTextNode,b as $getComputedStyleForElement,O as $getComputedStyleForParent,ne as $getSelectionStyleValueForProperty,A as $isAtNodeEnd,Z as $isParentElementRTL,R as $isParentRTL,Y as $moveCaretSelection,ee as $moveCharacter,_ as $patchStyleText,H as $setBlocksType,Q as $shouldOverrideDefaultCharacterSelection,z as $sliceSelectedTextNodeContent,M as $trimTextContentFromAnchor,X as $wrapNodes,E as createDOMRange,k as createRectsFromDOMRange,F as getCSSFromStyleObject,B as getStyleObjectFromCSS,le as trimTextContentFromAnchor};
