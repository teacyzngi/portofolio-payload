{"version":3,"sources":["../../src/upsertRow/shouldUseOptimizedUpsertRow.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\n/**\n * Checks whether we should use the upsertRow function for the passed data and otherwise use a simple SQL SET call.\n * We need to use upsertRow only when the data has arrays, blocks, hasMany select/text/number, localized fields, complex relationships.\n */\nexport const shouldUseOptimizedUpsertRow = ({\n  data,\n  fields,\n}: {\n  data: Record<string, unknown>\n  fields: FlattenedField[]\n}) => {\n  let fieldsMatched = false\n\n  for (const key in data) {\n    const value = data[key]\n    const field = fields.find((each) => each.name === key)\n\n    if (!field) {\n      continue\n    }\n\n    fieldsMatched = true\n\n    if (\n      field.type === 'blocks' ||\n      ((field.type === 'text' ||\n        field.type === 'relationship' ||\n        field.type === 'upload' ||\n        field.type === 'select' ||\n        field.type === 'number') &&\n        field.hasMany) ||\n      ((field.type === 'relationship' || field.type === 'upload') &&\n        Array.isArray(field.relationTo)) ||\n      field.localized\n    ) {\n      return false\n    }\n\n    if (field.type === 'array') {\n      if (typeof value === 'object' && '$push' in value && value.$push) {\n        return shouldUseOptimizedUpsertRow({\n          // Only check first row - this function cares about field definitions. Each array row will have the same field definitions.\n          data: Array.isArray(value.$push) ? value.$push?.[0] : value.$push,\n          fields: field.flattenedFields,\n        })\n      }\n      return false\n    }\n\n    // Handle relationship $push and $remove operations\n    if ((field.type === 'relationship' || field.type === 'upload') && field.hasMany) {\n      if (typeof value === 'object' && ('$push' in value || '$remove' in value)) {\n        return false // Use full upsertRow for relationship operations\n      }\n    }\n\n    if (\n      (field.type === 'group' || field.type === 'tab') &&\n      value &&\n      typeof value === 'object' &&\n      !shouldUseOptimizedUpsertRow({\n        data: value as Record<string, unknown>,\n        fields: field.flattenedFields,\n      })\n    ) {\n      return false\n    }\n  }\n\n  // Handle dot-notation paths when no fields matched\n  if (!fieldsMatched) {\n    for (const key in data) {\n      if (key.includes('.')) {\n        // Split on first dot only\n        const firstDotIndex = key.indexOf('.')\n        const fieldName = key.substring(0, firstDotIndex)\n        const remainingPath = key.substring(firstDotIndex + 1)\n\n        const nestedData = { [fieldName]: { [remainingPath]: data[key] } }\n        return shouldUseOptimizedUpsertRow({\n          data: nestedData,\n          fields,\n        })\n      }\n    }\n  }\n\n  return true\n}\n"],"names":["shouldUseOptimizedUpsertRow","data","fields","fieldsMatched","key","value","field","find","each","name","type","hasMany","Array","isArray","relationTo","localized","$push","flattenedFields","includes","firstDotIndex","indexOf","fieldName","substring","remainingPath","nestedData"],"mappings":"AAEA;;;CAGC,GACD,OAAO,MAAMA,8BAA8B,CAAC,EAC1CC,IAAI,EACJC,MAAM,EAIP;IACC,IAAIC,gBAAgB;IAEpB,IAAK,MAAMC,OAAOH,KAAM;QACtB,MAAMI,QAAQJ,IAAI,CAACG,IAAI;QACvB,MAAME,QAAQJ,OAAOK,IAAI,CAAC,CAACC,OAASA,KAAKC,IAAI,KAAKL;QAElD,IAAI,CAACE,OAAO;YACV;QACF;QAEAH,gBAAgB;QAEhB,IACEG,MAAMI,IAAI,KAAK,YACd,AAACJ,CAAAA,MAAMI,IAAI,KAAK,UACfJ,MAAMI,IAAI,KAAK,kBACfJ,MAAMI,IAAI,KAAK,YACfJ,MAAMI,IAAI,KAAK,YACfJ,MAAMI,IAAI,KAAK,QAAO,KACtBJ,MAAMK,OAAO,IACd,AAACL,CAAAA,MAAMI,IAAI,KAAK,kBAAkBJ,MAAMI,IAAI,KAAK,QAAO,KACvDE,MAAMC,OAAO,CAACP,MAAMQ,UAAU,KAChCR,MAAMS,SAAS,EACf;YACA,OAAO;QACT;QAEA,IAAIT,MAAMI,IAAI,KAAK,SAAS;YAC1B,IAAI,OAAOL,UAAU,YAAY,WAAWA,SAASA,MAAMW,KAAK,EAAE;gBAChE,OAAOhB,4BAA4B;oBACjC,2HAA2H;oBAC3HC,MAAMW,MAAMC,OAAO,CAACR,MAAMW,KAAK,IAAIX,MAAMW,KAAK,EAAE,CAAC,EAAE,GAAGX,MAAMW,KAAK;oBACjEd,QAAQI,MAAMW,eAAe;gBAC/B;YACF;YACA,OAAO;QACT;QAEA,mDAAmD;QACnD,IAAI,AAACX,CAAAA,MAAMI,IAAI,KAAK,kBAAkBJ,MAAMI,IAAI,KAAK,QAAO,KAAMJ,MAAMK,OAAO,EAAE;YAC/E,IAAI,OAAON,UAAU,YAAa,CAAA,WAAWA,SAAS,aAAaA,KAAI,GAAI;gBACzE,OAAO,MAAM,iDAAiD;;YAChE;QACF;QAEA,IACE,AAACC,CAAAA,MAAMI,IAAI,KAAK,WAAWJ,MAAMI,IAAI,KAAK,KAAI,KAC9CL,SACA,OAAOA,UAAU,YACjB,CAACL,4BAA4B;YAC3BC,MAAMI;YACNH,QAAQI,MAAMW,eAAe;QAC/B,IACA;YACA,OAAO;QACT;IACF;IAEA,mDAAmD;IACnD,IAAI,CAACd,eAAe;QAClB,IAAK,MAAMC,OAAOH,KAAM;YACtB,IAAIG,IAAIc,QAAQ,CAAC,MAAM;gBACrB,0BAA0B;gBAC1B,MAAMC,gBAAgBf,IAAIgB,OAAO,CAAC;gBAClC,MAAMC,YAAYjB,IAAIkB,SAAS,CAAC,GAAGH;gBACnC,MAAMI,gBAAgBnB,IAAIkB,SAAS,CAACH,gBAAgB;gBAEpD,MAAMK,aAAa;oBAAE,CAACH,UAAU,EAAE;wBAAE,CAACE,cAAc,EAAEtB,IAAI,CAACG,IAAI;oBAAC;gBAAE;gBACjE,OAAOJ,4BAA4B;oBACjCC,MAAMuB;oBACNtB;gBACF;YACF;QACF;IACF;IAEA,OAAO;AACT,EAAC"}