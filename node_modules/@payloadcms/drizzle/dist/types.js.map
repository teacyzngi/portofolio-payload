{"version":3,"sources":["../src/types.ts"],"sourcesContent":["import type {\n  Column,\n  ColumnBaseConfig,\n  ColumnDataType,\n  DrizzleConfig,\n  ExtractTablesWithRelations,\n  Relation,\n  Relations,\n  SQL,\n  TableRelationalConfig,\n} from 'drizzle-orm'\nimport type { LibSQLDatabase } from 'drizzle-orm/libsql'\nimport type { NodePgDatabase, NodePgQueryResultHKT } from 'drizzle-orm/node-postgres'\nimport type {\n  PgColumn,\n  PgTable,\n  PgTransaction,\n  Precision,\n  UpdateDeleteAction,\n} from 'drizzle-orm/pg-core'\nimport type { SQLiteColumn, SQLiteTable, SQLiteTransaction } from 'drizzle-orm/sqlite-core'\nimport type { Result } from 'drizzle-orm/sqlite-core/session'\nimport type {\n  BaseDatabaseAdapter,\n  FlattenedField,\n  MigrationData,\n  Payload,\n  PayloadRequest,\n} from 'payload'\n\nimport type { BuildQueryJoinAliases } from './queries/buildQuery.js'\n\nexport { BuildQueryJoinAliases }\n\nimport type { ResultSet } from '@libsql/client'\nimport type { DrizzleSnapshotJSON } from 'drizzle-kit/api'\nimport type { SQLiteRaw } from 'drizzle-orm/sqlite-core/query-builders/raw'\nimport type { QueryResult } from 'pg'\n\nimport type { Operators } from './queries/operatorMap.js'\n\nexport type PostgresDB = NodePgDatabase<Record<string, unknown>>\n\nexport type SQLiteDB = LibSQLDatabase<\n  Record<string, GenericRelation | GenericTable> & Record<string, unknown>\n>\n\nexport type GenericPgColumn = PgColumn<\n  ColumnBaseConfig<ColumnDataType, string>,\n  Record<string, unknown>\n>\n\nexport type GenericColumns<T> = {\n  [x: string]: T\n}\n\ntype GenericPgTable = PgTable<{\n  columns: GenericColumns<GenericPgColumn>\n  dialect: string\n  name: string\n  schema: undefined\n}>\n\ntype GenericSQLiteTable = SQLiteTable<{\n  columns: GenericColumns<SQLiteColumn>\n  dialect: string\n  name: string\n  schema: undefined\n}>\n\nexport type GenericColumn = GenericPgColumn | SQLiteColumn\n\nexport type GenericTable = GenericPgTable | GenericSQLiteTable\n\nexport type GenericRelation = Relations<string, Record<string, Relation<string>>>\n\nexport type TransactionSQLite = SQLiteTransaction<\n  'async',\n  Result<'async', unknown>,\n  Record<string, unknown>,\n  { tsName: TableRelationalConfig }\n>\nexport type TransactionPg = PgTransaction<\n  NodePgQueryResultHKT,\n  Record<string, unknown>,\n  ExtractTablesWithRelations<Record<string, unknown>>\n>\n\nexport type DrizzleTransaction = TransactionPg | TransactionSQLite\n\nexport type CountDistinct = (args: {\n  column?: PgColumn<any> | SQLiteColumn<any>\n  db: DrizzleTransaction | LibSQLDatabase | PostgresDB\n  joins: BuildQueryJoinAliases\n  tableName: string\n  where: SQL\n}) => Promise<number>\n\nexport type DeleteWhere = (args: {\n  db: DrizzleTransaction | LibSQLDatabase | PostgresDB\n  tableName: string\n  where: SQL\n}) => Promise<void>\n\nexport type DropDatabase = (args: { adapter: DrizzleAdapter }) => Promise<void>\n\nexport type Execute<T> = (args: {\n  db?: DrizzleTransaction | LibSQLDatabase | PostgresDB\n  drizzle?: LibSQLDatabase | PostgresDB\n  raw?: string\n  sql?: SQL<unknown>\n}) =>\n  | Promise<QueryResult<Record<string, T>>>\n  | SQLiteRaw<Promise<{ rows: T[] }>>\n  | SQLiteRaw<ResultSet>\n\nexport type Insert = (args: {\n  db: DrizzleTransaction | LibSQLDatabase | PostgresDB\n  onConflictDoUpdate?: unknown\n  tableName: string\n  values: Record<string, unknown> | Record<string, unknown>[]\n}) => Promise<Record<string, unknown>[]>\n\nexport type RequireDrizzleKit = () => {\n  generateDrizzleJson: (\n    args: Record<string, unknown>,\n  ) => DrizzleSnapshotJSON | Promise<DrizzleSnapshotJSON>\n  generateMigration: (prev: DrizzleSnapshotJSON, cur: DrizzleSnapshotJSON) => Promise<string[]>\n  pushSchema: (\n    schema: Record<string, unknown>,\n    drizzle: DrizzleAdapter['drizzle'],\n    filterSchema?: string[],\n    tablesFilter?: string[],\n    extensionsFilter?: string[],\n  ) => Promise<{ apply; hasDataLoss; warnings }>\n  upSnapshot?: (snapshot: Record<string, unknown>) => DrizzleSnapshotJSON\n}\n\nexport type Migration = {\n  down: ({\n    db,\n    payload,\n    req,\n  }: {\n    db?: DrizzleTransaction | LibSQLDatabase<Record<string, never>> | PostgresDB\n    payload: Payload\n    req: PayloadRequest\n  }) => Promise<void>\n  up: ({\n    db,\n    payload,\n    req,\n  }: {\n    db?: DrizzleTransaction | LibSQLDatabase | PostgresDB\n    payload: Payload\n    req: PayloadRequest\n  }) => Promise<void>\n} & MigrationData\n\nexport type CreateJSONQueryArgs = {\n  column?: Column | string\n  operator: string\n  pathSegments: string[]\n  rawColumn?: SQL<unknown>\n  table?: string\n  treatAsArray?: string[]\n  treatRootAsArray?: boolean\n  value: boolean | number | number[] | string | string[]\n}\n\n/**\n * Abstract relation link\n */\nexport type RawRelation =\n  | {\n      fields: { name: string; table: string }[]\n      references: string[]\n      relationName?: string\n      to: string\n      type: 'one'\n    }\n  | {\n      relationName?: string\n      to: string\n      type: 'many'\n    }\n\n/**\n * Abstract SQL table that later gets converted by database specific implementation to Drizzle\n */\nexport type RawTable = {\n  columns: Record<string, RawColumn>\n  foreignKeys?: Record<string, RawForeignKey>\n  indexes?: Record<string, RawIndex>\n  name: string\n}\n\n/**\n * Abstract SQL foreign key that later gets converted by database specific implementation to Drizzle\n */\nexport type RawForeignKey = {\n  columns: string[]\n  foreignColumns: { name: string; table: string }[]\n  name: string\n  onDelete?: UpdateDeleteAction\n  onUpdate?: UpdateDeleteAction\n}\n\n/**\n * Abstract SQL index that later gets converted by database specific implementation to Drizzle\n */\nexport type RawIndex = {\n  name: string\n  on: string | string[]\n  unique?: boolean\n}\n\n/**\n * Abstract SQL column that later gets converted by database specific implementation to Drizzle\n */\nexport type BaseRawColumn = {\n  default?: any\n  name: string\n  notNull?: boolean\n  primaryKey?: boolean\n  reference?: {\n    name: string\n    onDelete: UpdateDeleteAction\n    table: string\n  }\n}\n\n/**\n * Postgres: native timestamp type\n * SQLite: text column, defaultNow achieved through strftime('%Y-%m-%dT%H:%M:%fZ', 'now'). withTimezone/precision have no any effect.\n */\nexport type TimestampRawColumn = {\n  defaultNow?: boolean\n  mode: 'date' | 'string'\n  precision: Precision\n  type: 'timestamp'\n  withTimezone?: boolean\n} & BaseRawColumn\n\n/**\n * Postgres: native UUID type and db lavel defaultRandom\n * SQLite: text type and defaultRandom in the app level\n */\nexport type UUIDRawColumn = {\n  defaultRandom?: boolean\n  type: 'uuid'\n} & BaseRawColumn\n\n/**\n * Accepts either `locale: true` to have options from locales or `options` string array\n * Postgres: native enums\n * SQLite: text column with checks.\n */\nexport type EnumRawColumn = (\n  | {\n      enumName: string\n      options: string[]\n      type: 'enum'\n    }\n  | {\n      locale: true\n      type: 'enum'\n    }\n) &\n  BaseRawColumn\n\nexport type IntegerRawColumn = {\n  /**\n   * SQLite only.\n   * Enable [AUTOINCREMENT](https://www.sqlite.org/autoinc.html) for primary key to ensure that the same ID cannot be reused from previously deleted rows.\n   */\n  autoIncrement?: boolean\n  type: 'integer'\n} & BaseRawColumn\n\nexport type VectorRawColumn = {\n  dimensions?: number\n  type: 'vector'\n} & BaseRawColumn\n\nexport type HalfVecRawColumn = {\n  dimensions?: number\n  type: 'halfvec'\n} & BaseRawColumn\n\nexport type SparseVecRawColumn = {\n  dimensions?: number\n  type: 'sparsevec'\n} & BaseRawColumn\n\nexport type BinaryVecRawColumn = {\n  dimensions?: number\n  type: 'bit'\n} & BaseRawColumn\n\nexport type RawColumn =\n  | ({\n      type: 'boolean' | 'geometry' | 'jsonb' | 'numeric' | 'serial' | 'text' | 'varchar'\n    } & BaseRawColumn)\n  | BinaryVecRawColumn\n  | EnumRawColumn\n  | HalfVecRawColumn\n  | IntegerRawColumn\n  | SparseVecRawColumn\n  | TimestampRawColumn\n  | UUIDRawColumn\n  | VectorRawColumn\n\nexport type IDType = 'integer' | 'numeric' | 'text' | 'uuid' | 'varchar'\n\nexport type SetColumnID = (args: {\n  adapter: DrizzleAdapter\n  columns: Record<string, RawColumn>\n  fields: FlattenedField[]\n}) => IDType\n\nexport type ColumnToCodeConverter = (args: {\n  adapter: DrizzleAdapter\n  addEnum: (name: string, options: string[]) => void\n  addImport: (from: string, name: string) => void\n  column: RawColumn\n  locales?: string[]\n  tableKey: string\n}) => string\n\nexport type BuildDrizzleTable<T extends DrizzleAdapter = DrizzleAdapter> = (args: {\n  adapter: T\n  locales: string[]\n  rawTable: RawTable\n}) => void\n\nexport interface DrizzleAdapter extends BaseDatabaseAdapter {\n  blocksAsJSON?: boolean\n  convertPathToJSONTraversal?: (incomingSegments: string[]) => string\n  countDistinct: CountDistinct\n  createJSONQuery: (args: CreateJSONQueryArgs) => string\n  defaultDrizzleSnapshot: Record<string, unknown>\n  deleteWhere: DeleteWhere\n  drizzle: LibSQLDatabase | PostgresDB\n  dropDatabase: DropDatabase\n  enums?: never | Record<string, unknown>\n  execute: Execute<unknown>\n\n  features: {\n    json?: boolean\n  }\n  /**\n   * An object keyed on each table, with a key value pair where the constraint name is the key, followed by the dot-notation field name\n   * Used for returning properly formed errors from unique fields\n   */\n  fieldConstraints: Record<string, Record<string, string>>\n  idType: 'serial' | 'uuid'\n  indexes: Set<string>\n  initializing: Promise<void>\n  insert: Insert\n  limitedBoundParameters?: boolean\n  localesSuffix?: string\n  logger: DrizzleConfig['logger']\n  operators: Operators\n  push: boolean\n  rawRelations: Record<string, Record<string, RawRelation>>\n  rawTables: Record<string, RawTable>\n  rejectInitializing: () => void\n\n  relations: Record<string, GenericRelation>\n  relationshipsSuffix?: string\n  requireDrizzleKit: RequireDrizzleKit\n  resolveInitializing: () => void\n  schema: Record<string, unknown>\n\n  schemaName?: string\n  sessions: {\n    [id: string]: {\n      db: DrizzleTransaction\n      reject: () => Promise<void>\n      resolve: () => Promise<void>\n    }\n  }\n  tableNameMap: Map<string, string>\n  tables: Record<string, any>\n  transactionOptions: unknown\n  versionsSuffix?: string\n}\n\nexport type RelationMap = Map<\n  string,\n  {\n    localized: boolean\n    relationName?: string\n    target: string\n    type: 'many' | 'one'\n  }\n>\n\n/**\n * @deprecated - will be removed in 4.0. Use query + $dynamic() instead: https://orm.drizzle.team/docs/dynamic-query-building\n */\nexport type { ChainedMethods } from './find/chainMethods.js'\n"],"names":[],"mappings":"AA+YA;;CAEC,GACD,WAA4D"}