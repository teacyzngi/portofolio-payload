{"version":3,"sources":["../../src/queries/getTableColumnFromPath.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\nimport type { SQLiteTableWithColumns } from 'drizzle-orm/sqlite-core'\nimport type {\n  FlattenedBlock,\n  FlattenedField,\n  NumberField,\n  RelationshipField,\n  TextField,\n} from 'payload'\n\nimport { and, eq, getTableName, like, or, sql, Table } from 'drizzle-orm'\nimport { type PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport { APIError, getFieldByPath } from 'payload'\nimport { fieldShouldBeLocalized, tabHasName } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\nimport { validate as uuidValidate } from 'uuid'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { isPolymorphicRelationship } from '../utilities/isPolymorphicRelationship.js'\nimport { jsonBuildObject } from '../utilities/json.js'\nimport { DistinctSymbol } from '../utilities/rawConstraint.js'\nimport { resolveBlockTableName } from '../utilities/validateExistingBlockIsIdentical.js'\nimport { addJoinTable } from './addJoinTable.js'\nimport { getTableAlias } from './getTableAlias.js'\n\ntype Constraint = {\n  columnName: string\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  value: unknown\n}\n\ntype TableColumn = {\n  columnName?: string\n  columns?: {\n    idType: 'number' | 'text' | 'uuid'\n    rawColumn: SQL<unknown>\n  }[]\n  constraints: Constraint[]\n  field: FlattenedField\n  getNotNullColumnByValue?: (val: unknown) => string\n  pathSegments?: string[]\n  rawColumn?: SQL\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n}\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  collectionPath: string\n  columnPrefix?: string\n  constraintPath?: string\n  constraints?: Constraint[]\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  parentAliasTable?: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  parentIsLocalized: boolean\n  pathSegments: string[]\n  rootTableName?: string\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  /**\n   * If creating a new table name for arrays and blocks, this suffix should be appended to the table name\n   */\n  tableNameSuffix?: string\n  /**\n   * The raw value of the query before sanitization\n   */\n  value: unknown\n}\n/**\n * Transforms path to table and column name or to a list of OR columns\n * Adds tables to `join`\n * @returns TableColumn\n */\nexport const getTableColumnFromPath = ({\n  adapter,\n  aliasTable,\n  collectionPath,\n  columnPrefix = '',\n  constraintPath: incomingConstraintPath,\n  constraints = [],\n  fields,\n  joins,\n  locale: incomingLocale,\n  parentAliasTable,\n  parentIsLocalized,\n  pathSegments: incomingSegments,\n  rootTableName: incomingRootTableName,\n  selectFields,\n  selectLocale,\n  tableName,\n  tableNameSuffix = '',\n  value,\n}: Args): TableColumn => {\n  const fieldPath = incomingSegments[0]\n  let locale = incomingLocale\n  const rootTableName = incomingRootTableName || tableName\n  let constraintPath = incomingConstraintPath || ''\n\n  const field = fields.find((fieldToFind) => fieldToFind.name === fieldPath)\n  let newTableName = tableName\n\n  if (!field && fieldPath === 'id') {\n    selectFields.id = adapter.tables[newTableName].id\n    return {\n      columnName: 'id',\n      constraints,\n      field: {\n        name: 'id',\n        type: adapter.idType === 'uuid' ? 'text' : 'number',\n      } as NumberField | TextField,\n      table: adapter.tables[newTableName],\n    }\n  }\n\n  if (field) {\n    const pathSegments = [...incomingSegments]\n\n    const isFieldLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    // If next segment is a locale,\n    // we need to take it out and use it as the locale from this point on\n    if (isFieldLocalized && adapter.payload.config.localization) {\n      const matchedLocale = adapter.payload.config.localization.localeCodes.find(\n        (locale) => locale === pathSegments[1],\n      )\n\n      if (matchedLocale) {\n        locale = matchedLocale\n        pathSegments.splice(1, 1)\n      }\n    }\n\n    switch (field.type) {\n      case 'array': {\n        newTableName = adapter.tableNameMap.get(\n          `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n        )\n\n        const arrayParentTable = aliasTable || adapter.tables[tableName]\n\n        constraintPath = `${constraintPath}${field.name}.%.`\n        if (locale && isFieldLocalized && adapter.payload.config.localization) {\n          const conditions = [eq(arrayParentTable.id, adapter.tables[newTableName]._parentID)]\n\n          if (selectLocale) {\n            selectFields._locale = adapter.tables[newTableName]._locale\n          }\n\n          if (locale !== 'all') {\n            conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n          }\n          addJoinTable({\n            condition: and(...conditions),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        } else {\n          addJoinTable({\n            condition: eq(arrayParentTable.id, adapter.tables[newTableName]._parentID),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n\n        return getTableColumnFromPath({\n          adapter,\n          collectionPath,\n          constraintPath,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentAliasTable: aliasTable,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          value,\n        })\n      }\n      case 'blocks': {\n        if (adapter.blocksAsJSON) {\n          break\n        }\n        let blockTableColumn: TableColumn\n        let newTableName: string\n\n        // handle blockType queries\n        if (pathSegments[1] === 'blockType') {\n          // find the block config using the value\n          const blockTypes = Array.isArray(value) ? value : [value]\n          blockTypes.forEach((blockType) => {\n            const block =\n              adapter.payload.blocks[blockType] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (block) => typeof block !== 'string' && block.slug === blockType,\n              ) as FlattenedBlock | undefined)\n\n            newTableName = resolveBlockTableName(\n              block,\n              adapter.tableNameMap.get(`${tableName}_blocks_${toSnakeCase(block.slug)}`),\n            )\n\n            const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n            joins.push({\n              condition: eq(adapter.tables[tableName].id, newAliasTable._parentID),\n              table: newAliasTable,\n            })\n            constraints.push({\n              columnName: '_path',\n              table: newAliasTable,\n              value: pathSegments[0],\n            })\n          })\n          return {\n            constraints,\n            field,\n            getNotNullColumnByValue: () => 'id',\n            table: adapter.tables[tableName],\n          }\n        }\n\n        const hasBlockField = (field.blockReferences ?? field.blocks).some((_block) => {\n          const block = typeof _block === 'string' ? adapter.payload.blocks[_block] : _block\n\n          newTableName = resolveBlockTableName(\n            block,\n            adapter.tableNameMap.get(`${tableName}_blocks_${toSnakeCase(block.slug)}`),\n          )\n\n          constraintPath = `${constraintPath}${field.name}.%.`\n\n          let result: TableColumn\n          const blockConstraints = []\n          const blockSelectFields = {}\n\n          let blockJoin: BuildQueryJoinAliases[0]\n          if (isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            blockJoin = {\n              condition: and(...conditions),\n              table: adapter.tables[newTableName],\n            }\n          } else {\n            blockJoin = {\n              condition: eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n              table: adapter.tables[newTableName],\n            }\n          }\n\n          // Create a new reference for nested joins\n          const newJoins = [...joins]\n\n          try {\n            result = getTableColumnFromPath({\n              adapter,\n              collectionPath,\n              constraintPath,\n              constraints: blockConstraints,\n              fields: block.flattenedFields,\n              joins: newJoins,\n              locale,\n              parentIsLocalized: parentIsLocalized || field.localized,\n              pathSegments: pathSegments.slice(1),\n              rootTableName,\n              selectFields: blockSelectFields,\n              selectLocale,\n              tableName: newTableName,\n              value,\n            })\n          } catch (_) {\n            // this is fine, not every block will have the field\n          }\n          if (!result) {\n            return\n          }\n          blockTableColumn = result\n          constraints = constraints.concat(blockConstraints)\n          selectFields = { ...selectFields, ...blockSelectFields }\n\n          const previousLength = joins.length\n          joins.push(blockJoin)\n          // Append new joins AFTER the block join to prevent errors with missing FROM clause.\n          if (newJoins.length > previousLength) {\n            for (let i = previousLength; i < newJoins.length; i++) {\n              joins.push(newJoins[i])\n            }\n          }\n          return true\n        })\n        if (hasBlockField) {\n          return {\n            columnName: blockTableColumn.columnName,\n            constraints,\n            field: blockTableColumn.field,\n            pathSegments: pathSegments.slice(1),\n            rawColumn: blockTableColumn.rawColumn,\n            table: blockTableColumn.table,\n          }\n        }\n        break\n      }\n\n      case 'group': {\n        if (locale && isFieldLocalized && adapter.payload.config.localization) {\n          newTableName = `${tableName}${adapter.localesSuffix}`\n\n          let condition = eq(adapter.tables[tableName].id, adapter.tables[newTableName]._parentID)\n\n          if (locale !== 'all') {\n            condition = and(condition, eq(adapter.tables[newTableName]._locale, locale))\n          }\n\n          addJoinTable({\n            condition,\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix: `${columnPrefix}${field.name}_`,\n          constraintPath: `${constraintPath}${field.name}.`,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n          value,\n        })\n      }\n\n      case 'join': {\n        if (Array.isArray(field.collection)) {\n          throw new APIError('Not supported')\n        }\n\n        const newCollectionPath = pathSegments.slice(1).join('.')\n\n        if (field.hasMany) {\n          const relationTableName = `${adapter.tableNameMap.get(toSnakeCase(field.collection))}${adapter.relationshipsSuffix}`\n          const { newAliasTable: aliasRelationshipTable } = getTableAlias({\n            adapter,\n            tableName: relationTableName,\n          })\n\n          const relationshipField = getFieldByPath({\n            fields: adapter.payload.collections[field.collection].config.flattenedFields,\n            path: field.on,\n          })\n          if (!relationshipField) {\n            throw new APIError('Relationship was not found')\n          }\n\n          addJoinTable({\n            condition: and(\n              eq(\n                adapter.tables[rootTableName].id,\n                aliasRelationshipTable[\n                  `${(relationshipField.field as RelationshipField).relationTo as string}ID`\n                ],\n              ),\n              like(aliasRelationshipTable.path, field.on),\n            ),\n            joins,\n            queryPath: field.on,\n            table: aliasRelationshipTable,\n          })\n\n          if (newCollectionPath === 'id') {\n            return {\n              columnName: 'parent',\n              constraints,\n              field: {\n                name: 'id',\n                type: adapter.idType === 'uuid' ? 'text' : 'number',\n              } as NumberField | TextField,\n              table: aliasRelationshipTable,\n            }\n          }\n\n          const relationshipConfig = adapter.payload.collections[field.collection].config\n          const relationshipTableName = adapter.tableNameMap.get(\n            toSnakeCase(relationshipConfig.slug),\n          )\n\n          // parent to relationship join table\n          const relationshipFields = relationshipConfig.flattenedFields\n\n          const { newAliasTable: relationshipTable } = getTableAlias({\n            adapter,\n            tableName: relationshipTableName,\n          })\n\n          joins.push({\n            condition: eq(aliasRelationshipTable.parent, relationshipTable.id),\n            table: relationshipTable,\n          })\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: relationshipTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            // relationshipFields are fields from a different collection => no parentIsLocalized\n            fields: relationshipFields,\n            joins,\n            locale,\n            parentIsLocalized: false,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: relationshipTableName,\n            selectFields,\n            selectLocale,\n            tableName: relationshipTableName,\n            value,\n          })\n        }\n\n        const newTableName = adapter.tableNameMap.get(\n          toSnakeCase(adapter.payload.collections[field.collection].config.slug),\n        )\n        const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n        joins.push({\n          condition: eq(\n            newAliasTable[field.on.replaceAll('.', '_')],\n            aliasTable ? aliasTable.id : adapter.tables[tableName].id,\n          ),\n          table: newAliasTable,\n        })\n\n        if (newCollectionPath === 'id') {\n          return {\n            columnName: 'id',\n            constraints,\n            field: {\n              name: 'id',\n              type: adapter.idType === 'uuid' ? 'text' : 'number',\n            } as NumberField | TextField,\n            table: newAliasTable,\n          }\n        }\n\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable: newAliasTable,\n          collectionPath: newCollectionPath,\n          constraintPath: '',\n          constraints,\n          fields: adapter.payload.collections[field.collection].config.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          selectFields,\n          tableName: newTableName,\n          value,\n        })\n\n        break\n      }\n\n      case 'number':\n      case 'text': {\n        if (field.hasMany) {\n          let tableType = 'texts'\n          let columnName = 'text'\n          if (field.type === 'number') {\n            tableType = 'numbers'\n            columnName = 'number'\n          }\n          newTableName = `${rootTableName}_${tableType}`\n\n          const existingTable = joins.find((e) => e.queryPath === `${constraintPath}${field.name}`)\n\n          const table = (existingTable?.table ??\n            getTableAlias({ adapter, tableName: newTableName })\n              .newAliasTable) as PgTableWithColumns<any>\n\n          const joinConstraints = [\n            eq(adapter.tables[rootTableName].id, table.parent),\n            like(table.path, `${constraintPath}${field.name}`),\n          ]\n\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [...joinConstraints]\n\n            if (locale !== 'all') {\n              conditions.push(eq(table._locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              queryPath: `${constraintPath}${field.name}`,\n              table,\n            })\n          } else {\n            addJoinTable({\n              condition: and(...joinConstraints),\n              joins,\n              queryPath: `${constraintPath}${field.name}`,\n              table,\n            })\n          }\n\n          return {\n            columnName,\n            constraints,\n            field,\n            table,\n          }\n        }\n        break\n      }\n      case 'relationship':\n      case 'upload': {\n        const newCollectionPath = pathSegments.slice(1).join('.')\n\n        if (Array.isArray(field.relationTo) || field.hasMany) {\n          let relationshipFields: FlattenedField[]\n          const relationTableName = `${rootTableName}${adapter.relationshipsSuffix}`\n\n          const existingJoin = joins.find((e) => e.queryPath === `${constraintPath}.${field.name}`)\n\n          let aliasRelationshipTable: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n          let aliasRelationshipTableName: string\n          if (existingJoin) {\n            aliasRelationshipTable = existingJoin.table\n            aliasRelationshipTableName = getTableName(existingJoin.table)\n          } else {\n            const res = getTableAlias({\n              adapter,\n              tableName: relationTableName,\n            })\n            aliasRelationshipTable = res.newAliasTable\n            aliasRelationshipTableName = res.newAliasTableName\n          }\n\n          if (selectLocale && isFieldLocalized && adapter.payload.config.localization) {\n            selectFields._locale = aliasRelationshipTable.locale\n          }\n\n          // Join in the relationships table\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(\n                (parentAliasTable || aliasTable || adapter.tables[rootTableName]).id,\n                aliasRelationshipTable.parent,\n              ),\n              like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(aliasRelationshipTable.locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              queryPath: `${constraintPath}.${field.name}`,\n              table: aliasRelationshipTable,\n            })\n          } else {\n            // Join in the relationships table\n            addJoinTable({\n              condition: and(\n                eq(\n                  (parentAliasTable || aliasTable || adapter.tables[rootTableName]).id,\n                  aliasRelationshipTable.parent,\n                ),\n                like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n              ),\n              joins,\n              queryPath: `${constraintPath}.${field.name}`,\n              table: aliasRelationshipTable,\n            })\n          }\n\n          selectFields[`${relationTableName}.path`] = aliasRelationshipTable.path\n\n          let newAliasTable\n\n          if (typeof field.relationTo === 'string') {\n            const relationshipConfig = adapter.payload.collections[field.relationTo].config\n\n            newTableName = adapter.tableNameMap.get(toSnakeCase(relationshipConfig.slug))\n\n            // parent to relationship join table\n            relationshipFields = relationshipConfig.flattenedFields\n            ;({ newAliasTable } = getTableAlias({ adapter, tableName: newTableName }))\n\n            joins.push({\n              condition: eq(newAliasTable.id, aliasRelationshipTable[`${field.relationTo}ID`]),\n              table: newAliasTable,\n            })\n\n            if (newCollectionPath === '' || newCollectionPath === 'id') {\n              return {\n                columnName: `${field.relationTo}ID`,\n                constraints,\n                field,\n                table: aliasRelationshipTable,\n              }\n            }\n          } else if (newCollectionPath === 'value') {\n            const hasCustomCollectionWithCustomID = field.relationTo.some(\n              (relationTo) => !!adapter.payload.collections[relationTo].customIDType,\n            )\n\n            const columns: TableColumn['columns'] = field.relationTo\n              .map((relationTo) => {\n                let idType: 'number' | 'text' | 'uuid' =\n                  adapter.idType === 'uuid' ? 'uuid' : 'number'\n\n                const { customIDType } = adapter.payload.collections[relationTo]\n\n                if (customIDType) {\n                  idType = customIDType\n                }\n\n                const idTypeTextOrUuid = idType === 'text' || idType === 'uuid'\n\n                // Do not add the column to OR if we know that it can't match by the type\n                // We can't do the same with idType: 'number' because `value` can be from the REST search query params\n                if (typeof value === 'number' && idTypeTextOrUuid) {\n                  return null\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  value.every((val) => typeof val === 'number') &&\n                  idTypeTextOrUuid\n                ) {\n                  return null\n                }\n\n                // Do not add the UUID type column if incoming query value doesn't match UUID. If there aren't any collections with\n                // a custom ID type, we skip this check\n                // We need this because Postgres throws an error if querying by UUID column with a value that isn't a valid UUID.\n                if (\n                  value &&\n                  !Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID\n                ) {\n                  if (!uuidValidate(value)) {\n                    return null\n                  }\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID &&\n                  !value.some((val) => uuidValidate(val))\n                ) {\n                  return null\n                }\n\n                const relationTableName = adapter.tableNameMap.get(\n                  toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n                )\n\n                return {\n                  idType,\n                  rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n                }\n              })\n              .filter(Boolean)\n\n            return {\n              columns,\n              constraints,\n              field,\n              table: aliasRelationshipTable,\n            }\n          } else if (newCollectionPath === 'relationTo') {\n            const relationTo = Array.isArray(field.relationTo)\n              ? field.relationTo\n              : [field.relationTo]\n\n            return {\n              constraints,\n              field,\n              getNotNullColumnByValue: (val) => {\n                const matchedRelation = relationTo.find((relation) => relation === val)\n                if (matchedRelation) {\n                  return `${matchedRelation}ID`\n                }\n                return undefined\n              },\n              table: aliasRelationshipTable,\n            }\n          } else if (isPolymorphicRelationship(value)) {\n            const { relationTo } = value\n\n            const relationTableName = adapter.tableNameMap.get(\n              toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n            )\n\n            return {\n              constraints,\n              field,\n              rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n              table: aliasRelationshipTable,\n            }\n          } else if (value === DistinctSymbol) {\n            const obj: Record<string, SQL> = {}\n\n            field.relationTo.forEach((relationTo) => {\n              const relationTableName = adapter.tableNameMap.get(\n                toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n              )\n\n              obj[relationTo] = sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`)\n            })\n\n            let rawColumn = jsonBuildObject(adapter, obj)\n            if (adapter.name === 'postgres') {\n              rawColumn = sql`${rawColumn}::text`\n            }\n\n            return {\n              constraints,\n              field,\n              rawColumn,\n              table: aliasRelationshipTable,\n            }\n          } else {\n            throw new APIError('Not supported')\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            // relationshipFields are fields from a different collection => no parentIsLocalized\n            fields: relationshipFields,\n            joins,\n            locale,\n            parentIsLocalized: false,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: newTableName,\n            selectFields,\n            selectLocale,\n            tableName: newTableName,\n            value,\n          })\n        } else if (\n          pathSegments.length > 1 &&\n          !(pathSegments.length === 2 && pathSegments[1] === 'id')\n        ) {\n          // simple relationships\n          const columnName = `${columnPrefix}${field.name}`\n          const newTableName = adapter.tableNameMap.get(\n            toSnakeCase(adapter.payload.collections[field.relationTo].config.slug),\n          )\n          const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n          if (isFieldLocalized && adapter.payload.config.localization) {\n            const { newAliasTable: aliasLocaleTable } = getTableAlias({\n              adapter,\n              tableName: `${rootTableName}${adapter.localesSuffix}`,\n            })\n\n            const condtions = [eq(aliasLocaleTable._parentID, adapter.tables[rootTableName].id)]\n\n            if (selectLocale) {\n              selectFields._locale = aliasLocaleTable._locale\n            }\n\n            if (locale !== 'all') {\n              condtions.push(eq(aliasLocaleTable._locale, locale))\n            }\n\n            const localesTable = adapter.tables[`${rootTableName}${adapter.localesSuffix}`]\n\n            addJoinTable({\n              condition: and(...condtions),\n              joins,\n              table: localesTable,\n            })\n\n            joins.push({\n              condition: eq(localesTable[columnName], newAliasTable.id),\n              table: newAliasTable,\n            })\n          } else {\n            joins.push({\n              condition: eq(\n                newAliasTable.id,\n                aliasTable ? aliasTable[columnName] : adapter.tables[tableName][columnName],\n              ),\n              table: newAliasTable,\n            })\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraintPath: '',\n            constraints,\n            fields: adapter.payload.collections[field.relationTo].config.flattenedFields,\n            joins,\n            locale,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            pathSegments: pathSegments.slice(1),\n            selectFields,\n            tableName: newTableName,\n            value,\n          })\n        }\n\n        break\n      }\n\n      case 'select': {\n        if (field.hasMany) {\n          const newTableName = adapter.tableNameMap.get(\n            `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n          )\n\n          const idColumn = (aliasTable ?? adapter.tables[tableName]).id\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(idColumn, adapter.tables[newTableName].parent),\n              eq(adapter.tables[newTableName]._locale, locale),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            addJoinTable({\n              condition: eq(idColumn, adapter.tables[newTableName].parent),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName: 'value',\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n\n      case 'tab': {\n        if (tabHasName(field)) {\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable,\n            collectionPath,\n            columnPrefix: `${columnPrefix}${field.name}_`,\n            constraintPath: `${constraintPath}${field.name}.`,\n            constraints,\n            fields: field.flattenedFields,\n            joins,\n            locale,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            pathSegments: pathSegments.slice(1),\n            rootTableName,\n            selectFields,\n            selectLocale,\n            tableName: newTableName,\n            tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n            value,\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix,\n          constraintPath,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          tableNameSuffix,\n          value,\n        })\n      }\n\n      default: {\n        // fall through\n        break\n      }\n    }\n\n    let newTable = adapter.tables[newTableName]\n\n    if (isFieldLocalized && adapter.payload.config.localization) {\n      // If localized, we go to localized table and set aliasTable to undefined\n      // so it is not picked up below to be used as targetTable\n      const parentTable = aliasTable || adapter.tables[tableName]\n      newTableName = `${tableName}${adapter.localesSuffix}`\n\n      newTable = adapter.tables[newTableName]\n\n      let condition = eq(parentTable.id, newTable._parentID)\n\n      if (locale !== 'all') {\n        condition = and(condition, eq(newTable._locale, locale))\n      }\n\n      if (selectLocale) {\n        selectFields._locale = newTable._locale\n      }\n\n      addJoinTable({\n        condition,\n        joins,\n        table: newTable,\n      })\n\n      aliasTable = undefined\n    }\n\n    const targetTable = aliasTable || newTable\n\n    selectFields[`${newTableName}.${columnPrefix}${field.name}`] =\n      targetTable[`${columnPrefix}${field.name}`]\n\n    return {\n      columnName: `${columnPrefix}${field.name}`,\n      constraints,\n      field,\n      pathSegments,\n      table: targetTable,\n    }\n  }\n\n  throw new APIError(`Cannot find field for path at ${fieldPath}`)\n}\n"],"names":["and","eq","getTableName","like","sql","APIError","getFieldByPath","fieldShouldBeLocalized","tabHasName","toSnakeCase","validate","uuidValidate","isPolymorphicRelationship","jsonBuildObject","DistinctSymbol","resolveBlockTableName","addJoinTable","getTableAlias","getTableColumnFromPath","adapter","aliasTable","collectionPath","columnPrefix","constraintPath","incomingConstraintPath","constraints","fields","joins","locale","incomingLocale","parentAliasTable","parentIsLocalized","pathSegments","incomingSegments","rootTableName","incomingRootTableName","selectFields","selectLocale","tableName","tableNameSuffix","value","fieldPath","field","find","fieldToFind","name","newTableName","id","tables","columnName","type","idType","table","isFieldLocalized","payload","config","localization","matchedLocale","localeCodes","splice","tableNameMap","get","arrayParentTable","conditions","_parentID","_locale","push","condition","flattenedFields","localized","slice","blocksAsJSON","blockTableColumn","blockTypes","Array","isArray","forEach","blockType","block","blocks","blockReferences","slug","newAliasTable","getNotNullColumnByValue","hasBlockField","some","_block","result","blockConstraints","blockSelectFields","blockJoin","newJoins","_","concat","previousLength","length","i","rawColumn","localesSuffix","collection","newCollectionPath","join","hasMany","relationTableName","relationshipsSuffix","aliasRelationshipTable","relationshipField","collections","path","on","relationTo","queryPath","relationshipConfig","relationshipTableName","relationshipFields","relationshipTable","parent","replaceAll","tableType","existingTable","e","joinConstraints","existingJoin","aliasRelationshipTableName","res","newAliasTableName","hasCustomCollectionWithCustomID","customIDType","columns","map","idTypeTextOrUuid","every","val","raw","filter","Boolean","matchedRelation","relation","undefined","obj","aliasLocaleTable","condtions","localesTable","idColumn","newTable","parentTable","targetTable"],"mappings":"AAUA,SAASA,GAAG,EAAEC,EAAE,EAAEC,YAAY,EAAEC,IAAI,EAAMC,GAAG,QAAe,cAAa;AAEzE,SAASC,QAAQ,EAAEC,cAAc,QAAQ,UAAS;AAClD,SAASC,sBAAsB,EAAEC,UAAU,QAAQ,iBAAgB;AACnE,OAAOC,iBAAiB,gBAAe;AACvC,SAASC,YAAYC,YAAY,QAAQ,OAAM;AAK/C,SAASC,yBAAyB,QAAQ,4CAA2C;AACrF,SAASC,eAAe,QAAQ,uBAAsB;AACtD,SAASC,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,qBAAqB,QAAQ,mDAAkD;AACxF,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,aAAa,QAAQ,qBAAoB;AAgDlD;;;;CAIC,GACD,OAAO,MAAMC,yBAAyB,CAAC,EACrCC,OAAO,EACPC,UAAU,EACVC,cAAc,EACdC,eAAe,EAAE,EACjBC,gBAAgBC,sBAAsB,EACtCC,cAAc,EAAE,EAChBC,MAAM,EACNC,KAAK,EACLC,QAAQC,cAAc,EACtBC,gBAAgB,EAChBC,iBAAiB,EACjBC,cAAcC,gBAAgB,EAC9BC,eAAeC,qBAAqB,EACpCC,YAAY,EACZC,YAAY,EACZC,SAAS,EACTC,kBAAkB,EAAE,EACpBC,KAAK,EACA;IACL,MAAMC,YAAYR,gBAAgB,CAAC,EAAE;IACrC,IAAIL,SAASC;IACb,MAAMK,gBAAgBC,yBAAyBG;IAC/C,IAAIf,iBAAiBC,0BAA0B;IAE/C,MAAMkB,QAAQhB,OAAOiB,IAAI,CAAC,CAACC,cAAgBA,YAAYC,IAAI,KAAKJ;IAChE,IAAIK,eAAeR;IAEnB,IAAI,CAACI,SAASD,cAAc,MAAM;QAChCL,aAAaW,EAAE,GAAG5B,QAAQ6B,MAAM,CAACF,aAAa,CAACC,EAAE;QACjD,OAAO;YACLE,YAAY;YACZxB;YACAiB,OAAO;gBACLG,MAAM;gBACNK,MAAM/B,QAAQgC,MAAM,KAAK,SAAS,SAAS;YAC7C;YACAC,OAAOjC,QAAQ6B,MAAM,CAACF,aAAa;QACrC;IACF;IAEA,IAAIJ,OAAO;QACT,MAAMV,eAAe;eAAIC;SAAiB;QAE1C,MAAMoB,mBAAmB9C,uBAAuB;YAAEmC;YAAOX;QAAkB;QAE3E,+BAA+B;QAC/B,qEAAqE;QACrE,IAAIsB,oBAAoBlC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;YAC3D,MAAMC,gBAAgBtC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,CAACE,WAAW,CAACf,IAAI,CACxE,CAACf,SAAWA,WAAWI,YAAY,CAAC,EAAE;YAGxC,IAAIyB,eAAe;gBACjB7B,SAAS6B;gBACTzB,aAAa2B,MAAM,CAAC,GAAG;YACzB;QACF;QAEA,OAAQjB,MAAMQ,IAAI;YAChB,KAAK;gBAAS;oBACZJ,eAAe3B,QAAQyC,YAAY,CAACC,GAAG,CACrC,GAAGvB,UAAU,CAAC,EAAEC,kBAAkB9B,YAAYiC,MAAMG,IAAI,GAAG;oBAG7D,MAAMiB,mBAAmB1C,cAAcD,QAAQ6B,MAAM,CAACV,UAAU;oBAEhEf,iBAAiB,GAAGA,iBAAiBmB,MAAMG,IAAI,CAAC,GAAG,CAAC;oBACpD,IAAIjB,UAAUyB,oBAAoBlC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;wBACrE,MAAMO,aAAa;4BAAC9D,GAAG6D,iBAAiBf,EAAE,EAAE5B,QAAQ6B,MAAM,CAACF,aAAa,CAACkB,SAAS;yBAAE;wBAEpF,IAAI3B,cAAc;4BAChBD,aAAa6B,OAAO,GAAG9C,QAAQ6B,MAAM,CAACF,aAAa,CAACmB,OAAO;wBAC7D;wBAEA,IAAIrC,WAAW,OAAO;4BACpBmC,WAAWG,IAAI,CAACjE,GAAGkB,QAAQ6B,MAAM,CAACF,aAAa,CAACmB,OAAO,EAAErC;wBAC3D;wBACAZ,aAAa;4BACXmD,WAAWnE,OAAO+D;4BAClBpC;4BACAyB,OAAOjC,QAAQ6B,MAAM,CAACF,aAAa;wBACrC;oBACF,OAAO;wBACL9B,aAAa;4BACXmD,WAAWlE,GAAG6D,iBAAiBf,EAAE,EAAE5B,QAAQ6B,MAAM,CAACF,aAAa,CAACkB,SAAS;4BACzErC;4BACAyB,OAAOjC,QAAQ6B,MAAM,CAACF,aAAa;wBACrC;oBACF;oBAEA,OAAO5B,uBAAuB;wBAC5BC;wBACAE;wBACAE;wBACAE;wBACAC,QAAQgB,MAAM0B,eAAe;wBAC7BzC;wBACAC;wBACAE,kBAAkBV;wBAClBW,mBAAmBA,qBAAqBW,MAAM2B,SAAS;wBACvDrC,cAAcA,aAAasC,KAAK,CAAC;wBACjCpC;wBACAE;wBACAC;wBACAC,WAAWQ;wBACXN;oBACF;gBACF;YACA,KAAK;gBAAU;oBACb,IAAIrB,QAAQoD,YAAY,EAAE;wBACxB;oBACF;oBACA,IAAIC;oBACJ,IAAI1B;oBAEJ,2BAA2B;oBAC3B,IAAId,YAAY,CAAC,EAAE,KAAK,aAAa;wBACnC,wCAAwC;wBACxC,MAAMyC,aAAaC,MAAMC,OAAO,CAACnC,SAASA,QAAQ;4BAACA;yBAAM;wBACzDiC,WAAWG,OAAO,CAAC,CAACC;4BAClB,MAAMC,QACJ3D,QAAQmC,OAAO,CAACyB,MAAM,CAACF,UAAU,IAChC,AAACnC,CAAAA,MAAMsC,eAAe,IAAItC,MAAMqC,MAAM,AAAD,EAAGpC,IAAI,CAC3C,CAACmC,QAAU,OAAOA,UAAU,YAAYA,MAAMG,IAAI,KAAKJ;4BAG3D/B,eAAe/B,sBACb+D,OACA3D,QAAQyC,YAAY,CAACC,GAAG,CAAC,GAAGvB,UAAU,QAAQ,EAAE7B,YAAYqE,MAAMG,IAAI,GAAG;4BAG3E,MAAM,EAAEC,aAAa,EAAE,GAAGjE,cAAc;gCAAEE;gCAASmB,WAAWQ;4BAAa;4BAE3EnB,MAAMuC,IAAI,CAAC;gCACTC,WAAWlE,GAAGkB,QAAQ6B,MAAM,CAACV,UAAU,CAACS,EAAE,EAAEmC,cAAclB,SAAS;gCACnEZ,OAAO8B;4BACT;4BACAzD,YAAYyC,IAAI,CAAC;gCACfjB,YAAY;gCACZG,OAAO8B;gCACP1C,OAAOR,YAAY,CAAC,EAAE;4BACxB;wBACF;wBACA,OAAO;4BACLP;4BACAiB;4BACAyC,yBAAyB,IAAM;4BAC/B/B,OAAOjC,QAAQ6B,MAAM,CAACV,UAAU;wBAClC;oBACF;oBAEA,MAAM8C,gBAAgB,AAAC1C,CAAAA,MAAMsC,eAAe,IAAItC,MAAMqC,MAAM,AAAD,EAAGM,IAAI,CAAC,CAACC;wBAClE,MAAMR,QAAQ,OAAOQ,WAAW,WAAWnE,QAAQmC,OAAO,CAACyB,MAAM,CAACO,OAAO,GAAGA;wBAE5ExC,eAAe/B,sBACb+D,OACA3D,QAAQyC,YAAY,CAACC,GAAG,CAAC,GAAGvB,UAAU,QAAQ,EAAE7B,YAAYqE,MAAMG,IAAI,GAAG;wBAG3E1D,iBAAiB,GAAGA,iBAAiBmB,MAAMG,IAAI,CAAC,GAAG,CAAC;wBAEpD,IAAI0C;wBACJ,MAAMC,mBAAmB,EAAE;wBAC3B,MAAMC,oBAAoB,CAAC;wBAE3B,IAAIC;wBACJ,IAAIrC,oBAAoBlC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;4BAC3D,MAAMO,aAAa;gCACjB9D,GACE,AAACmB,CAAAA,cAAcD,QAAQ6B,MAAM,CAACV,UAAU,AAAD,EAAGS,EAAE,EAC5C5B,QAAQ6B,MAAM,CAACF,aAAa,CAACkB,SAAS;6BAEzC;4BAED,IAAIpC,WAAW,OAAO;gCACpBmC,WAAWG,IAAI,CAACjE,GAAGkB,QAAQ6B,MAAM,CAACF,aAAa,CAACmB,OAAO,EAAErC;4BAC3D;4BAEA8D,YAAY;gCACVvB,WAAWnE,OAAO+D;gCAClBX,OAAOjC,QAAQ6B,MAAM,CAACF,aAAa;4BACrC;wBACF,OAAO;4BACL4C,YAAY;gCACVvB,WAAWlE,GACT,AAACmB,CAAAA,cAAcD,QAAQ6B,MAAM,CAACV,UAAU,AAAD,EAAGS,EAAE,EAC5C5B,QAAQ6B,MAAM,CAACF,aAAa,CAACkB,SAAS;gCAExCZ,OAAOjC,QAAQ6B,MAAM,CAACF,aAAa;4BACrC;wBACF;wBAEA,0CAA0C;wBAC1C,MAAM6C,WAAW;+BAAIhE;yBAAM;wBAE3B,IAAI;4BACF4D,SAASrE,uBAAuB;gCAC9BC;gCACAE;gCACAE;gCACAE,aAAa+D;gCACb9D,QAAQoD,MAAMV,eAAe;gCAC7BzC,OAAOgE;gCACP/D;gCACAG,mBAAmBA,qBAAqBW,MAAM2B,SAAS;gCACvDrC,cAAcA,aAAasC,KAAK,CAAC;gCACjCpC;gCACAE,cAAcqD;gCACdpD;gCACAC,WAAWQ;gCACXN;4BACF;wBACF,EAAE,OAAOoD,GAAG;wBACV,oDAAoD;wBACtD;wBACA,IAAI,CAACL,QAAQ;4BACX;wBACF;wBACAf,mBAAmBe;wBACnB9D,cAAcA,YAAYoE,MAAM,CAACL;wBACjCpD,eAAe;4BAAE,GAAGA,YAAY;4BAAE,GAAGqD,iBAAiB;wBAAC;wBAEvD,MAAMK,iBAAiBnE,MAAMoE,MAAM;wBACnCpE,MAAMuC,IAAI,CAACwB;wBACX,oFAAoF;wBACpF,IAAIC,SAASI,MAAM,GAAGD,gBAAgB;4BACpC,IAAK,IAAIE,IAAIF,gBAAgBE,IAAIL,SAASI,MAAM,EAAEC,IAAK;gCACrDrE,MAAMuC,IAAI,CAACyB,QAAQ,CAACK,EAAE;4BACxB;wBACF;wBACA,OAAO;oBACT;oBACA,IAAIZ,eAAe;wBACjB,OAAO;4BACLnC,YAAYuB,iBAAiBvB,UAAU;4BACvCxB;4BACAiB,OAAO8B,iBAAiB9B,KAAK;4BAC7BV,cAAcA,aAAasC,KAAK,CAAC;4BACjC2B,WAAWzB,iBAAiByB,SAAS;4BACrC7C,OAAOoB,iBAAiBpB,KAAK;wBAC/B;oBACF;oBACA;gBACF;YAEA,KAAK;gBAAS;oBACZ,IAAIxB,UAAUyB,oBAAoBlC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;wBACrEV,eAAe,GAAGR,YAAYnB,QAAQ+E,aAAa,EAAE;wBAErD,IAAI/B,YAAYlE,GAAGkB,QAAQ6B,MAAM,CAACV,UAAU,CAACS,EAAE,EAAE5B,QAAQ6B,MAAM,CAACF,aAAa,CAACkB,SAAS;wBAEvF,IAAIpC,WAAW,OAAO;4BACpBuC,YAAYnE,IAAImE,WAAWlE,GAAGkB,QAAQ6B,MAAM,CAACF,aAAa,CAACmB,OAAO,EAAErC;wBACtE;wBAEAZ,aAAa;4BACXmD;4BACAxC;4BACAyB,OAAOjC,QAAQ6B,MAAM,CAACF,aAAa;wBACrC;oBACF;oBACA,OAAO5B,uBAAuB;wBAC5BC;wBACAC;wBACAC;wBACAC,cAAc,GAAGA,eAAeoB,MAAMG,IAAI,CAAC,CAAC,CAAC;wBAC7CtB,gBAAgB,GAAGA,iBAAiBmB,MAAMG,IAAI,CAAC,CAAC,CAAC;wBACjDpB;wBACAC,QAAQgB,MAAM0B,eAAe;wBAC7BzC;wBACAC;wBACAG,mBAAmBA,qBAAqBW,MAAM2B,SAAS;wBACvDrC,cAAcA,aAAasC,KAAK,CAAC;wBACjCpC;wBACAE;wBACAC;wBACAC,WAAWQ;wBACXP,iBAAiB,GAAGA,kBAAkB9B,YAAYiC,MAAMG,IAAI,EAAE,CAAC,CAAC;wBAChEL;oBACF;gBACF;YAEA,KAAK;gBAAQ;oBACX,IAAIkC,MAAMC,OAAO,CAACjC,MAAMyD,UAAU,GAAG;wBACnC,MAAM,IAAI9F,SAAS;oBACrB;oBAEA,MAAM+F,oBAAoBpE,aAAasC,KAAK,CAAC,GAAG+B,IAAI,CAAC;oBAErD,IAAI3D,MAAM4D,OAAO,EAAE;wBACjB,MAAMC,oBAAoB,GAAGpF,QAAQyC,YAAY,CAACC,GAAG,CAACpD,YAAYiC,MAAMyD,UAAU,KAAKhF,QAAQqF,mBAAmB,EAAE;wBACpH,MAAM,EAAEtB,eAAeuB,sBAAsB,EAAE,GAAGxF,cAAc;4BAC9DE;4BACAmB,WAAWiE;wBACb;wBAEA,MAAMG,oBAAoBpG,eAAe;4BACvCoB,QAAQP,QAAQmC,OAAO,CAACqD,WAAW,CAACjE,MAAMyD,UAAU,CAAC,CAAC5C,MAAM,CAACa,eAAe;4BAC5EwC,MAAMlE,MAAMmE,EAAE;wBAChB;wBACA,IAAI,CAACH,mBAAmB;4BACtB,MAAM,IAAIrG,SAAS;wBACrB;wBAEAW,aAAa;4BACXmD,WAAWnE,IACTC,GACEkB,QAAQ6B,MAAM,CAACd,cAAc,CAACa,EAAE,EAChC0D,sBAAsB,CACpB,GAAG,AAACC,kBAAkBhE,KAAK,CAAuBoE,UAAU,CAAW,EAAE,CAAC,CAC3E,GAEH3G,KAAKsG,uBAAuBG,IAAI,EAAElE,MAAMmE,EAAE;4BAE5ClF;4BACAoF,WAAWrE,MAAMmE,EAAE;4BACnBzD,OAAOqD;wBACT;wBAEA,IAAIL,sBAAsB,MAAM;4BAC9B,OAAO;gCACLnD,YAAY;gCACZxB;gCACAiB,OAAO;oCACLG,MAAM;oCACNK,MAAM/B,QAAQgC,MAAM,KAAK,SAAS,SAAS;gCAC7C;gCACAC,OAAOqD;4BACT;wBACF;wBAEA,MAAMO,qBAAqB7F,QAAQmC,OAAO,CAACqD,WAAW,CAACjE,MAAMyD,UAAU,CAAC,CAAC5C,MAAM;wBAC/E,MAAM0D,wBAAwB9F,QAAQyC,YAAY,CAACC,GAAG,CACpDpD,YAAYuG,mBAAmB/B,IAAI;wBAGrC,oCAAoC;wBACpC,MAAMiC,qBAAqBF,mBAAmB5C,eAAe;wBAE7D,MAAM,EAAEc,eAAeiC,iBAAiB,EAAE,GAAGlG,cAAc;4BACzDE;4BACAmB,WAAW2E;wBACb;wBAEAtF,MAAMuC,IAAI,CAAC;4BACTC,WAAWlE,GAAGwG,uBAAuBW,MAAM,EAAED,kBAAkBpE,EAAE;4BACjEK,OAAO+D;wBACT;wBAEA,OAAOjG,uBAAuB;4BAC5BC;4BACAC,YAAY+F;4BACZ9F,gBAAgB+E;4BAChB3E;4BACA,oFAAoF;4BACpFC,QAAQwF;4BACRvF;4BACAC;4BACAG,mBAAmB;4BACnBC,cAAcA,aAAasC,KAAK,CAAC;4BACjCpC,eAAe+E;4BACf7E;4BACAC;4BACAC,WAAW2E;4BACXzE;wBACF;oBACF;oBAEA,MAAMM,eAAe3B,QAAQyC,YAAY,CAACC,GAAG,CAC3CpD,YAAYU,QAAQmC,OAAO,CAACqD,WAAW,CAACjE,MAAMyD,UAAU,CAAC,CAAC5C,MAAM,CAAC0B,IAAI;oBAEvE,MAAM,EAAEC,aAAa,EAAE,GAAGjE,cAAc;wBAAEE;wBAASmB,WAAWQ;oBAAa;oBAE3EnB,MAAMuC,IAAI,CAAC;wBACTC,WAAWlE,GACTiF,aAAa,CAACxC,MAAMmE,EAAE,CAACQ,UAAU,CAAC,KAAK,KAAK,EAC5CjG,aAAaA,WAAW2B,EAAE,GAAG5B,QAAQ6B,MAAM,CAACV,UAAU,CAACS,EAAE;wBAE3DK,OAAO8B;oBACT;oBAEA,IAAIkB,sBAAsB,MAAM;wBAC9B,OAAO;4BACLnD,YAAY;4BACZxB;4BACAiB,OAAO;gCACLG,MAAM;gCACNK,MAAM/B,QAAQgC,MAAM,KAAK,SAAS,SAAS;4BAC7C;4BACAC,OAAO8B;wBACT;oBACF;oBAEA,OAAOhE,uBAAuB;wBAC5BC;wBACAC,YAAY8D;wBACZ7D,gBAAgB+E;wBAChB7E,gBAAgB;wBAChBE;wBACAC,QAAQP,QAAQmC,OAAO,CAACqD,WAAW,CAACjE,MAAMyD,UAAU,CAAC,CAAC5C,MAAM,CAACa,eAAe;wBAC5EzC;wBACAC;wBACAG,mBAAmBA,qBAAqBW,MAAM2B,SAAS;wBACvDrC,cAAcA,aAAasC,KAAK,CAAC;wBACjClC;wBACAE,WAAWQ;wBACXN;oBACF;oBAEA;gBACF;YAEA,KAAK;YACL,KAAK;gBAAQ;oBACX,IAAIE,MAAM4D,OAAO,EAAE;wBACjB,IAAIgB,YAAY;wBAChB,IAAIrE,aAAa;wBACjB,IAAIP,MAAMQ,IAAI,KAAK,UAAU;4BAC3BoE,YAAY;4BACZrE,aAAa;wBACf;wBACAH,eAAe,GAAGZ,cAAc,CAAC,EAAEoF,WAAW;wBAE9C,MAAMC,gBAAgB5F,MAAMgB,IAAI,CAAC,CAAC6E,IAAMA,EAAET,SAAS,KAAK,GAAGxF,iBAAiBmB,MAAMG,IAAI,EAAE;wBAExF,MAAMO,QAASmE,eAAenE,SAC5BnC,cAAc;4BAAEE;4BAASmB,WAAWQ;wBAAa,GAC9CoC,aAAa;wBAElB,MAAMuC,kBAAkB;4BACtBxH,GAAGkB,QAAQ6B,MAAM,CAACd,cAAc,CAACa,EAAE,EAAEK,MAAMgE,MAAM;4BACjDjH,KAAKiD,MAAMwD,IAAI,EAAE,GAAGrF,iBAAiBmB,MAAMG,IAAI,EAAE;yBAClD;wBAED,IAAIjB,UAAUyB,oBAAoBlC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;4BACrE,MAAMO,aAAa;mCAAI0D;6BAAgB;4BAEvC,IAAI7F,WAAW,OAAO;gCACpBmC,WAAWG,IAAI,CAACjE,GAAGmD,MAAMa,OAAO,EAAErC;4BACpC;4BAEAZ,aAAa;gCACXmD,WAAWnE,OAAO+D;gCAClBpC;gCACAoF,WAAW,GAAGxF,iBAAiBmB,MAAMG,IAAI,EAAE;gCAC3CO;4BACF;wBACF,OAAO;4BACLpC,aAAa;gCACXmD,WAAWnE,OAAOyH;gCAClB9F;gCACAoF,WAAW,GAAGxF,iBAAiBmB,MAAMG,IAAI,EAAE;gCAC3CO;4BACF;wBACF;wBAEA,OAAO;4BACLH;4BACAxB;4BACAiB;4BACAU;wBACF;oBACF;oBACA;gBACF;YACA,KAAK;YACL,KAAK;gBAAU;oBACb,MAAMgD,oBAAoBpE,aAAasC,KAAK,CAAC,GAAG+B,IAAI,CAAC;oBAErD,IAAI3B,MAAMC,OAAO,CAACjC,MAAMoE,UAAU,KAAKpE,MAAM4D,OAAO,EAAE;wBACpD,IAAIY;wBACJ,MAAMX,oBAAoB,GAAGrE,gBAAgBf,QAAQqF,mBAAmB,EAAE;wBAE1E,MAAMkB,eAAe/F,MAAMgB,IAAI,CAAC,CAAC6E,IAAMA,EAAET,SAAS,KAAK,GAAGxF,eAAe,CAAC,EAAEmB,MAAMG,IAAI,EAAE;wBAExF,IAAI4D;wBACJ,IAAIkB;wBACJ,IAAID,cAAc;4BAChBjB,yBAAyBiB,aAAatE,KAAK;4BAC3CuE,6BAA6BzH,aAAawH,aAAatE,KAAK;wBAC9D,OAAO;4BACL,MAAMwE,MAAM3G,cAAc;gCACxBE;gCACAmB,WAAWiE;4BACb;4BACAE,yBAAyBmB,IAAI1C,aAAa;4BAC1CyC,6BAA6BC,IAAIC,iBAAiB;wBACpD;wBAEA,IAAIxF,gBAAgBgB,oBAAoBlC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;4BAC3EpB,aAAa6B,OAAO,GAAGwC,uBAAuB7E,MAAM;wBACtD;wBAEA,kCAAkC;wBAClC,IAAIA,UAAUyB,oBAAoBlC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;4BACrE,MAAMO,aAAa;gCACjB9D,GACE,AAAC6B,CAAAA,oBAAoBV,cAAcD,QAAQ6B,MAAM,CAACd,cAAc,AAAD,EAAGa,EAAE,EACpE0D,uBAAuBW,MAAM;gCAE/BjH,KAAKsG,uBAAuBG,IAAI,EAAE,GAAGrF,iBAAiBmB,MAAMG,IAAI,EAAE;6BACnE;4BAED,IAAIjB,WAAW,OAAO;gCACpBmC,WAAWG,IAAI,CAACjE,GAAGwG,uBAAuB7E,MAAM,EAAEA;4BACpD;4BAEAZ,aAAa;gCACXmD,WAAWnE,OAAO+D;gCAClBpC;gCACAoF,WAAW,GAAGxF,eAAe,CAAC,EAAEmB,MAAMG,IAAI,EAAE;gCAC5CO,OAAOqD;4BACT;wBACF,OAAO;4BACL,kCAAkC;4BAClCzF,aAAa;gCACXmD,WAAWnE,IACTC,GACE,AAAC6B,CAAAA,oBAAoBV,cAAcD,QAAQ6B,MAAM,CAACd,cAAc,AAAD,EAAGa,EAAE,EACpE0D,uBAAuBW,MAAM,GAE/BjH,KAAKsG,uBAAuBG,IAAI,EAAE,GAAGrF,iBAAiBmB,MAAMG,IAAI,EAAE;gCAEpElB;gCACAoF,WAAW,GAAGxF,eAAe,CAAC,EAAEmB,MAAMG,IAAI,EAAE;gCAC5CO,OAAOqD;4BACT;wBACF;wBAEArE,YAAY,CAAC,GAAGmE,kBAAkB,KAAK,CAAC,CAAC,GAAGE,uBAAuBG,IAAI;wBAEvE,IAAI1B;wBAEJ,IAAI,OAAOxC,MAAMoE,UAAU,KAAK,UAAU;4BACxC,MAAME,qBAAqB7F,QAAQmC,OAAO,CAACqD,WAAW,CAACjE,MAAMoE,UAAU,CAAC,CAACvD,MAAM;4BAE/ET,eAAe3B,QAAQyC,YAAY,CAACC,GAAG,CAACpD,YAAYuG,mBAAmB/B,IAAI;4BAE3E,oCAAoC;4BACpCiC,qBAAqBF,mBAAmB5C,eAAe;4BACrD,CAAA,EAAEc,aAAa,EAAE,GAAGjE,cAAc;gCAAEE;gCAASmB,WAAWQ;4BAAa,EAAC;4BAExEnB,MAAMuC,IAAI,CAAC;gCACTC,WAAWlE,GAAGiF,cAAcnC,EAAE,EAAE0D,sBAAsB,CAAC,GAAG/D,MAAMoE,UAAU,CAAC,EAAE,CAAC,CAAC;gCAC/E1D,OAAO8B;4BACT;4BAEA,IAAIkB,sBAAsB,MAAMA,sBAAsB,MAAM;gCAC1D,OAAO;oCACLnD,YAAY,GAAGP,MAAMoE,UAAU,CAAC,EAAE,CAAC;oCACnCrF;oCACAiB;oCACAU,OAAOqD;gCACT;4BACF;wBACF,OAAO,IAAIL,sBAAsB,SAAS;4BACxC,MAAM0B,kCAAkCpF,MAAMoE,UAAU,CAACzB,IAAI,CAC3D,CAACyB,aAAe,CAAC,CAAC3F,QAAQmC,OAAO,CAACqD,WAAW,CAACG,WAAW,CAACiB,YAAY;4BAGxE,MAAMC,UAAkCtF,MAAMoE,UAAU,CACrDmB,GAAG,CAAC,CAACnB;gCACJ,IAAI3D,SACFhC,QAAQgC,MAAM,KAAK,SAAS,SAAS;gCAEvC,MAAM,EAAE4E,YAAY,EAAE,GAAG5G,QAAQmC,OAAO,CAACqD,WAAW,CAACG,WAAW;gCAEhE,IAAIiB,cAAc;oCAChB5E,SAAS4E;gCACX;gCAEA,MAAMG,mBAAmB/E,WAAW,UAAUA,WAAW;gCAEzD,yEAAyE;gCACzE,sGAAsG;gCACtG,IAAI,OAAOX,UAAU,YAAY0F,kBAAkB;oCACjD,OAAO;gCACT;gCAEA,IACExD,MAAMC,OAAO,CAACnC,UACdA,MAAM2F,KAAK,CAAC,CAACC,MAAQ,OAAOA,QAAQ,aACpCF,kBACA;oCACA,OAAO;gCACT;gCAEA,mHAAmH;gCACnH,uCAAuC;gCACvC,iHAAiH;gCACjH,IACE1F,SACA,CAACkC,MAAMC,OAAO,CAACnC,UACfW,WAAW,UACX2E,iCACA;oCACA,IAAI,CAACnH,aAAa6B,QAAQ;wCACxB,OAAO;oCACT;gCACF;gCAEA,IACEkC,MAAMC,OAAO,CAACnC,UACdW,WAAW,UACX2E,mCACA,CAACtF,MAAM6C,IAAI,CAAC,CAAC+C,MAAQzH,aAAayH,OAClC;oCACA,OAAO;gCACT;gCAEA,MAAM7B,oBAAoBpF,QAAQyC,YAAY,CAACC,GAAG,CAChDpD,YAAYU,QAAQmC,OAAO,CAACqD,WAAW,CAACG,WAAW,CAACvD,MAAM,CAAC0B,IAAI;gCAGjE,OAAO;oCACL9B;oCACA8C,WAAW7F,IAAIiI,GAAG,CAAC,CAAC,CAAC,EAAEV,2BAA2B,GAAG,EAAEpB,kBAAkB,IAAI,CAAC;gCAChF;4BACF,GACC+B,MAAM,CAACC;4BAEV,OAAO;gCACLP;gCACAvG;gCACAiB;gCACAU,OAAOqD;4BACT;wBACF,OAAO,IAAIL,sBAAsB,cAAc;4BAC7C,MAAMU,aAAapC,MAAMC,OAAO,CAACjC,MAAMoE,UAAU,IAC7CpE,MAAMoE,UAAU,GAChB;gCAACpE,MAAMoE,UAAU;6BAAC;4BAEtB,OAAO;gCACLrF;gCACAiB;gCACAyC,yBAAyB,CAACiD;oCACxB,MAAMI,kBAAkB1B,WAAWnE,IAAI,CAAC,CAAC8F,WAAaA,aAAaL;oCACnE,IAAII,iBAAiB;wCACnB,OAAO,GAAGA,gBAAgB,EAAE,CAAC;oCAC/B;oCACA,OAAOE;gCACT;gCACAtF,OAAOqD;4BACT;wBACF,OAAO,IAAI7F,0BAA0B4B,QAAQ;4BAC3C,MAAM,EAAEsE,UAAU,EAAE,GAAGtE;4BAEvB,MAAM+D,oBAAoBpF,QAAQyC,YAAY,CAACC,GAAG,CAChDpD,YAAYU,QAAQmC,OAAO,CAACqD,WAAW,CAACG,WAAW,CAACvD,MAAM,CAAC0B,IAAI;4BAGjE,OAAO;gCACLxD;gCACAiB;gCACAuD,WAAW7F,IAAIiI,GAAG,CAAC,CAAC,CAAC,EAAEV,2BAA2B,GAAG,EAAEpB,kBAAkB,IAAI,CAAC;gCAC9EnD,OAAOqD;4BACT;wBACF,OAAO,IAAIjE,UAAU1B,gBAAgB;4BACnC,MAAM6H,MAA2B,CAAC;4BAElCjG,MAAMoE,UAAU,CAAClC,OAAO,CAAC,CAACkC;gCACxB,MAAMP,oBAAoBpF,QAAQyC,YAAY,CAACC,GAAG,CAChDpD,YAAYU,QAAQmC,OAAO,CAACqD,WAAW,CAACG,WAAW,CAACvD,MAAM,CAAC0B,IAAI;gCAGjE0D,GAAG,CAAC7B,WAAW,GAAG1G,IAAIiI,GAAG,CAAC,CAAC,CAAC,EAAEV,2BAA2B,GAAG,EAAEpB,kBAAkB,IAAI,CAAC;4BACvF;4BAEA,IAAIN,YAAYpF,gBAAgBM,SAASwH;4BACzC,IAAIxH,QAAQ0B,IAAI,KAAK,YAAY;gCAC/BoD,YAAY7F,GAAG,CAAC,EAAE6F,UAAU,MAAM,CAAC;4BACrC;4BAEA,OAAO;gCACLxE;gCACAiB;gCACAuD;gCACA7C,OAAOqD;4BACT;wBACF,OAAO;4BACL,MAAM,IAAIpG,SAAS;wBACrB;wBAEA,OAAOa,uBAAuB;4BAC5BC;4BACAC,YAAY8D;4BACZ7D,gBAAgB+E;4BAChB3E;4BACA,oFAAoF;4BACpFC,QAAQwF;4BACRvF;4BACAC;4BACAG,mBAAmB;4BACnBC,cAAcA,aAAasC,KAAK,CAAC;4BACjCpC,eAAeY;4BACfV;4BACAC;4BACAC,WAAWQ;4BACXN;wBACF;oBACF,OAAO,IACLR,aAAa+D,MAAM,GAAG,KACtB,CAAE/D,CAAAA,aAAa+D,MAAM,KAAK,KAAK/D,YAAY,CAAC,EAAE,KAAK,IAAG,GACtD;wBACA,uBAAuB;wBACvB,MAAMiB,aAAa,GAAG3B,eAAeoB,MAAMG,IAAI,EAAE;wBACjD,MAAMC,eAAe3B,QAAQyC,YAAY,CAACC,GAAG,CAC3CpD,YAAYU,QAAQmC,OAAO,CAACqD,WAAW,CAACjE,MAAMoE,UAAU,CAAC,CAACvD,MAAM,CAAC0B,IAAI;wBAEvE,MAAM,EAAEC,aAAa,EAAE,GAAGjE,cAAc;4BAAEE;4BAASmB,WAAWQ;wBAAa;wBAE3E,IAAIO,oBAAoBlC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;4BAC3D,MAAM,EAAE0B,eAAe0D,gBAAgB,EAAE,GAAG3H,cAAc;gCACxDE;gCACAmB,WAAW,GAAGJ,gBAAgBf,QAAQ+E,aAAa,EAAE;4BACvD;4BAEA,MAAM2C,YAAY;gCAAC5I,GAAG2I,iBAAiB5E,SAAS,EAAE7C,QAAQ6B,MAAM,CAACd,cAAc,CAACa,EAAE;6BAAE;4BAEpF,IAAIV,cAAc;gCAChBD,aAAa6B,OAAO,GAAG2E,iBAAiB3E,OAAO;4BACjD;4BAEA,IAAIrC,WAAW,OAAO;gCACpBiH,UAAU3E,IAAI,CAACjE,GAAG2I,iBAAiB3E,OAAO,EAAErC;4BAC9C;4BAEA,MAAMkH,eAAe3H,QAAQ6B,MAAM,CAAC,GAAGd,gBAAgBf,QAAQ+E,aAAa,EAAE,CAAC;4BAE/ElF,aAAa;gCACXmD,WAAWnE,OAAO6I;gCAClBlH;gCACAyB,OAAO0F;4BACT;4BAEAnH,MAAMuC,IAAI,CAAC;gCACTC,WAAWlE,GAAG6I,YAAY,CAAC7F,WAAW,EAAEiC,cAAcnC,EAAE;gCACxDK,OAAO8B;4BACT;wBACF,OAAO;4BACLvD,MAAMuC,IAAI,CAAC;gCACTC,WAAWlE,GACTiF,cAAcnC,EAAE,EAChB3B,aAAaA,UAAU,CAAC6B,WAAW,GAAG9B,QAAQ6B,MAAM,CAACV,UAAU,CAACW,WAAW;gCAE7EG,OAAO8B;4BACT;wBACF;wBAEA,OAAOhE,uBAAuB;4BAC5BC;4BACAC,YAAY8D;4BACZ7D,gBAAgB+E;4BAChB7E,gBAAgB;4BAChBE;4BACAC,QAAQP,QAAQmC,OAAO,CAACqD,WAAW,CAACjE,MAAMoE,UAAU,CAAC,CAACvD,MAAM,CAACa,eAAe;4BAC5EzC;4BACAC;4BACAG,mBAAmBA,qBAAqBW,MAAM2B,SAAS;4BACvDrC,cAAcA,aAAasC,KAAK,CAAC;4BACjClC;4BACAE,WAAWQ;4BACXN;wBACF;oBACF;oBAEA;gBACF;YAEA,KAAK;gBAAU;oBACb,IAAIE,MAAM4D,OAAO,EAAE;wBACjB,MAAMxD,eAAe3B,QAAQyC,YAAY,CAACC,GAAG,CAC3C,GAAGvB,UAAU,CAAC,EAAEC,kBAAkB9B,YAAYiC,MAAMG,IAAI,GAAG;wBAG7D,MAAMkG,WAAW,AAAC3H,CAAAA,cAAcD,QAAQ6B,MAAM,CAACV,UAAU,AAAD,EAAGS,EAAE;wBAC7D,IAAInB,UAAUyB,oBAAoBlC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;4BACrE,MAAMO,aAAa;gCACjB9D,GAAG8I,UAAU5H,QAAQ6B,MAAM,CAACF,aAAa,CAACsE,MAAM;gCAChDnH,GAAGkB,QAAQ6B,MAAM,CAACF,aAAa,CAACmB,OAAO,EAAErC;6BAC1C;4BAED,IAAIA,WAAW,OAAO;gCACpBmC,WAAWG,IAAI,CAACjE,GAAGkB,QAAQ6B,MAAM,CAACF,aAAa,CAACmB,OAAO,EAAErC;4BAC3D;4BAEAZ,aAAa;gCACXmD,WAAWnE,OAAO+D;gCAClBpC;gCACAyB,OAAOjC,QAAQ6B,MAAM,CAACF,aAAa;4BACrC;wBACF,OAAO;4BACL9B,aAAa;gCACXmD,WAAWlE,GAAG8I,UAAU5H,QAAQ6B,MAAM,CAACF,aAAa,CAACsE,MAAM;gCAC3DzF;gCACAyB,OAAOjC,QAAQ6B,MAAM,CAACF,aAAa;4BACrC;wBACF;wBAEA,OAAO;4BACLG,YAAY;4BACZxB;4BACAiB;4BACAU,OAAOjC,QAAQ6B,MAAM,CAACF,aAAa;wBACrC;oBACF;oBACA;gBACF;YAEA,KAAK;gBAAO;oBACV,IAAItC,WAAWkC,QAAQ;wBACrB,OAAOxB,uBAAuB;4BAC5BC;4BACAC;4BACAC;4BACAC,cAAc,GAAGA,eAAeoB,MAAMG,IAAI,CAAC,CAAC,CAAC;4BAC7CtB,gBAAgB,GAAGA,iBAAiBmB,MAAMG,IAAI,CAAC,CAAC,CAAC;4BACjDpB;4BACAC,QAAQgB,MAAM0B,eAAe;4BAC7BzC;4BACAC;4BACAG,mBAAmBA,qBAAqBW,MAAM2B,SAAS;4BACvDrC,cAAcA,aAAasC,KAAK,CAAC;4BACjCpC;4BACAE;4BACAC;4BACAC,WAAWQ;4BACXP,iBAAiB,GAAGA,kBAAkB9B,YAAYiC,MAAMG,IAAI,EAAE,CAAC,CAAC;4BAChEL;wBACF;oBACF;oBACA,OAAOtB,uBAAuB;wBAC5BC;wBACAC;wBACAC;wBACAC;wBACAC;wBACAE;wBACAC,QAAQgB,MAAM0B,eAAe;wBAC7BzC;wBACAC;wBACAG,mBAAmBA,qBAAqBW,MAAM2B,SAAS;wBACvDrC,cAAcA,aAAasC,KAAK,CAAC;wBACjCpC;wBACAE;wBACAC;wBACAC,WAAWQ;wBACXP;wBACAC;oBACF;gBACF;YAEA;gBAAS;oBAEP;gBACF;QACF;QAEA,IAAIwG,WAAW7H,QAAQ6B,MAAM,CAACF,aAAa;QAE3C,IAAIO,oBAAoBlC,QAAQmC,OAAO,CAACC,MAAM,CAACC,YAAY,EAAE;YAC3D,yEAAyE;YACzE,yDAAyD;YACzD,MAAMyF,cAAc7H,cAAcD,QAAQ6B,MAAM,CAACV,UAAU;YAC3DQ,eAAe,GAAGR,YAAYnB,QAAQ+E,aAAa,EAAE;YAErD8C,WAAW7H,QAAQ6B,MAAM,CAACF,aAAa;YAEvC,IAAIqB,YAAYlE,GAAGgJ,YAAYlG,EAAE,EAAEiG,SAAShF,SAAS;YAErD,IAAIpC,WAAW,OAAO;gBACpBuC,YAAYnE,IAAImE,WAAWlE,GAAG+I,SAAS/E,OAAO,EAAErC;YAClD;YAEA,IAAIS,cAAc;gBAChBD,aAAa6B,OAAO,GAAG+E,SAAS/E,OAAO;YACzC;YAEAjD,aAAa;gBACXmD;gBACAxC;gBACAyB,OAAO4F;YACT;YAEA5H,aAAasH;QACf;QAEA,MAAMQ,cAAc9H,cAAc4H;QAElC5G,YAAY,CAAC,GAAGU,aAAa,CAAC,EAAExB,eAAeoB,MAAMG,IAAI,EAAE,CAAC,GAC1DqG,WAAW,CAAC,GAAG5H,eAAeoB,MAAMG,IAAI,EAAE,CAAC;QAE7C,OAAO;YACLI,YAAY,GAAG3B,eAAeoB,MAAMG,IAAI,EAAE;YAC1CpB;YACAiB;YACAV;YACAoB,OAAO8F;QACT;IACF;IAEA,MAAM,IAAI7I,SAAS,CAAC,8BAA8B,EAAEoC,WAAW;AACjE,EAAC"}