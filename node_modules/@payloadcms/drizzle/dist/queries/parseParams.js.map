{"version":3,"sources":["../../src/queries/parseParams.ts"],"sourcesContent":["import type { SQL, Table } from 'drizzle-orm'\nimport type { FlattenedField, Operator, Sort, Where } from 'payload'\n\nimport { and, isNotNull, isNull, ne, notInArray, or, sql } from 'drizzle-orm'\nimport { PgUUID } from 'drizzle-orm/pg-core'\nimport { APIError, QueryError } from 'payload'\nimport { validOperatorSet } from 'payload/shared'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\nimport { isValidStringID } from '../utilities/isValidStringID.js'\nimport { DistinctSymbol } from '../utilities/rawConstraint.js'\nimport { buildAndOrConditions } from './buildAndOrConditions.js'\nimport { getTableColumnFromPath } from './getTableColumnFromPath.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\nexport type QueryContext = { rawSort?: SQL; sort: Sort }\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  context: QueryContext\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  parentIsLocalized: boolean\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  where: Where\n}\n\nexport function parseParams({\n  adapter,\n  aliasTable,\n  context,\n  fields,\n  joins,\n  locale,\n  parentIsLocalized,\n  selectFields,\n  selectLocale,\n  tableName,\n  where,\n}: Args): SQL {\n  let result: SQL\n  const constraints: SQL[] = []\n\n  if (typeof where === 'object' && Object.keys(where).length > 0) {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    for (const relationOrPath of Object.keys(where)) {\n      if (relationOrPath) {\n        const condition = where[relationOrPath]\n        let conditionOperator: typeof and | typeof or\n        if (relationOrPath.toLowerCase() === 'and') {\n          conditionOperator = and\n        } else if (relationOrPath.toLowerCase() === 'or') {\n          conditionOperator = or\n        }\n        if (Array.isArray(condition)) {\n          const builtConditions = buildAndOrConditions({\n            adapter,\n            aliasTable,\n            context,\n            fields,\n            joins,\n            locale,\n            parentIsLocalized,\n            selectFields,\n            selectLocale,\n            tableName,\n            where: condition,\n          })\n          if (builtConditions.length > 0) {\n            result = conditionOperator(...builtConditions)\n          }\n        } else {\n          // It's a path - and there can be multiple comparisons on a single path.\n          // For example - title like 'test' and title not equal to 'tester'\n          // So we need to loop on keys again here to handle each operator independently\n          const pathOperators = where[relationOrPath]\n          if (typeof pathOperators === 'object') {\n            for (let operator of Object.keys(pathOperators)) {\n              if (validOperatorSet.has(operator as Operator)) {\n                const val = where[relationOrPath][operator]\n\n                const {\n                  columnName,\n                  columns,\n                  constraints: queryConstraints,\n                  field,\n                  getNotNullColumnByValue,\n                  pathSegments,\n                  rawColumn,\n                  table,\n                } = getTableColumnFromPath({\n                  adapter,\n                  aliasTable,\n                  collectionPath: relationOrPath,\n                  fields,\n                  joins,\n                  locale,\n                  parentIsLocalized,\n                  pathSegments: relationOrPath.replace(/__/g, '.').split('.'),\n                  selectFields,\n                  selectLocale,\n                  tableName,\n                  value: val,\n                })\n\n                const resolvedColumn =\n                  rawColumn ||\n                  (aliasTable && tableName === getNameFromDrizzleTable(table)\n                    ? aliasTable[columnName]\n                    : table[columnName])\n\n                if (val === DistinctSymbol) {\n                  selectFields['_selected'] = resolvedColumn\n                  break\n                }\n\n                queryConstraints.forEach(({ columnName: col, table: constraintTable, value }) => {\n                  if (typeof value === 'string' && value.indexOf('%') > -1) {\n                    constraints.push(adapter.operators.like(constraintTable[col], value))\n                  } else {\n                    constraints.push(adapter.operators.equals(constraintTable[col], value))\n                  }\n                })\n\n                if (\n                  (['json', 'richText'].includes(field.type) ||\n                    (field.type === 'blocks' && adapter.blocksAsJSON)) &&\n                  Array.isArray(pathSegments) &&\n                  pathSegments.length > 1\n                ) {\n                  if (adapter.name === 'postgres') {\n                    const constraint = adapter.createJSONQuery({\n                      column: rawColumn || table[columnName],\n                      operator,\n                      pathSegments,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(constraint))\n                    break\n                  }\n\n                  const segments = pathSegments.slice(1)\n                  segments.unshift(table[columnName].name)\n\n                  if (field.type === 'richText') {\n                    // use the table name from the nearest join to handle blocks, arrays, etc. or use the tableName arg\n                    const jsonTable =\n                      joins.length === 0\n                        ? tableName\n                        : joins[joins.length - 1].table[\n                            Object.getOwnPropertySymbols(joins[joins.length - 1].table)[0]\n                          ]\n                    const jsonQuery = adapter.createJSONQuery({\n                      operator,\n                      pathSegments: segments,\n                      table: jsonTable,\n                      treatAsArray: ['children'],\n                      treatRootAsArray: true,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(jsonQuery))\n                    break\n                  }\n\n                  const jsonQuery = adapter.convertPathToJSONTraversal(pathSegments)\n                  const operatorKeys: Record<string, { operator: string; wildcard: string }> = {\n                    contains: { operator: 'like', wildcard: '%' },\n                    equals: { operator: '=', wildcard: '' },\n                    exists: { operator: val === true ? 'is not null' : 'is null', wildcard: '' },\n                    in: { operator: 'in', wildcard: '' },\n                    like: { operator: 'like', wildcard: '%' },\n                    not_equals: { operator: '<>', wildcard: '' },\n                    not_in: { operator: 'not in', wildcard: '' },\n                    not_like: { operator: 'not like', wildcard: '%' },\n                  }\n\n                  let formattedValue = val\n                  if (adapter.name === 'sqlite' && operator === 'equals' && !isNaN(val)) {\n                    formattedValue = val\n                  } else if (['in', 'not_in'].includes(operator) && Array.isArray(val)) {\n                    formattedValue = `(${val.map((v) => `${v}`).join(',')})`\n                  } else {\n                    formattedValue = `'${operatorKeys[operator].wildcard}${val}${operatorKeys[operator].wildcard}'`\n                  }\n                  if (operator === 'exists') {\n                    formattedValue = ''\n                  }\n\n                  let jsonQuerySelector = `${table[columnName].name}${jsonQuery}`\n\n                  if (adapter.name === 'sqlite' && operator === 'not_like') {\n                    jsonQuerySelector = `COALESCE(${table[columnName].name}${jsonQuery}, '')`\n                  }\n\n                  const rawSQLQuery = `${jsonQuerySelector} ${operatorKeys[operator].operator} ${formattedValue}`\n\n                  constraints.push(sql.raw(rawSQLQuery))\n\n                  break\n                }\n\n                if (getNotNullColumnByValue) {\n                  const columnName = getNotNullColumnByValue(val)\n                  if (columnName) {\n                    constraints.push(isNotNull(table[columnName]))\n                  } else {\n                    throw new QueryError([{ path: relationOrPath }])\n                  }\n                  break\n                }\n\n                if (\n                  operator === 'like' &&\n                  (field.type === 'number' ||\n                    field.type === 'relationship' ||\n                    field.type === 'upload' ||\n                    table[columnName].columnType === 'PgUUID')\n                ) {\n                  operator = 'equals'\n                }\n\n                if (operator === 'like') {\n                  constraints.push(\n                    and(\n                      ...val\n                        .split(' ')\n                        .map((word) => adapter.operators.like(table[columnName], `%${word}%`)),\n                    ),\n                  )\n                  break\n                }\n\n                const sanitizedQueryValue = sanitizeQueryValue({\n                  adapter,\n                  columns,\n                  field,\n                  isUUID: table?.[columnName] instanceof PgUUID,\n                  operator,\n                  relationOrPath,\n                  val,\n                })\n\n                if (sanitizedQueryValue === null) {\n                  break\n                }\n\n                const {\n                  columns: queryColumns,\n                  operator: queryOperator,\n                  value: queryValue,\n                } = sanitizedQueryValue\n\n                // Handle polymorphic relationships by value\n                if (queryColumns) {\n                  if (!queryColumns.length) {\n                    break\n                  }\n\n                  let wrapOperator = or\n\n                  if (queryValue === null && ['equals', 'not_equals'].includes(operator)) {\n                    if (operator === 'equals') {\n                      wrapOperator = and\n                    }\n\n                    constraints.push(\n                      wrapOperator(\n                        ...queryColumns.map(({ rawColumn }) =>\n                          operator === 'equals' ? isNull(rawColumn) : isNotNull(rawColumn),\n                        ),\n                      ),\n                    )\n                    break\n                  }\n\n                  if (['not_equals', 'not_in'].includes(operator)) {\n                    wrapOperator = and\n                  }\n\n                  constraints.push(\n                    wrapOperator(\n                      ...queryColumns.map(({ rawColumn, value }) =>\n                        adapter.operators[queryOperator](rawColumn, value),\n                      ),\n                    ),\n                  )\n\n                  break\n                }\n\n                if (queryOperator === 'not_equals' && queryValue !== null) {\n                  constraints.push(\n                    or(\n                      isNull(resolvedColumn),\n                      /* eslint-disable @typescript-eslint/no-explicit-any */\n                      ne<any>(resolvedColumn, queryValue),\n                    ),\n                  )\n                  break\n                }\n\n                if (\n                  (field.type === 'relationship' || field.type === 'upload') &&\n                  Array.isArray(queryValue) &&\n                  operator === 'not_in'\n                ) {\n                  constraints.push(\n                    sql`(${notInArray(table[columnName], queryValue)} OR\n                    ${table[columnName]}\n                    IS\n                    NULL)`,\n                  )\n\n                  break\n                }\n\n                if (operator === 'equals' && queryValue === null) {\n                  constraints.push(isNull(resolvedColumn))\n                  break\n                }\n\n                if (operator === 'not_equals' && queryValue === null) {\n                  constraints.push(isNotNull(resolvedColumn))\n                  break\n                }\n\n                if (field.type === 'point' && adapter.name === 'postgres') {\n                  switch (operator) {\n                    case 'intersects': {\n                      constraints.push(\n                        sql`ST_Intersects(${table[columnName]}, ST_GeomFromGeoJSON(${JSON.stringify(queryValue)}))`,\n                      )\n                      break\n                    }\n\n                    case 'near': {\n                      const [lng, lat, maxDistance, minDistance] = queryValue as number[]\n                      const geoConstraints: SQL[] = []\n\n                      if (typeof maxDistance === 'number' && !Number.isNaN(maxDistance)) {\n                        geoConstraints.push(\n                          sql`ST_DWithin(ST_Transform(${table[columnName]}, 3857), ST_Transform(ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326), 3857), ${maxDistance})`,\n                        )\n                      }\n\n                      if (typeof minDistance === 'number' && !Number.isNaN(minDistance)) {\n                        geoConstraints.push(\n                          sql`ST_Distance(ST_Transform(${table[columnName]}, 3857), ST_Transform(ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326), 3857)) >= ${minDistance}`,\n                        )\n                      }\n                      if (geoConstraints.length) {\n                        context.sort = relationOrPath\n                        context.rawSort = sql`${table[columnName]} <-> ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326)`\n                        constraints.push(and(...geoConstraints))\n                      }\n                      break\n                    }\n\n                    case 'within': {\n                      constraints.push(\n                        sql`ST_Within(${table[columnName]}, ST_GeomFromGeoJSON(${JSON.stringify(queryValue)}))`,\n                      )\n                      break\n                    }\n\n                    default:\n                      break\n                  }\n                  break\n                }\n\n                const orConditions: SQL<unknown>[] = []\n                let resolvedQueryValue = queryValue\n                if (\n                  operator === 'in' &&\n                  Array.isArray(queryValue) &&\n                  queryValue.some((v) => v === null)\n                ) {\n                  orConditions.push(isNull(resolvedColumn))\n                  resolvedQueryValue = queryValue.filter((v) => v !== null)\n                }\n\n                let constraint = adapter.operators[queryOperator](\n                  resolvedColumn,\n                  resolvedQueryValue,\n                )\n\n                if (\n                  adapter.limitedBoundParameters &&\n                  (operator === 'in' || operator === 'not_in') &&\n                  relationOrPath === 'id' &&\n                  Array.isArray(queryValue)\n                ) {\n                  let isInvalid = false\n                  for (const val of queryValue) {\n                    if (typeof val === 'number' || val === null) {\n                      continue\n                    }\n                    if (typeof val === 'string') {\n                      if (!isValidStringID(val)) {\n                        isInvalid = true\n                        break\n                      } else {\n                        continue\n                      }\n                    }\n                    isInvalid = true\n                    break\n                  }\n\n                  if (isInvalid) {\n                    throw new APIError(`Invalid ID value in ${JSON.stringify(queryValue)}`)\n                  }\n\n                  constraints.push(\n                    sql.raw(\n                      `${resolvedColumn.name} ${operator === 'in' ? 'IN' : 'NOT IN'} (${queryValue\n                        .map((e) => {\n                          if (e === null) {\n                            return `NULL`\n                          }\n\n                          if (typeof e === 'number') {\n                            return e\n                          }\n\n                          return `'${e}'`\n                        })\n                        .join(',')})`,\n                    ),\n                  )\n                  break\n                }\n\n                if (orConditions.length) {\n                  orConditions.push(constraint)\n                  constraint = or(...orConditions)\n                }\n                constraints.push(constraint)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (constraints.length > 0) {\n    if (result) {\n      result = and(result, ...constraints)\n    } else {\n      result = and(...constraints)\n    }\n  }\n  if (constraints.length === 1 && !result) {\n    ;[result] = constraints\n  }\n\n  return result\n}\n"],"names":["and","isNotNull","isNull","ne","notInArray","or","sql","PgUUID","APIError","QueryError","validOperatorSet","getNameFromDrizzleTable","isValidStringID","DistinctSymbol","buildAndOrConditions","getTableColumnFromPath","sanitizeQueryValue","parseParams","adapter","aliasTable","context","fields","joins","locale","parentIsLocalized","selectFields","selectLocale","tableName","where","result","constraints","Object","keys","length","relationOrPath","condition","conditionOperator","toLowerCase","Array","isArray","builtConditions","pathOperators","operator","has","val","columnName","columns","queryConstraints","field","getNotNullColumnByValue","pathSegments","rawColumn","table","collectionPath","replace","split","value","resolvedColumn","forEach","col","constraintTable","indexOf","push","operators","like","equals","includes","type","blocksAsJSON","name","constraint","createJSONQuery","column","raw","segments","slice","unshift","jsonTable","getOwnPropertySymbols","jsonQuery","treatAsArray","treatRootAsArray","convertPathToJSONTraversal","operatorKeys","contains","wildcard","exists","in","not_equals","not_in","not_like","formattedValue","isNaN","map","v","join","jsonQuerySelector","rawSQLQuery","path","columnType","word","sanitizedQueryValue","isUUID","queryColumns","queryOperator","queryValue","wrapOperator","JSON","stringify","lng","lat","maxDistance","minDistance","geoConstraints","Number","sort","rawSort","orConditions","resolvedQueryValue","some","filter","limitedBoundParameters","isInvalid","e"],"mappings":"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"}