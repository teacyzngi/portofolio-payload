{"version":3,"sources":["../../../src/sqlite/createJSONQuery/index.ts"],"sourcesContent":["import type { CreateJSONQueryArgs } from '../../types.js'\n\ntype FromArrayArgs = {\n  isRoot?: true\n  operator: string\n  pathSegments: string[]\n  table: string\n  treatAsArray?: string[]\n  value: boolean | number | string\n}\n\nconst fromArray = ({\n  isRoot,\n  operator,\n  pathSegments,\n  table,\n  treatAsArray,\n  value,\n}: FromArrayArgs) => {\n  const newPathSegments = pathSegments.slice(1)\n  const alias = `${pathSegments[isRoot ? 0 : 1]}_alias_${newPathSegments.length}`\n\n  return `EXISTS (\n    SELECT 1\n    FROM json_each(${table}.${pathSegments[0]}) AS ${alias}\n    WHERE ${createJSONQuery({\n      operator,\n      pathSegments: newPathSegments,\n      table: alias,\n      treatAsArray,\n      value,\n    })}\n  )`\n}\n\ntype CreateConstraintArgs = {\n  alias?: string\n  operator: string\n  pathSegments: string[]\n  treatAsArray?: string[]\n  value: boolean | number | string\n}\n\nconst createConstraint = ({\n  alias,\n  operator,\n  pathSegments,\n  value,\n}: CreateConstraintArgs): string => {\n  const newAlias = `${pathSegments[0]}_alias_${pathSegments.length - 1}`\n\n  if (operator === 'exists' && value === false) {\n    operator = 'not_exists'\n    value = true\n  } else if (operator === 'not_exists' && value === false) {\n    operator = 'exists'\n    value = true\n  }\n\n  if (operator === 'exists') {\n    if (pathSegments.length === 1) {\n      return `EXISTS (SELECT 1 FROM json_each(\"${pathSegments[0]}\") AS ${newAlias})`\n    }\n\n    return `EXISTS (\n      SELECT 1\n      FROM json_each(${alias}.value -> '${pathSegments[0]}') AS ${newAlias}\n      WHERE ${newAlias}.key = '${pathSegments[1]}'\n    )`\n  }\n\n  if (operator === 'not_exists') {\n    if (pathSegments.length === 1) {\n      return `NOT EXISTS (SELECT 1 FROM json_each(\"${pathSegments[0]}\") AS ${newAlias})`\n    }\n\n    return `NOT EXISTS (\n      SELECT 1\n      FROM json_each(${alias}.value -> '${pathSegments[0]}') AS ${newAlias}\n      WHERE ${newAlias}.key = '${pathSegments[1]}'\n    )`\n  }\n\n  let formattedValue = value\n  let formattedOperator = operator\n  if (['contains', 'like'].includes(operator)) {\n    formattedOperator = 'like'\n    formattedValue = `%${value}%`\n  } else if (['not_like', 'notlike'].includes(operator)) {\n    formattedOperator = 'not like'\n    formattedValue = `%${value}%`\n  } else if (operator === 'equals') {\n    formattedOperator = '='\n  }\n\n  if (pathSegments.length === 1) {\n    return `EXISTS (SELECT 1 FROM json_each(\"${pathSegments[0]}\") AS ${newAlias} WHERE ${newAlias}.value ${formattedOperator} '${formattedValue}')`\n  }\n\n  return `EXISTS (\n  SELECT 1\n  FROM json_each(${alias}.value -> '${pathSegments[0]}') AS ${newAlias}\n  WHERE COALESCE(${newAlias}.value ->> '${pathSegments[1]}', '') ${formattedOperator} '${formattedValue}'\n  )`\n}\n\nexport const createJSONQuery = ({\n  column,\n  operator,\n  pathSegments,\n  rawColumn,\n  table,\n  treatAsArray,\n  treatRootAsArray,\n  value,\n}: CreateJSONQueryArgs): string => {\n  if ((operator === 'in' || operator === 'not_in') && Array.isArray(value)) {\n    let sql = ''\n    for (const [i, v] of value.entries()) {\n      sql = `${sql}${createJSONQuery({ column, operator: operator === 'in' ? 'equals' : 'not_equals', pathSegments, rawColumn, table, treatAsArray, treatRootAsArray, value: v })} ${i === value.length - 1 ? '' : ` ${operator === 'in' ? 'OR' : 'AND'} `}`\n    }\n    return sql\n  }\n\n  if (treatAsArray?.includes(pathSegments[1]) && table) {\n    return fromArray({\n      operator,\n      pathSegments,\n      table,\n      treatAsArray,\n      value: value as CreateConstraintArgs['value'],\n    })\n  }\n\n  return createConstraint({\n    alias: table,\n    operator,\n    pathSegments,\n    treatAsArray,\n    value: value as CreateConstraintArgs['value'],\n  })\n}\n"],"names":["fromArray","isRoot","operator","pathSegments","table","treatAsArray","value","newPathSegments","slice","alias","length","createJSONQuery","createConstraint","newAlias","formattedValue","formattedOperator","includes","column","rawColumn","treatRootAsArray","Array","isArray","sql","i","v","entries"],"mappings":"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"}