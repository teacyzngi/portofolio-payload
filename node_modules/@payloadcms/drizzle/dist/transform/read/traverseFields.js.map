{"version":3,"sources":["../../../src/transform/read/traverseFields.ts"],"sourcesContent":["import type { FlattenedBlock, FlattenedField, JoinQuery, SanitizedConfig } from 'payload'\n\nimport { fieldIsVirtual, fieldShouldBeLocalized } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { BlocksMap } from '../../utilities/createBlocksMap.js'\n\nimport { getArrayRelationName } from '../../utilities/getArrayRelationName.js'\nimport { resolveBlockTableName } from '../../utilities/validateExistingBlockIsIdentical.js'\nimport { transformHasManyNumber } from './hasManyNumber.js'\nimport { transformHasManyText } from './hasManyText.js'\nimport { transformRelationship } from './relationship.js'\n\ntype TraverseFieldsArgs = {\n  /**\n   * The DB adapter\n   */\n  adapter: DrizzleAdapter\n  /**\n   * Pre-formatted blocks map\n   */\n  blocks: BlocksMap\n  /**\n   * The full Payload config\n   */\n  config: SanitizedConfig\n  currentTableName: string\n  /**\n   * The data reference to be mutated within this recursive function\n   */\n  dataRef: Record<string, unknown>\n  /**\n   * Data that needs to be removed from the result after all fields have populated\n   */\n  deletions: (() => void)[]\n  /**\n   * Column prefix can be built up by group and named tab fields\n   */\n  fieldPrefix: string\n  /**\n   * An array of Payload fields to traverse\n   */\n  fields: FlattenedField[]\n  /**\n   *\n   */\n  joinQuery?: JoinQuery\n  /**\n   * All hasMany number fields, as returned by Drizzle, keyed on an object by field path\n   */\n  numbers: Record<string, Record<string, unknown>[]>\n  parentIsLocalized: boolean\n  /**\n   * The current field path (in dot notation), used to merge in relationships\n   */\n  path: string\n  /**\n   * All related documents, as returned by Drizzle, keyed on an object by field path\n   */\n  relationships: Record<string, Record<string, unknown>[]>\n  /**\n   * Data structure representing the nearest table from db\n   */\n  table: Record<string, unknown>\n  tablePath: string\n  /**\n   * All hasMany text fields, as returned by Drizzle, keyed on an object by field path\n   */\n  texts: Record<string, Record<string, unknown>[]>\n  topLevelTableName: string\n  /**\n   * Set to a locale if this group of fields is within a localized array or block.\n   */\n  withinArrayOrBlockLocale?: string\n}\n\n// Traverse fields recursively, transforming data\n// for each field type into required Payload shape\nexport const traverseFields = <T extends Record<string, unknown>>({\n  adapter,\n  blocks,\n  config,\n  currentTableName,\n  dataRef,\n  deletions,\n  fieldPrefix,\n  fields,\n  joinQuery,\n  numbers,\n  parentIsLocalized,\n  path,\n  relationships,\n  table,\n  tablePath,\n  texts,\n  topLevelTableName,\n  withinArrayOrBlockLocale,\n}: TraverseFieldsArgs): T => {\n  const sanitizedPath = path ? `${path}.` : path\n  const localeCodes =\n    adapter.payload.config.localization && adapter.payload.config.localization.localeCodes\n\n  const formatted = fields.reduce((result, field) => {\n    if (fieldIsVirtual(field)) {\n      return result\n    }\n\n    const fieldName = `${fieldPrefix || ''}${field.name}`\n    let fieldData = table[fieldName]\n    const localizedFieldData = {}\n    const valuesToTransform: {\n      ref: Record<string, unknown>\n      table: Record<string, unknown>\n    }[] = []\n\n    if (fieldPrefix) {\n      deletions.push(() => delete table[fieldName])\n    }\n\n    const isLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    if (field.type === 'array') {\n      const arrayTableName = adapter.tableNameMap.get(\n        `${currentTableName}_${tablePath}${toSnakeCase(field.name)}`,\n      )\n\n      fieldData = table[getArrayRelationName({ field, path: fieldName, tableName: arrayTableName })]\n\n      if (Array.isArray(fieldData)) {\n        if (isLocalized) {\n          result[field.name] = fieldData.reduce((arrayResult, row) => {\n            if (typeof row._locale === 'string') {\n              if (!arrayResult[row._locale]) {\n                arrayResult[row._locale] = []\n              }\n              const locale = row._locale\n              const data = {}\n              delete row._locale\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n\n              const rowResult = traverseFields<T>({\n                adapter,\n                blocks,\n                config,\n                currentTableName: arrayTableName,\n                dataRef: data,\n                deletions,\n                fieldPrefix: '',\n                fields: field.flattenedFields,\n                numbers,\n                parentIsLocalized: parentIsLocalized || field.localized,\n                path: `${sanitizedPath}${field.name}.${row._order - 1}`,\n                relationships,\n                table: row,\n                tablePath: '',\n                texts,\n                topLevelTableName,\n                withinArrayOrBlockLocale: locale,\n              })\n\n              if ('_order' in rowResult) {\n                delete rowResult._order\n              }\n\n              arrayResult[locale].push(rowResult)\n            }\n\n            return arrayResult\n          }, {})\n        } else {\n          result[field.name] = fieldData.reduce((acc, row, i) => {\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n\n            if ('_order' in row) {\n              delete row._order\n            }\n\n            if (\n              !withinArrayOrBlockLocale ||\n              (withinArrayOrBlockLocale && withinArrayOrBlockLocale === row._locale)\n            ) {\n              if (row._locale) {\n                delete row._locale\n              }\n\n              acc.push(\n                traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  currentTableName: arrayTableName,\n                  dataRef: row,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: field.flattenedFields,\n                  numbers,\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  path: `${sanitizedPath}${field.name}.${i}`,\n                  relationships,\n                  table: row,\n                  tablePath: '',\n                  texts,\n                  topLevelTableName,\n                  withinArrayOrBlockLocale,\n                }),\n              )\n            }\n\n            return acc\n          }, [])\n        }\n      }\n\n      return result\n    }\n\n    if (field.type === 'blocks' && !adapter.blocksAsJSON) {\n      const blockFieldPath = `${sanitizedPath}${field.name}`\n      const blocksByPath = blocks[blockFieldPath]\n\n      if (Array.isArray(blocksByPath)) {\n        if (isLocalized) {\n          result[field.name] = {}\n\n          blocksByPath.forEach((row) => {\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n            if (typeof row._locale === 'string') {\n              if (!result[field.name][row._locale]) {\n                result[field.name][row._locale] = []\n              }\n              result[field.name][row._locale].push(row)\n              delete row._locale\n            }\n          })\n\n          Object.entries(result[field.name]).forEach(([locale, localizedBlocks]) => {\n            result[field.name][locale] = localizedBlocks.map((row) => {\n              const block =\n                adapter.payload.blocks[row.blockType] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (block) => typeof block !== 'string' && block.slug === row.blockType,\n                ) as FlattenedBlock | undefined)\n\n              const tableName = resolveBlockTableName(\n                block,\n                adapter.tableNameMap.get(`${topLevelTableName}_blocks_${toSnakeCase(block.slug)}`),\n              )\n\n              if (block) {\n                const blockResult = traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  currentTableName: tableName,\n                  dataRef: row,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: block.flattenedFields,\n                  numbers,\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  path: `${blockFieldPath}.${row._order - 1}`,\n                  relationships,\n                  table: row,\n                  tablePath: '',\n                  texts,\n                  topLevelTableName,\n                  withinArrayOrBlockLocale: locale,\n                })\n\n                delete blockResult._order\n                return blockResult\n              }\n\n              return {}\n            })\n          })\n        } else {\n          // Add locale-specific index to have a proper blockFieldPath for current locale\n          // because blocks can be in the same array for different locales!\n          if (withinArrayOrBlockLocale && config.localization) {\n            for (const locale of config.localization.localeCodes) {\n              let localeIndex = 0\n\n              for (let i = 0; i < blocksByPath.length; i++) {\n                const row = blocksByPath[i]\n                if (row._locale === locale) {\n                  row._index = localeIndex\n                  localeIndex++\n                }\n              }\n            }\n          }\n\n          result[field.name] = blocksByPath.reduce((acc, row, i) => {\n            delete row._order\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n\n            if (typeof row.blockType !== 'string') {\n              return acc\n            }\n\n            const block =\n              adapter.payload.blocks[row.blockType] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (block) => typeof block !== 'string' && block.slug === row.blockType,\n              ) as FlattenedBlock | undefined)\n\n            if (block) {\n              if (\n                !withinArrayOrBlockLocale ||\n                (withinArrayOrBlockLocale && withinArrayOrBlockLocale === row._locale)\n              ) {\n                if (row._locale) {\n                  delete row._locale\n                }\n                if (typeof row._index === 'number') {\n                  i = row._index\n                  delete row._index\n                }\n\n                const tableName = resolveBlockTableName(\n                  block,\n                  adapter.tableNameMap.get(\n                    `${topLevelTableName}_blocks_${toSnakeCase(block.slug)}`,\n                  ),\n                )\n\n                acc.push(\n                  traverseFields<T>({\n                    adapter,\n                    blocks,\n                    config,\n                    currentTableName: tableName,\n                    dataRef: row,\n                    deletions,\n                    fieldPrefix: '',\n                    fields: block.flattenedFields,\n                    numbers,\n                    parentIsLocalized: parentIsLocalized || field.localized,\n                    path: `${blockFieldPath}.${i}`,\n                    relationships,\n                    table: row,\n                    tablePath: '',\n                    texts,\n                    topLevelTableName,\n                    withinArrayOrBlockLocale,\n                  }),\n                )\n\n                return acc\n              }\n            } else {\n              acc.push({})\n            }\n\n            return acc\n          }, [])\n        }\n      }\n\n      return result\n    }\n\n    if (\n      (field.type === 'relationship' || field.type === 'upload') &&\n      (Array.isArray(field.relationTo) || field.hasMany)\n    ) {\n      const relationPathMatch = relationships[`${sanitizedPath}${field.name}`]\n\n      if (!relationPathMatch) {\n        if ('hasMany' in field && field.hasMany) {\n          if (isLocalized && config.localization && config.localization.locales) {\n            result[field.name] = {\n              [config.localization.defaultLocale]: [],\n            }\n          } else {\n            result[field.name] = []\n          }\n        }\n\n        return result\n      }\n\n      if (isLocalized) {\n        result[field.name] = {}\n        const relationsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n        relationPathMatch.forEach((row) => {\n          if (typeof row.locale === 'string') {\n            if (!relationsByLocale[row.locale]) {\n              relationsByLocale[row.locale] = []\n            }\n            relationsByLocale[row.locale].push(row)\n          }\n        })\n\n        Object.entries(relationsByLocale).forEach(([locale, relations]) => {\n          transformRelationship({\n            field,\n            locale,\n            ref: result,\n            relations,\n          })\n        })\n      } else {\n        transformRelationship({\n          field,\n          ref: result,\n          relations: relationPathMatch,\n          withinArrayOrBlockLocale,\n        })\n      }\n      return result\n    }\n\n    if (field.type === 'join') {\n      const { count, limit = field.defaultLimit ?? 10 } =\n        joinQuery?.[`${fieldPrefix.replaceAll('_', '.')}${field.name}`] || {}\n\n      // raw hasMany results from SQLite\n      if (typeof fieldData === 'string') {\n        fieldData = JSON.parse(fieldData)\n      }\n\n      let fieldResult:\n        | { docs: unknown[]; hasNextPage: boolean; totalDocs?: number }\n        | Record<string, { docs: unknown[]; hasNextPage: boolean; totalDocs?: number }>\n      if (Array.isArray(fieldData)) {\n        if (isLocalized && adapter.payload.config.localization) {\n          fieldResult = fieldData.reduce(\n            (joinResult, row) => {\n              if (typeof row.locale === 'string') {\n                joinResult[row.locale].docs.push(row.id)\n              }\n\n              return joinResult\n            },\n\n            // initialize with defaults so empty won't be undefined\n            adapter.payload.config.localization.localeCodes.reduce((acc, code) => {\n              acc[code] = {\n                docs: [],\n                hasNextPage: false,\n              }\n              return acc\n            }, {}),\n          )\n          Object.keys(fieldResult).forEach((locale) => {\n            fieldResult[locale].hasNextPage = fieldResult[locale].docs.length > limit\n            fieldResult[locale].docs = fieldResult[locale].docs.slice(0, limit)\n          })\n        } else {\n          const hasNextPage = limit !== 0 && fieldData.length > limit\n          fieldResult = {\n            docs: (hasNextPage ? fieldData.slice(0, limit) : fieldData).map(\n              ({ id, relationTo }) => {\n                if (relationTo) {\n                  return { relationTo, value: id }\n                }\n                return { id }\n              },\n            ),\n            hasNextPage,\n          }\n        }\n      }\n\n      if (count) {\n        const countPath = `${fieldName}_count`\n        if (typeof table[countPath] !== 'undefined') {\n          let value = Number(table[countPath])\n          if (Number.isNaN(value)) {\n            value = 0\n          }\n          fieldResult.totalDocs = value\n        }\n      }\n\n      result[field.name] = fieldResult\n      return result\n    }\n\n    if (field.type === 'text' && field?.hasMany) {\n      const textPathMatch = texts[`${sanitizedPath}${field.name}`]\n      if (!textPathMatch) {\n        result[field.name] =\n          isLocalized && localeCodes\n            ? Object.fromEntries(localeCodes.map((locale) => [locale, []]))\n            : []\n        return result\n      }\n\n      if (isLocalized) {\n        result[field.name] = {}\n        const textsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n        textPathMatch.forEach((row) => {\n          if (typeof row.locale === 'string') {\n            if (!textsByLocale[row.locale]) {\n              textsByLocale[row.locale] = []\n            }\n            textsByLocale[row.locale].push(row)\n          }\n        })\n\n        Object.entries(textsByLocale).forEach(([locale, texts]) => {\n          transformHasManyText({\n            field,\n            locale,\n            ref: result,\n            textRows: texts,\n          })\n        })\n      } else {\n        transformHasManyText({\n          field,\n          ref: result,\n          textRows: textPathMatch,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return result\n    }\n\n    if (field.type === 'number' && field.hasMany) {\n      const numberPathMatch = numbers[`${sanitizedPath}${field.name}`]\n      if (!numberPathMatch) {\n        result[field.name] =\n          isLocalized && localeCodes\n            ? Object.fromEntries(localeCodes.map((locale) => [locale, []]))\n            : []\n        return result\n      }\n\n      if (isLocalized) {\n        result[field.name] = {}\n        const numbersByLocale: Record<string, Record<string, unknown>[]> = {}\n\n        numberPathMatch.forEach((row) => {\n          if (typeof row.locale === 'string') {\n            if (!numbersByLocale[row.locale]) {\n              numbersByLocale[row.locale] = []\n            }\n            numbersByLocale[row.locale].push(row)\n          }\n        })\n\n        Object.entries(numbersByLocale).forEach(([locale, numbers]) => {\n          transformHasManyNumber({\n            field,\n            locale,\n            numberRows: numbers,\n            ref: result,\n          })\n        })\n      } else {\n        transformHasManyNumber({\n          field,\n          numberRows: numberPathMatch,\n          ref: result,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return result\n    }\n\n    if (field.type === 'select' && field.hasMany) {\n      if (Array.isArray(fieldData)) {\n        if (isLocalized) {\n          result[field.name] = fieldData.reduce((selectResult, row) => {\n            if (typeof row.locale === 'string') {\n              if (!selectResult[row.locale]) {\n                selectResult[row.locale] = []\n              }\n              selectResult[row.locale].push(row.value)\n            }\n\n            return selectResult\n          }, {})\n        } else {\n          let selectData = fieldData\n          if (withinArrayOrBlockLocale) {\n            selectData = selectData.filter(({ locale }) => locale === withinArrayOrBlockLocale)\n          }\n          result[field.name] = selectData.map(({ value }) => value)\n        }\n      }\n      return result\n    }\n\n    if (isLocalized && Array.isArray(table._locales)) {\n      if (!table._locales.length && localeCodes) {\n        localeCodes.forEach((_locale) => (table._locales as unknown[]).push({ _locale }))\n      }\n\n      table._locales.forEach((localeRow) => {\n        valuesToTransform.push({\n          ref: localizedFieldData,\n          table: {\n            ...table,\n            ...localeRow,\n          },\n        })\n      })\n    } else {\n      valuesToTransform.push({ ref: result, table })\n    }\n\n    valuesToTransform.forEach(({ ref, table }) => {\n      const fieldData = table[`${fieldPrefix || ''}${field.name}`]\n      const locale = table?._locale\n      let val = fieldData\n\n      switch (field.type) {\n        case 'date': {\n          if (typeof fieldData === 'string') {\n            val = new Date(fieldData).toISOString()\n          }\n\n          break\n        }\n\n        case 'group':\n        case 'tab': {\n          const groupFieldPrefix = `${fieldPrefix || ''}${field.name}_`\n          const groupData = {}\n          const locale = table._locale as string\n          const refKey = isLocalized && locale ? locale : field.name\n\n          if (isLocalized && locale) {\n            delete table._locale\n          }\n          ref[refKey] = traverseFields<Record<string, unknown>>({\n            adapter,\n            blocks,\n            config,\n            currentTableName,\n            dataRef: groupData as Record<string, unknown>,\n            deletions,\n            fieldPrefix: groupFieldPrefix,\n            fields: field.flattenedFields,\n            joinQuery,\n            numbers,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            path: `${sanitizedPath}${field.name}`,\n            relationships,\n            table,\n            tablePath: `${tablePath}${toSnakeCase(field.name)}_`,\n            texts,\n            topLevelTableName,\n            withinArrayOrBlockLocale: locale || withinArrayOrBlockLocale,\n          })\n\n          return\n        }\n\n        case 'number': {\n          if (typeof fieldData === 'string') {\n            val = Number.parseFloat(fieldData)\n          }\n\n          break\n        }\n\n        case 'point': {\n          if (typeof fieldData === 'string') {\n            val = JSON.parse(fieldData)\n          }\n\n          break\n        }\n\n        case 'relationship':\n        case 'upload': {\n          if (\n            val &&\n            typeof field.relationTo === 'string' &&\n            adapter.payload.collections[field.relationTo].customIDType === 'number'\n          ) {\n            val = Number(val)\n          }\n\n          break\n        }\n        case 'text': {\n          if (typeof fieldData === 'string') {\n            val = String(fieldData)\n          }\n\n          break\n        }\n\n        default: {\n          break\n        }\n      }\n      if (typeof locale === 'string') {\n        ref[locale] = val\n      } else {\n        result[field.name] = val\n      }\n    })\n\n    if (Object.keys(localizedFieldData).length > 0) {\n      result[field.name] = localizedFieldData\n    }\n\n    return result\n  }, dataRef)\n\n  if (Array.isArray(table._locales)) {\n    deletions.push(() => delete table._locales)\n  }\n\n  return formatted as T\n}\n"],"names":["fieldIsVirtual","fieldShouldBeLocalized","toSnakeCase","getArrayRelationName","resolveBlockTableName","transformHasManyNumber","transformHasManyText","transformRelationship","traverseFields","adapter","blocks","config","currentTableName","dataRef","deletions","fieldPrefix","fields","joinQuery","numbers","parentIsLocalized","path","relationships","table","tablePath","texts","topLevelTableName","withinArrayOrBlockLocale","sanitizedPath","localeCodes","payload","localization","formatted","reduce","result","field","fieldName","name","fieldData","localizedFieldData","valuesToTransform","push","isLocalized","type","arrayTableName","tableNameMap","get","tableName","Array","isArray","arrayResult","row","_locale","locale","data","_uuid","id","rowResult","flattenedFields","localized","_order","acc","i","blocksAsJSON","blockFieldPath","blocksByPath","forEach","Object","entries","localizedBlocks","map","block","blockType","blockReferences","find","slug","blockResult","localeIndex","length","_index","relationTo","hasMany","relationPathMatch","locales","defaultLocale","relationsByLocale","relations","ref","count","limit","defaultLimit","replaceAll","JSON","parse","fieldResult","joinResult","docs","code","hasNextPage","keys","slice","value","countPath","Number","isNaN","totalDocs","textPathMatch","fromEntries","textsByLocale","textRows","numberPathMatch","numbersByLocale","numberRows","selectResult","selectData","filter","_locales","localeRow","val","Date","toISOString","groupFieldPrefix","groupData","refKey","parseFloat","collections","customIDType","String"],"mappings":"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"}