{"version":3,"sources":["../src/migrateRefresh.ts"],"sourcesContent":["import {\n  commitTransaction,\n  createLocalReq,\n  getMigrations,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\n\nimport type { DrizzleAdapter } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\n/**\n * Run all migration down functions before running up\n */\nexport async function migrateRefresh(this: DrizzleAdapter) {\n  const { payload } = this\n  const migrationFiles = await readMigrationFiles({ payload })\n\n  const { existingMigrations, latestBatch } = await getMigrations({\n    payload,\n  })\n\n  if (!existingMigrations?.length) {\n    payload.logger.info({ msg: 'No migrations to rollback.' })\n    return\n  }\n\n  payload.logger.info({\n    msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`,\n  })\n\n  const req = await createLocalReq({}, payload)\n\n  // Reverse order of migrations to rollback\n  existingMigrations.reverse()\n\n  for (const migration of existingMigrations) {\n    try {\n      const migrationFile = migrationFiles.find((m) => m.name === migration.name)\n      if (!migrationFile) {\n        throw new Error(`Migration ${migration.name} not found locally.`)\n      }\n\n      payload.logger.info({ msg: `Migrating down: ${migration.name}` })\n      const start = Date.now()\n      await initTransaction(req)\n      const db = await getTransaction(this, req)\n      await migrationFile.down({ db, payload, req })\n      payload.logger.info({\n        msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)`,\n      })\n\n      const tableExists = await migrationTableExists(this, db)\n      if (tableExists) {\n        await payload.delete({\n          collection: 'payload-migrations',\n          req,\n          where: {\n            name: {\n              equals: migration.name,\n            },\n          },\n        })\n      }\n      await commitTransaction(req)\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      await migration.up({ payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          executed: true,\n        },\n        req,\n      })\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: parseError(err, `Error running migration ${migration.name}. Rolling back.`),\n      })\n      process.exit(1)\n    }\n  }\n}\n"],"names":["commitTransaction","createLocalReq","getMigrations","initTransaction","killTransaction","readMigrationFiles","getTransaction","migrationTableExists","parseError","migrateRefresh","payload","migrationFiles","existingMigrations","latestBatch","length","logger","info","msg","req","reverse","migration","migrationFile","find","m","name","Error","start","Date","now","db","down","tableExists","delete","collection","where","equals","err","error","process","exit","up","create","data","executed"],"mappings":"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"}