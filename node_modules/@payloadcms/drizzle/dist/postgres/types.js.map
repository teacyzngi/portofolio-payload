{"version":3,"sources":["../../src/postgres/types.ts"],"sourcesContent":["import type { DrizzleSnapshotJSON } from 'drizzle-kit/api'\nimport type {\n  ColumnBaseConfig,\n  ColumnDataType,\n  DrizzleConfig,\n  Relation,\n  Relations,\n  SQL,\n} from 'drizzle-orm'\nimport type { NodePgDatabase } from 'drizzle-orm/node-postgres'\nimport type {\n  ForeignKeyBuilder,\n  IndexBuilder,\n  PgColumn,\n  PgEnum,\n  pgEnum,\n  PgInsertOnConflictDoUpdateConfig,\n  PgSchema,\n  PgTableWithColumns,\n  UniqueConstraintBuilder,\n} from 'drizzle-orm/pg-core'\nimport type { PgTableFn } from 'drizzle-orm/pg-core/table'\nimport type { SQLiteColumn } from 'drizzle-orm/sqlite-core'\nimport type { Payload, PayloadRequest } from 'payload'\nimport type { ClientConfig, QueryResult } from 'pg'\n\nimport type { extendDrizzleTable, Operators } from '../index.js'\nimport type { BuildQueryJoinAliases, DrizzleAdapter, TransactionPg } from '../types.js'\n\nexport type BaseExtraConfig = Record<\n  string,\n  (cols: GenericColumns) => ForeignKeyBuilder | IndexBuilder | UniqueConstraintBuilder\n>\n\nexport type RelationMap = Map<\n  string,\n  {\n    localized: boolean\n    relationName?: string\n    target: string\n    type: 'many' | 'one'\n  }\n>\n\nexport type GenericColumn = PgColumn<\n  ColumnBaseConfig<ColumnDataType, string>,\n  Record<string, unknown>\n>\n\nexport type GenericColumns = {\n  [x: string]: GenericColumn\n}\n\nexport type GenericTable = PgTableWithColumns<{\n  columns: GenericColumns\n  dialect: string\n  name: string\n  schema: string\n}>\n\nexport type GenericEnum = PgEnum<[string, ...string[]]>\n\nexport type GenericRelation = Relations<string, Record<string, Relation<string>>>\n\nexport type PostgresDB = NodePgDatabase<Record<string, unknown>>\n\nexport type CountDistinct = (args: {\n  column?: PgColumn<any> | SQLiteColumn<any>\n  db: PostgresDB | TransactionPg\n  joins: BuildQueryJoinAliases\n  tableName: string\n  where: SQL\n}) => Promise<number>\n\nexport type DeleteWhere = (args: {\n  db: PostgresDB | TransactionPg\n  tableName: string\n  where: SQL\n}) => Promise<void>\n\nexport type DropDatabase = (args: { adapter: BasePostgresAdapter }) => Promise<void>\n\nexport type Execute<T> = (args: {\n  db?: PostgresDB | TransactionPg\n  drizzle?: PostgresDB\n  raw?: string\n  sql?: SQL<unknown>\n}) => Promise<QueryResult<Record<string, T>>>\n\nexport type Insert = (args: {\n  db: PostgresDB | TransactionPg\n  onConflictDoUpdate?: PgInsertOnConflictDoUpdateConfig<any>\n  tableName: string\n  values: Record<string, unknown> | Record<string, unknown>[]\n}) => Promise<Record<string, unknown>[]>\n\nexport type CreateDatabase = (args?: {\n  /**\n   * Name of a database, defaults to the current one\n   */\n  name?: string\n  /**\n   * Schema to create in addition to 'public'. Defaults from adapter.schemaName if exists.\n   */\n  schemaName?: string\n}) => Promise<boolean>\n\ntype Schema =\n  | {\n      enum: typeof pgEnum\n      table: PgTableFn<string>\n    }\n  | PgSchema\n\ntype PostgresSchema = {\n  enums: Record<string, GenericEnum>\n  relations: Record<string, GenericRelation>\n  tables: Record<string, PgTableWithColumns<any>>\n}\n\ntype PostgresSchemaHookArgs = {\n  adapter: PostgresDrizzleAdapter\n  extendTable: typeof extendDrizzleTable\n  schema: PostgresSchema\n}\n\nexport type PostgresSchemaHook = (\n  args: PostgresSchemaHookArgs,\n) => PostgresSchema | Promise<PostgresSchema>\n\nexport type BasePostgresAdapter = {\n  afterSchemaInit: PostgresSchemaHook[]\n  beforeSchemaInit: PostgresSchemaHook[]\n  countDistinct: CountDistinct\n  createDatabase: CreateDatabase\n  createExtensions: () => Promise<void>\n  defaultDrizzleSnapshot: DrizzleSnapshotJSON\n  deleteWhere: DeleteWhere\n  disableCreateDatabase: boolean\n  drizzle: PostgresDB\n  dropDatabase: DropDatabase\n  enums: Record<string, GenericEnum>\n  execute: Execute<unknown>\n  extensions: Record<string, boolean>\n  /**\n   * An object keyed on each table, with a key value pair where the constraint name is the key, followed by the dot-notation field name\n   * Used for returning properly formed errors from unique fields\n   */\n  fieldConstraints: Record<string, Record<string, string>>\n  idType: 'serial' | 'uuid'\n  initializing: Promise<void>\n  insert: Insert\n  localesSuffix?: string\n  logger: DrizzleConfig['logger']\n  operators: Operators\n  pgSchema: Schema\n  poolOptions?: ClientConfig\n  prodMigrations?: {\n    down: (args: MigrateDownArgs) => Promise<void>\n    name: string\n    up: (args: MigrateUpArgs) => Promise<void>\n  }[]\n  push: boolean\n  readReplicaOptions?: string[]\n  rejectInitializing: () => void\n  relations: Record<string, GenericRelation>\n  relationshipsSuffix?: string\n  resolveInitializing: () => void\n  schemaName?: string\n  sessions: {\n    [id: string]: {\n      db: PostgresDB | TransactionPg\n      reject: () => Promise<void>\n      resolve: () => Promise<void>\n    }\n  }\n  tableNameMap: Map<string, string>\n  tables: Record<string, GenericTable>\n  tablesFilter?: string[]\n  versionsSuffix?: string\n} & PostgresDrizzleAdapter\n\nexport type PostgresDrizzleAdapter = Omit<\n  DrizzleAdapter,\n  | 'countDistinct'\n  | 'deleteWhere'\n  | 'drizzle'\n  | 'dropDatabase'\n  | 'execute'\n  | 'insert'\n  | 'operators'\n  | 'relations'\n>\n\nexport type IDType = 'integer' | 'numeric' | 'uuid' | 'varchar'\n\nexport type MigrateUpArgs = {\n  /**\n   * The Postgres Drizzle instance that you can use to execute SQL directly within the current transaction.\n   * @example\n   * ```ts\n   * import { type MigrateUpArgs, sql } from '@payloadcms/db-postgres'\n   *\n   * export async function up({ db, payload, req }: MigrateUpArgs): Promise<void> {\n   *   const { rows: posts } = await db.execute(sql`SELECT * FROM posts`)\n   * }\n   * ```\n   */\n  db: PostgresDB\n  /**\n   * The Payload instance that you can use to execute Local API methods\n   * To use the current transaction you must pass `req` to arguments\n   * @example\n   * ```ts\n   * import { type MigrateUpArgs, sql } from '@payloadcms/db-postgres'\n   *\n   * export async function up({ db, payload, req }: MigrateUpArgs): Promise<void> {\n   *   const posts = await payload.find({ collection: 'posts', req })\n   * }\n   * ```\n   */\n  payload: Payload\n  /**\n   * The `PayloadRequest` object that contains the current transaction\n   */\n  req: PayloadRequest\n}\n\nexport type MigrateDownArgs = {\n  /**\n   * The Postgres Drizzle instance that you can use to execute SQL directly within the current transaction.\n   * @example\n   * ```ts\n   * import { type MigrateDownArgs, sql } from '@payloadcms/db-postgres'\n   *\n   * export async function down({ db, payload, req }: MigrateDownArgs): Promise<void> {\n   *   const { rows: posts } = await db.execute(sql`SELECT * FROM posts`)\n   * }\n   * ```\n   */\n  db: PostgresDB\n  /**\n   * The Payload instance that you can use to execute Local API methods\n   * To use the current transaction you must pass `req` to arguments\n   * @example\n   * ```ts\n   * import { type MigrateDownArgs } from '@payloadcms/db-postgres'\n   *\n   * export async function down({ db, payload, req }: MigrateDownArgs): Promise<void> {\n   *   const posts = await payload.find({ collection: 'posts', req })\n   * }\n   * ```\n   */\n  payload: Payload\n  /**\n   * The `PayloadRequest` object that contains the current transaction\n   */\n  req: PayloadRequest\n}\n"],"names":[],"mappings":"AAoOA,WA8BC"}