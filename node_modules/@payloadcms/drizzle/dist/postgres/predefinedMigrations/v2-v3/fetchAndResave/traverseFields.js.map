{"version":3,"sources":["../../../../../src/postgres/predefinedMigrations/v2-v3/fetchAndResave/traverseFields.ts"],"sourcesContent":["import type { FlattenedField } from 'payload'\n\ntype Args = {\n  doc: Record<string, unknown>\n  fields: FlattenedField[]\n  locale?: string\n  path: string\n  rows: Record<string, unknown>[]\n}\n\nexport const traverseFields = ({ doc, fields, locale, path, rows }: Args) => {\n  fields.forEach((field) => {\n    switch (field.type) {\n      case 'array': {\n        const rowData = doc?.[field.name]\n\n        if (field.localized && typeof rowData === 'object' && rowData !== null) {\n          Object.entries(rowData).forEach(([locale, localeRows]) => {\n            if (Array.isArray(localeRows)) {\n              localeRows.forEach((row, i) => {\n                return traverseFields({\n                  doc: row as Record<string, unknown>,\n                  fields: field.flattenedFields,\n                  locale,\n                  path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n                  rows,\n                })\n              })\n            }\n          })\n        }\n\n        if (Array.isArray(rowData)) {\n          rowData.forEach((row, i) => {\n            return traverseFields({\n              doc: row as Record<string, unknown>,\n              fields: field.flattenedFields,\n              path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n              rows,\n            })\n          })\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const rowData = doc?.[field.name]\n\n        if (field.localized && typeof rowData === 'object' && rowData !== null) {\n          Object.entries(rowData).forEach(([locale, localeRows]) => {\n            if (Array.isArray(localeRows)) {\n              localeRows.forEach((row, i) => {\n                // Can ignore string blocks, as those were added in v3 and don't need to be migrated\n                const matchedBlock = field.blocks.find(\n                  (block) => typeof block !== 'string' && block.slug === row.blockType,\n                )\n\n                if (matchedBlock) {\n                  return traverseFields({\n                    doc: row as Record<string, unknown>,\n                    fields: matchedBlock.flattenedFields,\n                    locale,\n                    path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n                    rows,\n                  })\n                }\n              })\n            }\n          })\n        }\n\n        if (Array.isArray(rowData)) {\n          rowData.forEach((row, i) => {\n            // Can ignore string blocks, as those were added in v3 and don't need to be migrated\n            const matchedBlock = field.blocks.find(\n              (block) => typeof block !== 'string' && block.slug === row.blockType,\n            )\n\n            if (matchedBlock) {\n              return traverseFields({\n                doc: row as Record<string, unknown>,\n                fields: matchedBlock.flattenedFields,\n                path: `${path ? `${path}.` : ''}${field.name}.${i}`,\n                rows,\n              })\n            }\n          })\n        }\n\n        break\n      }\n\n      case 'group':\n      case 'tab': {\n        const newPath = `${path ? `${path}.` : ''}${field.name}`\n        const newDoc = doc?.[field.name]\n\n        if (typeof newDoc === 'object' && newDoc !== null) {\n          if (field.localized) {\n            Object.entries(newDoc).forEach(([locale, localeDoc]) => {\n              return traverseFields({\n                doc: localeDoc,\n                fields: field.flattenedFields,\n                locale,\n                path: newPath,\n                rows,\n              })\n            })\n          } else {\n            return traverseFields({\n              doc: newDoc as Record<string, unknown>,\n              fields: field.flattenedFields,\n              path: newPath,\n              rows,\n            })\n          }\n        }\n\n        break\n      }\n\n      case 'relationship':\n      // falls through\n      case 'upload': {\n        if (typeof field.relationTo === 'string') {\n          if (field.type === 'upload' || !field.hasMany) {\n            const relationshipPath = `${path ? `${path}.` : ''}${field.name}`\n\n            if (field.localized) {\n              const matchedRelationshipsWithLocales = rows.filter(\n                (row) => row.path === relationshipPath,\n              )\n\n              if (matchedRelationshipsWithLocales.length && !doc[field.name]) {\n                doc[field.name] = {}\n              }\n\n              const newDoc = doc[field.name] as Record<string, unknown>\n\n              matchedRelationshipsWithLocales.forEach((localeRow) => {\n                if (typeof localeRow.locale === 'string') {\n                  const [, id] = Object.entries(localeRow).find(\n                    ([key, val]) =>\n                      val !== null && !['id', 'locale', 'order', 'parent_id', 'path'].includes(key),\n                  )\n\n                  newDoc[localeRow.locale] = id\n                }\n              })\n            } else {\n              const matchedRelationship = rows.find((row) => {\n                const matchesPath = row.path === relationshipPath\n\n                if (locale) {\n                  return matchesPath && locale === row.locale\n                }\n\n                return row.path === relationshipPath\n              })\n\n              if (matchedRelationship) {\n                const [, id] = Object.entries(matchedRelationship).find(\n                  ([key, val]) =>\n                    val !== null && !['id', 'locale', 'order', 'parent_id', 'path'].includes(key),\n                )\n\n                doc[field.name] = id\n              }\n            }\n          }\n        }\n        break\n      }\n    }\n  })\n}\n"],"names":["traverseFields","doc","fields","locale","path","rows","forEach","field","type","rowData","name","localized","Object","entries","localeRows","Array","isArray","row","i","flattenedFields","matchedBlock","blocks","find","block","slug","blockType","newPath","newDoc","localeDoc","relationTo","hasMany","relationshipPath","matchedRelationshipsWithLocales","filter","length","localeRow","id","key","val","includes","matchedRelationship","matchesPath"],"mappings":"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"}