{"version":3,"sources":["../src/types.ts"],"sourcesContent":["import type {\n  BasePostgresAdapter,\n  GenericEnum,\n  MigrateDownArgs,\n  MigrateUpArgs,\n  PostgresSchemaHook,\n} from '@payloadcms/drizzle/postgres'\nimport type { DrizzleAdapter } from '@payloadcms/drizzle/types'\nimport type { DrizzleConfig, ExtractTablesWithRelations } from 'drizzle-orm'\nimport type { NodePgDatabase } from 'drizzle-orm/node-postgres'\nimport type {\n  PgDatabase,\n  PgQueryResultHKT,\n  PgSchema,\n  PgTableFn,\n  PgTransactionConfig,\n  PgWithReplicas,\n} from 'drizzle-orm/pg-core'\nimport type { Pool, PoolConfig } from 'pg'\n\ntype PgDependency = typeof import('pg')\n\nexport type Args = {\n  /**\n   * Transform the schema after it's built.\n   * You can use it to customize the schema with features that aren't supported by Payload.\n   * Examples may include: composite indices, generated columns, vectors\n   */\n  afterSchemaInit?: PostgresSchemaHook[]\n  /**\n   * Enable this flag if you want to thread your own ID to create operation data, for example:\n   * ```ts\n   * // doc created with id 1\n   * const doc = await payload.create({ collection: 'posts', data: {id: 1, title: \"my title\"}})\n   * ```\n   */\n  allowIDOnCreate?: boolean\n  /**\n   * Transform the schema before it's built.\n   * You can use it to preserve an existing database schema and if there are any collissions Payload will override them.\n   * To generate Drizzle schema from the database, see [Drizzle Kit introspection](https://orm.drizzle.team/kit-docs/commands#introspect--pull)\n   */\n  beforeSchemaInit?: PostgresSchemaHook[]\n  /**\n   * Store blocks as JSON column instead of storing them in relational structure.\n   */\n  blocksAsJSON?: boolean\n  /**\n   * Pass `true` to disale auto database creation if it doesn't exist.\n   * @default false\n   */\n  disableCreateDatabase?: boolean\n  extensions?: string[]\n  /** Generated schema from payload generate:db-schema file path */\n  generateSchemaOutputFile?: string\n  idType?: 'serial' | 'uuid'\n  localesSuffix?: string\n  logger?: DrizzleConfig['logger']\n  migrationDir?: string\n  pg?: PgDependency\n  pool: PoolConfig\n  prodMigrations?: {\n    down: (args: MigrateDownArgs) => Promise<void>\n    name: string\n    up: (args: MigrateUpArgs) => Promise<void>\n  }[]\n  push?: boolean\n  readReplicas?: string[]\n  relationshipsSuffix?: string\n  /**\n   * The schema name to use for the database\n   *\n   * @experimental This only works when there are not other tables or enums of the same name in the database under a different schema. Awaiting fix from Drizzle.\n   */\n  schemaName?: string\n  tablesFilter?: string[]\n  transactionOptions?: false | PgTransactionConfig\n  versionsSuffix?: string\n}\n\nexport interface GeneratedDatabaseSchema {\n  schemaUntyped: Record<string, unknown>\n}\n\ntype ResolveSchemaType<T> = 'schema' extends keyof T\n  ? T['schema']\n  : GeneratedDatabaseSchema['schemaUntyped']\n\ntype Drizzle =\n  | NodePgDatabase<ResolveSchemaType<GeneratedDatabaseSchema>>\n  | PgWithReplicas<NodePgDatabase<ResolveSchemaType<GeneratedDatabaseSchema>>>\n\nexport type PostgresAdapter = {\n  drizzle: Drizzle\n  pg: PgDependency\n  pool: Pool\n  poolOptions: PoolConfig\n} & BasePostgresAdapter\n\ndeclare module 'payload' {\n  export interface DatabaseAdapter\n    extends Omit<Args, 'idType' | 'logger' | 'migrationDir' | 'pool'>,\n      DrizzleAdapter {\n    afterSchemaInit: PostgresSchemaHook[]\n\n    beforeSchemaInit: PostgresSchemaHook[]\n    beginTransaction: (options?: PgTransactionConfig) => Promise<null | number | string>\n    drizzle: Drizzle\n    enums: Record<string, GenericEnum>\n    extensions: Record<string, boolean>\n    /**\n     * An object keyed on each table, with a key value pair where the constraint name is the key, followed by the dot-notation field name\n     * Used for returning properly formed errors from unique fields\n     */\n    fieldConstraints: Record<string, Record<string, string>>\n    idType: Args['idType']\n    initializing: Promise<void>\n    localesSuffix?: string\n    logger: DrizzleConfig['logger']\n    /** Optionally inject your own node-postgres. This is required if you wish to instrument the driver with @payloadcms/plugin-sentry. */\n    pg?: PgDependency\n    pgSchema?: { table: PgTableFn } | PgSchema\n    pool: Pool\n    poolOptions: Args['pool']\n    prodMigrations?: {\n      down: (args: MigrateDownArgs) => Promise<void>\n      name: string\n      up: (args: MigrateUpArgs) => Promise<void>\n    }[]\n    push: boolean\n    rejectInitializing: () => void\n    relationshipsSuffix?: string\n    resolveInitializing: () => void\n    schema: Record<string, unknown>\n    schemaName?: Args['schemaName']\n    tableNameMap: Map<string, string>\n    tablesFilter?: string[]\n    versionsSuffix?: string\n  }\n}\n"],"names":[],"mappings":"AA4FA,WAKuB"}