{"version":3,"file":"types.js","names":[],"sources":["../../../src/forms/Form/types.ts"],"sourcesContent":["import type {\n  ClientField,\n  Data,\n  FormField,\n  FormState,\n  Row,\n  TypedUser,\n  ValidationFieldError,\n} from 'payload'\nimport type React from 'react'\nimport type { Dispatch } from 'react'\n\nimport type { AcceptValues } from './mergeServerFormState.js'\n\nexport type Preferences = {\n  [key: string]: unknown\n}\n\nexport type FormOnSuccess<T = unknown, C = Record<string, unknown>> = (\n  json: T,\n  ctx?: {\n    /**\n     * Arbitrary context passed to the onSuccess callback.\n     */\n    context?: C\n    /**\n     * The form state that was sent with the request when retrieving the `json` arg.\n     */\n    formState?: FormState\n  },\n) => Promise<FormState | void> | void\n\nexport type FormProps = {\n  beforeSubmit?: ((args: { formState: FormState }) => Promise<FormState>)[]\n  children?: React.ReactNode\n  className?: string\n  disabled?: boolean\n  disableSuccessStatus?: boolean\n  /**\n   * If you would like to solely leverage server-side validation on submit,\n   * you can disable checks that the form makes before it submits\n   */\n  disableValidationOnSubmit?: boolean\n  /**\n   * If you don't want the form to be a <form> element, you can pass a string here to use as the wrapper element.\n   */\n  el?: string\n  /**\n   * By default, the form will get the field schema (not data) from the current document. If you pass this in, you can override that behavior.\n   * This is very useful for sub-forms, where the form's field schema is not necessarily the field schema of the current document (e.g. for the Blocks\n   * feature of the Lexical Rich Text field)\n   */\n  fields?: ClientField[]\n  handleResponse?: (\n    res: Response,\n    successToast: (value: string) => void,\n    errorToast: (value: string) => void,\n  ) => void\n  initialState?: FormState\n  /**\n   * Determines if this Form is the main, top-level Form of a document. If set to true, the\n   * Form's children will be wrapped in a DocumentFormContext, which lets you access this document\n   * Form's data and fields from any child component - even if that child component is wrapped in a child\n   * Form (e.g. a lexical block).\n   */\n  isDocumentForm?: boolean\n  isInitializing?: boolean\n  log?: boolean\n  onChange?: ((args: { formState: FormState; submitted?: boolean }) => Promise<FormState>)[]\n  onSubmit?: (fields: FormState, data: Data) => void\n  onSuccess?: FormOnSuccess\n  redirect?: string\n  submitted?: boolean\n  uuid?: string\n  validationOperation?: 'create' | 'update'\n  waitForAutocomplete?: boolean\n} & (\n  | {\n      action: (formData: FormData) => Promise<void>\n    }\n  | {\n      action?: string\n      method?: 'DELETE' | 'GET' | 'PATCH' | 'POST'\n    }\n)\n\nexport type SubmitOptions<C = Record<string, unknown>> = {\n  acceptValues?: AcceptValues\n  action?: string\n  /**\n   * If you want to pass additional data to the onSuccess callback, you can use this context object.\n   *\n   * @experimental This property is experimental and may change in the future.\n   */\n  context?: C\n  /**\n   * When true, will disable the form while it is processing.\n   * @default true\n   */\n  disableFormWhileProcessing?: boolean\n  /**\n   * When true, will disable the success toast after form submission.\n   * @default false\n   */\n  disableSuccessStatus?: boolean\n  method?: string\n  overrides?: ((formState) => FormData) | Record<string, unknown>\n  /**\n   * When true, will skip validation before submitting the form.\n   * @default false\n   */\n  skipValidation?: boolean\n}\n\nexport type DispatchFields = React.Dispatch<any>\n\nexport type Submit = <T extends Response, C extends Record<string, unknown>>(\n  options?: SubmitOptions<C>,\n  e?: React.FormEvent<HTMLFormElement>,\n) => Promise</**\n * Returns the form state and the response from the server.\n *\n * @experimental - Note: the `{ res: ... }` return type is experimental and may change in the future. Use at your own risk.\n */\n{ formState?: FormState; res: T } | void>\n\nexport type ValidateForm = () => Promise<boolean>\n\nexport type CreateFormData = (\n  overrides?: Record<string, unknown>,\n  /**\n   * If mergeOverrideData true, the data will be merged with the existing data in the form state.\n   * @default true\n   */\n  options?: {\n    /**\n     * If provided, will use this instead of of derived data from the current form state.\n     */\n    data?: Data\n    mergeOverrideData?: boolean\n  },\n) => FormData | Promise<FormData>\n\nexport type GetFields = () => FormState\nexport type GetField = (path: string) => FormField\nexport type GetData = () => Data\nexport type GetSiblingData = (path: string) => Data\nexport type GetDataByPath = <T = unknown>(path: string) => T\nexport type SetModified = (modified: boolean) => void\nexport type SetSubmitted = (submitted: boolean) => void\nexport type SetProcessing = (processing: boolean) => void\n\nexport type Reset = (data: unknown) => Promise<void>\n\nexport type REPLACE_STATE = {\n  optimize?: boolean\n  /**\n   * If `sanitize` is true, default values will be set for form field properties that are not present in the incoming state.\n   * For example, `valid` will be set to true if it is not present in the incoming state.\n   */\n  sanitize?: boolean\n  state: FormState\n  type: 'REPLACE_STATE'\n}\n\nexport type REMOVE = {\n  path: string\n  type: 'REMOVE'\n}\n\nexport type MODIFY_CONDITION = {\n  path: string\n  result: boolean\n  type: 'MODIFY_CONDITION'\n  user: TypedUser\n}\n\nexport type UPDATE = {\n  path: string\n  type: 'UPDATE'\n} & Partial<FormField>\n\nexport type UPDATE_MANY = {\n  formState: FormState\n  type: 'UPDATE_MANY'\n}\n\nexport type REMOVE_ROW = {\n  path: string\n  rowIndex: number\n  type: 'REMOVE_ROW'\n}\n\nexport type ADD_ROW = {\n  blockType?: string\n  path: string\n  rowIndex?: number\n  subFieldState?: FormState\n  type: 'ADD_ROW'\n}\n\nexport type MERGE_SERVER_STATE = {\n  acceptValues?: AcceptValues\n  prevStateRef: React.RefObject<FormState>\n  serverState: FormState\n  type: 'MERGE_SERVER_STATE'\n}\n\nexport type REPLACE_ROW = {\n  blockType?: string\n  path: string\n  rowIndex: number\n  subFieldState?: FormState\n  type: 'REPLACE_ROW'\n}\n\nexport type DUPLICATE_ROW = {\n  path: string\n  rowIndex: number\n  type: 'DUPLICATE_ROW'\n}\n\nexport type MOVE_ROW = {\n  moveFromIndex: number\n  moveToIndex: number\n  path: string\n  type: 'MOVE_ROW'\n}\n\nexport type ADD_SERVER_ERRORS = {\n  errors: ValidationFieldError[]\n  type: 'ADD_SERVER_ERRORS'\n}\n\nexport type SET_ROW_COLLAPSED = {\n  path: string\n  type: 'SET_ROW_COLLAPSED'\n  updatedRows: Row[]\n}\n\nexport type SET_ALL_ROWS_COLLAPSED = {\n  path: string\n  type: 'SET_ALL_ROWS_COLLAPSED'\n  updatedRows: Row[]\n}\n\nexport type FieldAction =\n  | ADD_ROW\n  | ADD_SERVER_ERRORS\n  | DUPLICATE_ROW\n  | MERGE_SERVER_STATE\n  | MODIFY_CONDITION\n  | MOVE_ROW\n  | REMOVE\n  | REMOVE_ROW\n  | REPLACE_ROW\n  | REPLACE_STATE\n  | SET_ALL_ROWS_COLLAPSED\n  | SET_ROW_COLLAPSED\n  | UPDATE\n  | UPDATE_MANY\n\nexport type FormFieldsContext = [FormState, Dispatch<FieldAction>]\n\nexport type Context = {\n  addFieldRow: ({\n    blockType,\n    path,\n    rowIndex,\n    schemaPath,\n    subFieldState,\n  }: {\n    blockType?: string\n    path: string\n    rowIndex?: number\n    schemaPath: string\n    subFieldState?: FormState\n  }) => void\n  buildRowErrors: () => void\n  createFormData: CreateFormData\n  disabled: boolean\n  dispatchFields: Dispatch<FieldAction>\n  /**\n   * Form context fields may be outdated and should not be relied on. Instead, prefer `useFormFields`.\n   */\n  fields: FormState\n  formRef: React.RefObject<HTMLFormElement>\n  getData: GetData\n  getDataByPath: GetDataByPath\n  getField: GetField\n  getFields: GetFields\n  getSiblingData: GetSiblingData\n  initializing: boolean\n  /**\n   * Tracks wether the form state passes validation.\n   * For example the state could be submitted but invalid as field errors have been returned.\n   */\n  isValid: boolean\n  moveFieldRow: ({\n    moveFromIndex,\n    moveToIndex,\n    path,\n  }: {\n    moveFromIndex: number\n    moveToIndex: number\n    path: string\n  }) => void\n  removeFieldRow: ({ path, rowIndex }: { path: string; rowIndex: number }) => void\n  replaceFieldRow: ({\n    blockType,\n    path,\n    rowIndex,\n    schemaPath,\n    subFieldState,\n  }: {\n    blockType?: string\n    path: string\n    rowIndex: number\n    schemaPath: string\n    subFieldState?: FormState\n  }) => void\n  replaceState: (state: FormState) => void\n  reset: Reset\n  /**\n   * If the form has started processing in the background (e.g.\n   * if autosave is running), this will be true.\n   */\n  setBackgroundProcessing: SetProcessing\n  setDisabled: (disabled: boolean) => void\n  setIsValid: (processing: boolean) => void\n  setModified: SetModified\n  setProcessing: SetProcessing\n  setSubmitted: SetSubmitted\n  submit: Submit\n  uuid?: string\n  validateForm: ValidateForm\n}\n"],"mappings":"AAwQA","ignoreList":[]}