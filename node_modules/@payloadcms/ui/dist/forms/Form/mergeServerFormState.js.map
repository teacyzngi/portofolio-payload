{"version":3,"file":"mergeServerFormState.js","names":["dequal","mergeServerFormState","acceptValues","currentState","incomingState","newState","path","incomingField","Object","entries","addedByServer","shouldAcceptValue","overrideLocalChanges","isModified","sanitizedIncomingField","initialValue","value","rest","errorPaths","Array","isArray","rows","forEach","row","indexInCurrentState","findIndex","existingRow","id","newRow","push","valid","passesCondition","blocksFilterOptions"],"sources":["../../../src/forms/Form/mergeServerFormState.ts"],"sourcesContent":["'use client'\nimport type { FormState } from 'payload'\n\nimport { dequal } from 'dequal/lite' // lite: no need for Map and Set support\n\n/**\n * If true, will accept all values from the server, overriding any current values in local state.\n * Can also provide an options object for more granular control.\n */\nexport type AcceptValues =\n  | {\n      /**\n       * When `false`, will accept the values from the server _UNLESS_ the value has been modified locally since the request was made.\n       * This is useful for autosave, for example, where hooks may have modified the field's value on the server while you were still making changes.\n       * @default undefined\n       */\n      overrideLocalChanges?: boolean\n    }\n  | boolean\n\ntype Args = {\n  acceptValues?: AcceptValues\n  currentState?: FormState\n  incomingState: FormState\n}\n\n/**\n * This function receives form state from the server and intelligently merges it into the client state.\n * The server contains extra properties that the client may not have, e.g. custom components and error states.\n * We typically do not want to merge properties that rely on user input, however, such as values, unless explicitly requested.\n * Doing this would cause the client to lose any local changes to those fields.\n *\n * Note: Local state is the source of truth, not the new server state that is getting merged in. This is critical for array row\n * manipulation specifically, where the user may have added, removed, or reordered rows while a request was pending and is now stale.\n *\n * This function applies some defaults, as well as cleans up the server response in preparation for the client.\n * e.g. it will set `valid` and `passesCondition` to true if undefined, and remove `addedByServer` from the response.\n */\nexport const mergeServerFormState = ({\n  acceptValues,\n  currentState = {},\n  incomingState,\n}: Args): FormState => {\n  const newState = { ...currentState }\n\n  for (const [path, incomingField] of Object.entries(incomingState || {})) {\n    if (!(path in currentState) && !incomingField.addedByServer) {\n      continue\n    }\n\n    /**\n     * If it's a new field added by the server, always accept the value.\n     * Otherwise:\n     *   a. accept all values when explicitly requested, e.g. on submit\n     *   b. only accept values for unmodified fields, e.g. on autosave\n     */\n    const shouldAcceptValue =\n      incomingField.addedByServer ||\n      acceptValues === true ||\n      (typeof acceptValues === 'object' &&\n        acceptValues !== null &&\n        // Note: Must be explicitly `false`, allow `null` or `undefined` to mean true\n        acceptValues.overrideLocalChanges === false &&\n        !currentState[path]?.isModified)\n\n    let sanitizedIncomingField = incomingField\n\n    if (!shouldAcceptValue) {\n      /**\n       * Note: do not delete properties off `incomingField` as this will mutate the original object\n       * Instead, omit them from the destructured object by excluding specific keys\n       * This will also ensure we don't set `undefined` into the result unnecessarily\n       */\n      const { initialValue, value, ...rest } = incomingField\n      sanitizedIncomingField = rest\n    }\n\n    newState[path] = {\n      ...currentState[path],\n      ...sanitizedIncomingField,\n    }\n\n    if (\n      currentState[path] &&\n      'errorPaths' in currentState[path] &&\n      !('errorPaths' in incomingField)\n    ) {\n      newState[path].errorPaths = []\n    }\n\n    /**\n     * Deeply merge the rows array to ensure changes to local state are not lost while the request was pending\n     * For example, the server response could come back with a row which has been deleted on the client\n     * Loop over the incoming rows, if it exists in client side form state, merge in any new properties from the server\n     * Note: read `currentState` and not `newState` here, as the `rows` property have already been merged above\n     */\n    if (Array.isArray(incomingField.rows) && path in currentState) {\n      newState[path].rows = [...(currentState[path]?.rows || [])] // shallow copy to avoid mutating the original array\n\n      incomingField.rows.forEach((row) => {\n        const indexInCurrentState = currentState[path].rows?.findIndex(\n          (existingRow) => existingRow.id === row.id,\n        )\n\n        if (indexInCurrentState > -1) {\n          newState[path].rows[indexInCurrentState] = {\n            ...currentState[path].rows[indexInCurrentState],\n            ...row,\n          }\n        } else if (row.addedByServer) {\n          /**\n           * Note: This is a known limitation of computed array and block rows\n           * If a new row was added by the server, we append it to the _end_ of this array\n           * This is because the client is the source of truth, and it has arrays ordered in a certain position\n           * For example, the user may have re-ordered rows client-side while a long running request is processing\n           * This means that we _cannot_ slice a new row into the second position on the server, for example\n           * By the time it gets back to the client, its index is stale\n           */\n          const newRow = { ...row }\n          delete newRow.addedByServer\n          newState[path].rows.push(newRow)\n        }\n      })\n    }\n\n    // If `valid` is `undefined`, mark it as `true`\n    if (incomingField.valid !== false) {\n      newState[path].valid = true\n    }\n\n    // If `passesCondition` is `undefined`, mark it as `true`\n    if (incomingField.passesCondition !== false) {\n      newState[path].passesCondition = true\n    }\n\n    /**\n     * Undefined values for blocksFilterOptions coming back should be treated as \"all blocks allowed\" and\n     * should always be merged in.\n     * Without this, an undefined value coming back will incorrectly be ignored, and the previous filter will remain.\n     */\n    if (!incomingField.blocksFilterOptions) {\n      delete newState[path].blocksFilterOptions\n    }\n\n    // Strip away the `addedByServer` property from the client\n    // This will prevent it from being passed back to the server\n    delete newState[path].addedByServer\n  }\n\n  // Return the original object reference if the state is unchanged\n  // This will avoid unnecessary re-renders and dependency updates\n  return dequal(newState, currentState) ? currentState : newState\n}\n"],"mappings":"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","ignoreList":[]}