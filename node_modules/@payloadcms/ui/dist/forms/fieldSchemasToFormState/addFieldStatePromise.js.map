{"version":3,"file":"addFieldStatePromise.js","names":["ObjectIdImport","getBlockSelect","stripUnselectedFields","validateBlocksFilterOptions","deepCopyObjectSimple","fieldAffectsData","fieldHasSubFields","fieldIsHiddenOrDisabled","fieldIsID","fieldIsLocalized","getFieldPaths","tabHasName","resolveFilterOptions","isRowCollapsed","iterateFields","ObjectId","default","addFieldStatePromise","args","id","addErrorPathToParent","addErrorPathToParentArg","anyParentLocalized","blockData","clientFieldSchemaMap","collectionSlug","data","field","fieldSchemaMap","filter","forceFullValue","fullData","includeSchema","indexPath","mockRSCs","omitParents","operation","parentPath","parentPermissions","parentSchemaPath","passesCondition","path","preferences","previousFormState","readOnly","renderAllFields","renderFieldFn","req","schemaPath","select","selectMode","skipConditionChecks","skipValidation","state","console","warn","fieldPermissions","fieldState","lastRenderedPath","addedByServer","fieldSchema","name","hasPermission","read","access","siblingData","validate","validationResult","jsonError","type","JSON","parse","e","event","previousValue","initialValue","err","payload","logger","error","msg","errorPath","errorPaths","includes","push","valid","errorMessage","arrayValue","Array","isArray","arraySelect","promises","rows","reduce","acc","row","i","toHexString","idKey","value","fields","find","localized","parentIndexPath","parentPassesCondition","permissions","undefined","previousRow","prevRow","newRow","isLoading","isCollapsed","collapsedPrefs","collapsed","Promise","all","length","disableFormData","blocksValue","filterOptionsValidationResult","filterOptions","blocksFilterOptions","allowedBlockSlugs","rowMetadata","blockTypeToMatch","blockType","block","blocks","blockReferences","slug","Error","blockSelect","blockSelectMode","invalidBlockSlugs","t","blockField","fieldKey","blockNameKey","blockName","groupSelect","relationTo","relation","query","user","hasMany","relationshipValue","map","relationship","selectFilterOptions","options","tabs","tab","tabIndex","isNamedTab","tabSelect","tabField","tabIndexPath","tabPath","tabSchemaPath","index","childPermissions","shouldContinue","siblingDoc","tabPermissions","pathSegments","split","tabPassesCondition","admin","condition","fieldConfig","get","endsWith","formState","previousFieldState"],"sources":["../../../src/forms/fieldSchemasToFormState/addFieldStatePromise.ts"],"sourcesContent":["import type {\n  BuildFormStateArgs,\n  ClientFieldSchemaMap,\n  Data,\n  DocumentPreferences,\n  Field,\n  FieldSchemaMap,\n  FieldState,\n  FlattenedBlock,\n  FormState,\n  FormStateWithoutComponents,\n  PayloadRequest,\n  Row,\n  SanitizedFieldPermissions,\n  SanitizedFieldsPermissions,\n  SelectMode,\n  SelectType,\n  TabAsField,\n  Validate,\n} from 'payload'\n\nimport ObjectIdImport from 'bson-objectid'\nimport { getBlockSelect, stripUnselectedFields, validateBlocksFilterOptions } from 'payload'\nimport {\n  deepCopyObjectSimple,\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldIsHiddenOrDisabled,\n  fieldIsID,\n  fieldIsLocalized,\n  getFieldPaths,\n  tabHasName,\n} from 'payload/shared'\n\nimport type { RenderFieldMethod } from './types.js'\n\nimport { resolveFilterOptions } from '../../utilities/resolveFilterOptions.js'\nimport { isRowCollapsed } from './isRowCollapsed.js'\nimport { iterateFields } from './iterateFields.js'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nexport type AddFieldStatePromiseArgs = {\n  addErrorPathToParent: (fieldPath: string) => void\n  /**\n   * if all parents are localized, then the field is localized\n   */\n  anyParentLocalized?: boolean\n  /**\n   * Data of the nearest parent block, or undefined\n   */\n  blockData: Data | undefined\n  clientFieldSchemaMap?: ClientFieldSchemaMap\n  collectionSlug?: string\n  data: Data\n  field: Field\n  fieldIndex: number\n  fieldSchemaMap: FieldSchemaMap\n  /**\n   * You can use this to filter down to only `localized` fields that require translation (type: text, textarea, etc.). Another plugin might want to look for only `point` type fields to do some GIS function. With the filter function you can go in like a surgeon.\n   */\n  filter?: (args: AddFieldStatePromiseArgs) => boolean\n  /**\n   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false\n   */\n  forceFullValue?: boolean\n  fullData: Data\n  id: number | string\n  /**\n   * Whether the field schema should be included in the state\n   */\n  includeSchema?: boolean\n  indexPath: string\n  mockRSCs?: BuildFormStateArgs['mockRSCs']\n  /**\n   * Whether to omit parent fields in the state. @default false\n   */\n  omitParents?: boolean\n  operation: 'create' | 'update'\n  parentIndexPath: string\n  parentPath: string\n  parentPermissions: SanitizedFieldsPermissions\n  parentSchemaPath: string\n  passesCondition: boolean\n  path: string\n  preferences: DocumentPreferences\n  previousFormState: FormState\n  readOnly?: boolean\n  renderAllFields: boolean\n  renderFieldFn: RenderFieldMethod\n  /**\n   * Req is used for validation and defaultValue calculation. If you don't need validation,\n   * just create your own req and pass in the locale and the user\n   */\n  req: PayloadRequest\n  schemaPath: string\n  select?: SelectType\n  selectMode?: SelectMode\n  /**\n   * Whether to skip checking the field's condition. @default false\n   */\n  skipConditionChecks?: boolean\n  /**\n   * Whether to skip validating the field. @default false\n   */\n  skipValidation?: boolean\n  state: FormStateWithoutComponents\n}\n\n/**\n * Flattens the fields schema and fields data.\n * The output is the field path (e.g. array.0.name) mapped to a FormField object.\n */\nexport const addFieldStatePromise = async (args: AddFieldStatePromiseArgs): Promise<void> => {\n  const {\n    id,\n    addErrorPathToParent: addErrorPathToParentArg,\n    anyParentLocalized = false,\n    blockData,\n    clientFieldSchemaMap,\n    collectionSlug,\n    data,\n    field,\n    fieldSchemaMap,\n    filter,\n    forceFullValue = false,\n    fullData,\n    includeSchema = false,\n    indexPath,\n    mockRSCs,\n    omitParents = false,\n    operation,\n    parentPath,\n    parentPermissions,\n    parentSchemaPath,\n    passesCondition,\n    path,\n    preferences,\n    previousFormState,\n    readOnly,\n    renderAllFields,\n    renderFieldFn,\n    req,\n    schemaPath,\n    select,\n    selectMode,\n    skipConditionChecks = false,\n    skipValidation = false,\n    state,\n  } = args\n\n  if (!args.clientFieldSchemaMap && args.renderFieldFn) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'clientFieldSchemaMap is not passed to addFieldStatePromise - this will reduce performance',\n    )\n  }\n\n  let fieldPermissions: SanitizedFieldPermissions = true\n\n  const fieldState: FieldState = {}\n\n  const lastRenderedPath = previousFormState?.[path]?.lastRenderedPath\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (lastRenderedPath) {\n    fieldState.lastRenderedPath = lastRenderedPath\n  }\n\n  // If we're rendering all fields, no need to flag this as added by server\n  const addedByServer = !renderAllFields && !previousFormState?.[path]\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (addedByServer) {\n    fieldState.addedByServer = true\n  }\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (passesCondition === false) {\n    fieldState.passesCondition = false\n  }\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (includeSchema) {\n    fieldState.fieldSchema = field\n  }\n\n  if (fieldAffectsData(field) && !fieldIsHiddenOrDisabled(field)) {\n    fieldPermissions =\n      parentPermissions === true\n        ? parentPermissions\n        : deepCopyObjectSimple(parentPermissions?.[field.name])\n\n    let hasPermission: boolean =\n      fieldPermissions === true || deepCopyObjectSimple(fieldPermissions?.read)\n\n    if (typeof field?.access?.read === 'function') {\n      hasPermission = await field.access.read({\n        id,\n        blockData,\n        data: fullData,\n        req,\n        siblingData: data,\n      })\n    } else {\n      hasPermission = true\n    }\n\n    if (!hasPermission) {\n      return\n    }\n\n    const validate: Validate = field.validate\n\n    let validationResult: string | true = true\n\n    if (typeof validate === 'function' && !skipValidation && passesCondition) {\n      let jsonError\n\n      if (field.type === 'json' && typeof data[field.name] === 'string') {\n        try {\n          JSON.parse(data[field.name])\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      try {\n        validationResult = await validate(data?.[field.name], {\n          ...field,\n          id,\n          blockData,\n          collectionSlug,\n          data: fullData,\n          event: 'onChange',\n          // @AlessioGr added `jsonError` in https://github.com/payloadcms/payload/commit/c7ea62a39473408c3ea912c4fbf73e11be4b538d\n          // @ts-expect-error-next-line\n          jsonError,\n          operation,\n          preferences,\n          previousValue: previousFormState?.[path]?.initialValue,\n          req,\n          siblingData: data,\n        })\n      } catch (err) {\n        validationResult = `Error validating field at path: ${path}`\n\n        req.payload.logger.error({\n          err,\n          msg: validationResult,\n        })\n      }\n    }\n\n    /**\n     * This function adds the error **path** to the current field and all its parents. If a field is invalid, all its parents are also invalid.\n     * It does not add the error **message** to the current field, as that shouldn't apply to all parents.\n     * This is done separately below.\n     */\n    const addErrorPathToParent = (errorPath: string) => {\n      if (typeof addErrorPathToParentArg === 'function') {\n        addErrorPathToParentArg(errorPath)\n      }\n\n      if (!fieldState.errorPaths) {\n        fieldState.errorPaths = []\n      }\n\n      if (!fieldState.errorPaths.includes(errorPath)) {\n        fieldState.errorPaths.push(errorPath)\n        fieldState.valid = false\n      }\n    }\n\n    if (typeof validationResult === 'string') {\n      fieldState.errorMessage = validationResult\n      fieldState.valid = false\n      addErrorPathToParent(path)\n    }\n\n    switch (field.type) {\n      case 'array': {\n        const arrayValue = Array.isArray(data[field.name]) ? data[field.name] : []\n\n        const arraySelect = select?.[field.name]\n\n        const { promises, rows } = arrayValue.reduce(\n          (acc, row, i: number) => {\n            const parentPath = path + '.' + i\n            row.id = row?.id || new ObjectId().toHexString()\n\n            if (!omitParents && (!filter || filter(args))) {\n              const idKey = parentPath + '.id'\n\n              state[idKey] = {\n                initialValue: row.id,\n                value: row.id,\n              }\n\n              if (includeSchema) {\n                state[idKey].fieldSchema = field.fields.find((field) => fieldIsID(field))\n              }\n            }\n\n            acc.promises.push(\n              iterateFields({\n                id,\n                addErrorPathToParent,\n                anyParentLocalized: field.localized || anyParentLocalized,\n                blockData,\n                clientFieldSchemaMap,\n                collectionSlug,\n                data: row,\n                fields: field.fields,\n                fieldSchemaMap,\n                filter,\n                forceFullValue,\n                fullData,\n                includeSchema,\n                mockRSCs,\n                omitParents,\n                operation,\n                parentIndexPath: '',\n                parentPassesCondition: passesCondition,\n                parentPath,\n                parentSchemaPath: schemaPath,\n                permissions:\n                  fieldPermissions === true ? fieldPermissions : fieldPermissions?.fields || {},\n                preferences,\n                previousFormState,\n                readOnly,\n                renderAllFields,\n                renderFieldFn,\n                req,\n                select: typeof arraySelect === 'object' ? arraySelect : undefined,\n                selectMode,\n                skipConditionChecks,\n                skipValidation,\n                state,\n              }),\n            )\n\n            if (!acc.rows) {\n              acc.rows = []\n            }\n\n            // First, check if `previousFormState` has a matching row\n            const previousRow: Row = (previousFormState?.[path]?.rows || []).find(\n              (prevRow) => prevRow.id === row.id,\n            )\n\n            const newRow: Row = {\n              id: row.id,\n              isLoading: false,\n            }\n\n            if (previousRow?.lastRenderedPath) {\n              newRow.lastRenderedPath = previousRow.lastRenderedPath\n            }\n\n            // add addedByServer flag\n            if (!previousRow) {\n              newRow.addedByServer = true\n            }\n\n            const isCollapsed = isRowCollapsed({\n              collapsedPrefs: preferences?.fields?.[path]?.collapsed,\n              field,\n              previousRow,\n              row,\n            })\n\n            if (isCollapsed) {\n              newRow.collapsed = true\n            }\n\n            acc.rows.push(newRow)\n\n            return acc\n          },\n          {\n            promises: [],\n            rows: [],\n          },\n        )\n\n        // Wait for all promises and update fields with the results\n        await Promise.all(promises)\n\n        if (rows) {\n          fieldState.rows = rows\n        }\n\n        // Add values to field state\n        if (data[field.name] !== null) {\n          fieldState.value = forceFullValue ? arrayValue : arrayValue.length\n          fieldState.initialValue = forceFullValue ? arrayValue : arrayValue.length\n\n          if (arrayValue.length > 0) {\n            fieldState.disableFormData = true\n          }\n        }\n\n        // Add field to state\n        if (!omitParents && (!filter || filter(args))) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const blocksValue = Array.isArray(data[field.name]) ? data[field.name] : []\n\n        // Handle blocks filterOptions\n        let filterOptionsValidationResult: Awaited<\n          ReturnType<typeof validateBlocksFilterOptions>\n        > | null = null\n        if (field.filterOptions) {\n          filterOptionsValidationResult = await validateBlocksFilterOptions({\n            id,\n            data: fullData,\n            filterOptions: field.filterOptions,\n            req,\n            siblingData: data,\n            value: data[field.name],\n          })\n\n          fieldState.blocksFilterOptions = filterOptionsValidationResult.allowedBlockSlugs\n        }\n\n        const { promises, rowMetadata } = blocksValue.reduce(\n          (acc, row, i: number) => {\n            const blockTypeToMatch: string = row.blockType\n\n            const block =\n              req.payload.blocks[blockTypeToMatch] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (blockType) => typeof blockType !== 'string' && blockType.slug === blockTypeToMatch,\n              ) as FlattenedBlock | undefined)\n\n            if (!block) {\n              throw new Error(\n                `Block with type \"${row.blockType}\" was found in block data, but no block with that type is defined in the config for field with schema path ${schemaPath}.`,\n              )\n            }\n\n            const { blockSelect, blockSelectMode } = getBlockSelect({\n              block,\n              select: select?.[field.name],\n              selectMode,\n            })\n\n            const parentPath = path + '.' + i\n\n            if (block) {\n              row.id = row?.id || new ObjectId().toHexString()\n\n              if (!omitParents && (!filter || filter(args))) {\n                // Handle block `id` field\n                const idKey = parentPath + '.id'\n\n                state[idKey] = {\n                  initialValue: row.id,\n                  value: row.id,\n                }\n\n                // If the blocks field fails filterOptions validation, add error paths to the individual blocks that are no longer allowed\n                if (\n                  filterOptionsValidationResult?.invalidBlockSlugs?.length &&\n                  filterOptionsValidationResult.invalidBlockSlugs.includes(row.blockType)\n                ) {\n                  state[idKey].errorMessage = req.t('validation:invalidBlock', {\n                    block: row.blockType,\n                  })\n                  state[idKey].valid = false\n                  addErrorPathToParent(idKey)\n\n                  // If the error is due to block filterOptions, we want the blocks field (fieldState) to include all the filterOptions-related\n                  // error paths for each sub-block, not for the validation result of the block itself. Otherwise, say there are 2 invalid blocks,\n                  // the blocks field will have 3 instead of 2 error paths - one for itself, and one for each invalid block.\n                  // Instead, we want only the 2 error paths for the individual, invalid blocks.\n                  fieldState.errorPaths = fieldState.errorPaths.filter(\n                    (errorPath) => errorPath !== path,\n                  )\n                }\n\n                if (includeSchema) {\n                  state[idKey].fieldSchema = includeSchema\n                    ? block.fields.find((blockField) => fieldIsID(blockField))\n                    : undefined\n                }\n\n                // Handle `blockType` field\n                const fieldKey = parentPath + '.blockType'\n\n                state[fieldKey] = {\n                  initialValue: row.blockType,\n                  value: row.blockType,\n                }\n\n                if (addedByServer) {\n                  state[fieldKey].addedByServer = addedByServer\n                }\n\n                if (includeSchema) {\n                  state[fieldKey].fieldSchema = block.fields.find(\n                    (blockField) => 'name' in blockField && blockField.name === 'blockType',\n                  )\n                }\n\n                // Handle `blockName` field\n                const blockNameKey = parentPath + '.blockName'\n\n                state[blockNameKey] = {}\n\n                if (row.blockName) {\n                  state[blockNameKey].initialValue = row.blockName\n                  state[blockNameKey].value = row.blockName\n                }\n\n                if (includeSchema) {\n                  state[blockNameKey].fieldSchema = block.fields.find(\n                    (blockField) => 'name' in blockField && blockField.name === 'blockName',\n                  )\n                }\n              }\n\n              acc.promises.push(\n                iterateFields({\n                  id,\n                  addErrorPathToParent,\n                  anyParentLocalized: field.localized || anyParentLocalized,\n                  blockData: row,\n                  clientFieldSchemaMap,\n                  collectionSlug,\n                  data: row,\n                  fields: block.fields,\n                  fieldSchemaMap,\n                  filter,\n                  forceFullValue,\n                  fullData,\n                  includeSchema,\n                  mockRSCs,\n                  omitParents,\n                  operation,\n                  parentIndexPath: '',\n                  parentPassesCondition: passesCondition,\n                  parentPath,\n                  parentSchemaPath: schemaPath + '.' + block.slug,\n                  permissions:\n                    fieldPermissions === true\n                      ? fieldPermissions\n                      : parentPermissions?.[field.name]?.blocks?.[block.slug] === true\n                        ? true\n                        : parentPermissions?.[field.name]?.blocks?.[block.slug]?.fields || {},\n                  preferences,\n                  previousFormState,\n                  readOnly,\n                  renderAllFields,\n                  renderFieldFn,\n                  req,\n                  select: typeof blockSelect === 'object' ? blockSelect : undefined,\n                  selectMode: blockSelectMode,\n                  skipConditionChecks,\n                  skipValidation,\n                  state,\n                }),\n              )\n\n              // First, check if `previousFormState` has a matching row\n              const previousRow: Row = (previousFormState?.[path]?.rows || []).find(\n                (prevRow) => prevRow.id === row.id,\n              )\n\n              const newRow: Row = {\n                id: row.id,\n                blockType: row.blockType,\n                isLoading: false,\n              }\n\n              if (previousRow?.lastRenderedPath) {\n                newRow.lastRenderedPath = previousRow.lastRenderedPath\n              }\n\n              acc.rowMetadata.push(newRow)\n\n              const isCollapsed = isRowCollapsed({\n                collapsedPrefs: preferences?.fields?.[path]?.collapsed,\n                field,\n                previousRow,\n                row,\n              })\n\n              if (isCollapsed) {\n                acc.rowMetadata[acc.rowMetadata.length - 1].collapsed = true\n              }\n            }\n\n            return acc\n          },\n          {\n            promises: [],\n            rowMetadata: [],\n          },\n        )\n\n        await Promise.all(promises)\n\n        // Add values to field state\n        if (data[field.name] === null) {\n          fieldState.value = null\n          fieldState.initialValue = null\n        } else {\n          fieldState.value = forceFullValue ? blocksValue : blocksValue.length\n          fieldState.initialValue = forceFullValue ? blocksValue : blocksValue.length\n\n          if (blocksValue.length > 0) {\n            fieldState.disableFormData = true\n          }\n        }\n\n        fieldState.rows = rowMetadata\n\n        // Add field to state\n        if (!omitParents && (!filter || filter(args))) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      case 'group': {\n        if (!filter || filter(args)) {\n          fieldState.disableFormData = true\n          state[path] = fieldState\n        }\n\n        const groupSelect = select?.[field.name]\n\n        await iterateFields({\n          id,\n          addErrorPathToParent,\n          anyParentLocalized: field.localized || anyParentLocalized,\n          blockData,\n          clientFieldSchemaMap,\n          collectionSlug,\n          data: data?.[field.name] || {},\n          fields: field.fields,\n          fieldSchemaMap,\n          filter,\n          forceFullValue,\n          fullData,\n          includeSchema,\n          mockRSCs,\n          omitParents,\n          operation,\n          parentIndexPath: '',\n          parentPassesCondition: passesCondition,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          permissions:\n            typeof fieldPermissions === 'boolean' ? fieldPermissions : fieldPermissions?.fields,\n          preferences,\n          previousFormState,\n          readOnly,\n          renderAllFields,\n          renderFieldFn,\n          req,\n          select: typeof groupSelect === 'object' ? groupSelect : undefined,\n          selectMode,\n          skipConditionChecks,\n          skipValidation,\n          state,\n        })\n\n        break\n      }\n\n      case 'relationship':\n      case 'upload': {\n        if (field.filterOptions) {\n          if (typeof field.filterOptions === 'object') {\n            if (typeof field.relationTo === 'string') {\n              fieldState.filterOptions = {\n                [field.relationTo]: field.filterOptions,\n              }\n            } else {\n              fieldState.filterOptions = field.relationTo.reduce((acc, relation) => {\n                acc[relation] = field.filterOptions\n                return acc\n              }, {})\n            }\n          }\n\n          if (typeof field.filterOptions === 'function') {\n            const query = await resolveFilterOptions(field.filterOptions, {\n              id,\n              blockData,\n              data: fullData,\n              relationTo: field.relationTo,\n              req,\n              siblingData: data,\n              user: req.user,\n            })\n\n            fieldState.filterOptions = query\n          }\n        }\n\n        if (field.hasMany) {\n          const relationshipValue = Array.isArray(data[field.name])\n            ? data[field.name].map((relationship) => {\n                if (Array.isArray(field.relationTo)) {\n                  return {\n                    relationTo: relationship.relationTo,\n                    value:\n                      relationship.value && typeof relationship.value === 'object'\n                        ? relationship.value?.id\n                        : relationship.value,\n                  }\n                }\n                if (typeof relationship === 'object' && relationship !== null) {\n                  return relationship.id\n                }\n                return relationship\n              })\n            : undefined\n\n          fieldState.value = relationshipValue\n          fieldState.initialValue = relationshipValue\n        } else if (Array.isArray(field.relationTo)) {\n          if (\n            data[field.name] &&\n            typeof data[field.name] === 'object' &&\n            'relationTo' in data[field.name] &&\n            'value' in data[field.name]\n          ) {\n            const value =\n              typeof data[field.name]?.value === 'object' &&\n              data[field.name]?.value &&\n              'id' in data[field.name].value\n                ? data[field.name].value.id\n                : data[field.name].value\n            const relationshipValue = {\n              relationTo: data[field.name]?.relationTo,\n              value,\n            }\n            fieldState.value = relationshipValue\n            fieldState.initialValue = relationshipValue\n          }\n        } else {\n          const relationshipValue =\n            data[field.name] && typeof data[field.name] === 'object' && 'id' in data[field.name]\n              ? data[field.name].id\n              : data[field.name]\n          fieldState.value = relationshipValue\n          fieldState.initialValue = relationshipValue\n        }\n\n        if (!filter || filter(args)) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      case 'select': {\n        if (typeof field.filterOptions === 'function') {\n          fieldState.selectFilterOptions = field.filterOptions({\n            data: fullData,\n            options: field.options,\n            req,\n            siblingData: data,\n          })\n        }\n\n        if (data[field.name] !== undefined) {\n          fieldState.value = data[field.name]\n          fieldState.initialValue = data[field.name]\n        }\n\n        if (!filter || filter(args)) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      default: {\n        if (data[field.name] !== undefined) {\n          fieldState.value = data[field.name]\n          fieldState.initialValue = data[field.name]\n        }\n\n        // Add field to state\n        if (!filter || filter(args)) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n    }\n  } else if (fieldHasSubFields(field) && !fieldAffectsData(field)) {\n    // Handle field types that do not use names (row, collapsible, unnamed group etc)\n\n    if (!filter || filter(args)) {\n      state[path] = {\n        disableFormData: true,\n      }\n\n      if (passesCondition === false) {\n        state[path].passesCondition = false\n      }\n    }\n\n    await iterateFields({\n      id,\n      mockRSCs,\n      select,\n      selectMode,\n      // passthrough parent functionality\n      addErrorPathToParent: addErrorPathToParentArg,\n      anyParentLocalized: fieldIsLocalized(field) || anyParentLocalized,\n      blockData,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data,\n      fields: field.fields,\n      fieldSchemaMap,\n      filter,\n      forceFullValue,\n      fullData,\n      includeSchema,\n      omitParents,\n      operation,\n      parentIndexPath: indexPath,\n      parentPassesCondition: passesCondition,\n      parentPath,\n      parentSchemaPath,\n      permissions: parentPermissions, // TODO: Verify this is correct\n      preferences,\n      previousFormState,\n      readOnly,\n      renderAllFields,\n      renderFieldFn,\n      req,\n      skipConditionChecks,\n      skipValidation,\n      state,\n    })\n  } else if (field.type === 'tabs') {\n    const promises = field.tabs.map((tab, tabIndex) => {\n      const isNamedTab = tabHasName(tab)\n      let tabSelect: SelectType | undefined\n\n      const tabField: TabAsField = {\n        ...tab,\n        type: 'tab',\n      }\n\n      const {\n        indexPath: tabIndexPath,\n        path: tabPath,\n        schemaPath: tabSchemaPath,\n      } = getFieldPaths({\n        field: tabField,\n        index: tabIndex,\n        parentIndexPath: indexPath,\n        parentPath,\n        parentSchemaPath,\n      })\n\n      let childPermissions: SanitizedFieldsPermissions = undefined\n\n      if (isNamedTab) {\n        const shouldContinue = stripUnselectedFields({\n          field: tabField,\n          select,\n          selectMode,\n          siblingDoc: data?.[tab.name] || {},\n        })\n\n        if (!shouldContinue) {\n          return\n        }\n\n        if (parentPermissions === true) {\n          childPermissions = true\n        } else {\n          const tabPermissions = parentPermissions?.[tab.name]\n          if (tabPermissions === true) {\n            childPermissions = true\n          } else {\n            childPermissions = tabPermissions?.fields\n          }\n        }\n\n        if (typeof select?.[tab.name] === 'object') {\n          tabSelect = select?.[tab.name] as SelectType\n        }\n      } else {\n        childPermissions = parentPermissions\n        tabSelect = select\n      }\n\n      const pathSegments = path ? path.split('.') : []\n\n      // If passesCondition is false then this should always result to false\n      // If the tab has no admin.condition provided then fallback to passesCondition and let that decide the result\n      let tabPassesCondition = passesCondition\n\n      if (passesCondition && typeof tab.admin?.condition === 'function') {\n        tabPassesCondition = tab.admin.condition(fullData, data, {\n          blockData,\n          operation,\n          path: pathSegments,\n          user: req.user,\n        })\n      }\n\n      if (tab?.id) {\n        state[tab.id] = {\n          passesCondition: tabPassesCondition,\n        }\n      }\n\n      return iterateFields({\n        id,\n        addErrorPathToParent: addErrorPathToParentArg,\n        anyParentLocalized: tab.localized || anyParentLocalized,\n        blockData,\n        clientFieldSchemaMap,\n        collectionSlug,\n        data: isNamedTab ? data?.[tab.name] || {} : data,\n        fields: tab.fields,\n        fieldSchemaMap,\n        filter,\n        forceFullValue,\n        fullData,\n        includeSchema,\n        mockRSCs,\n        omitParents,\n        operation,\n        parentIndexPath: isNamedTab ? '' : tabIndexPath,\n        parentPassesCondition: tabPassesCondition,\n        parentPath: isNamedTab ? tabPath : parentPath,\n        parentSchemaPath: isNamedTab ? tabSchemaPath : parentSchemaPath,\n        permissions: childPermissions,\n        preferences,\n        previousFormState,\n        readOnly,\n        renderAllFields,\n        renderFieldFn,\n        req,\n        select: tabSelect,\n        selectMode,\n        skipConditionChecks,\n        skipValidation,\n        state,\n      })\n    })\n\n    await Promise.all(promises)\n  } else if (field.type === 'ui') {\n    if (!filter || filter(args)) {\n      state[path] = fieldState\n      state[path].disableFormData = true\n    }\n  }\n\n  if (renderFieldFn && !fieldIsHiddenOrDisabled(field)) {\n    const fieldConfig = fieldSchemaMap.get(schemaPath)\n\n    if (!fieldConfig && !mockRSCs) {\n      if (schemaPath.endsWith('.blockType')) {\n        return\n      } else {\n        throw new Error(`Field config not found for ${schemaPath}`)\n      }\n    }\n\n    if (!state[path]) {\n      // Some fields (ie `Tab`) do not live in form state\n      // therefore we cannot attach customComponents to them\n      return\n    }\n\n    if (addedByServer) {\n      state[path].addedByServer = addedByServer\n    }\n\n    renderFieldFn({\n      id,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data: fullData,\n      fieldConfig: fieldConfig as Field,\n      fieldSchemaMap,\n      fieldState: state[path],\n      formState: state,\n      indexPath,\n      lastRenderedPath,\n      mockRSCs,\n      operation,\n      parentPath,\n      parentSchemaPath,\n      path,\n      permissions: fieldPermissions,\n      preferences,\n      previousFieldState: previousFormState?.[path],\n      readOnly,\n      renderAllFields,\n      req,\n      schemaPath,\n      siblingData: data,\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]}