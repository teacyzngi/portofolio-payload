{"version":3,"file":"index.js","names":["calculateDefaultValues","iterateFields","fieldSchemasToFormState","id","clientFieldSchemaMap","collectionSlug","data","documentData","fields","fieldSchemaMap","initialBlockData","mockRSCs","operation","permissions","preferences","previousFormState","readOnly","renderAllFields","renderFieldFn","req","schemaPath","select","selectMode","skipValidation","console","warn","length","state","dataWithDefaultValues","locale","siblingData","user","fullData","addErrorPathToParent","blockData","parentIndexPath","parentPassesCondition","parentPath","parentSchemaPath"],"sources":["../../../src/forms/fieldSchemasToFormState/index.tsx"],"sourcesContent":["import type {\n  BuildFormStateArgs,\n  ClientFieldSchemaMap,\n  Data,\n  DocumentPreferences,\n  Field,\n  FieldSchemaMap,\n  FormState,\n  FormStateWithoutComponents,\n  PayloadRequest,\n  SanitizedFieldsPermissions,\n  SelectMode,\n  SelectType,\n} from 'payload'\n\nimport type { RenderFieldMethod } from './types.js'\n\nimport { calculateDefaultValues } from './calculateDefaultValues/index.js'\nimport { iterateFields } from './iterateFields.js'\n\ntype Args = {\n  /**\n   * The client field schema map is required for field rendering.\n   * If fields should not be rendered (=> `renderFieldFn` is not provided),\n   * then the client field schema map is not required.\n   */\n  clientFieldSchemaMap?: ClientFieldSchemaMap\n  collectionSlug?: string\n  data?: Data\n  /**\n   * If this is undefined, the `data` passed to this function will serve as `fullData` and `data` when iterating over\n   * the top-level-fields to generate form state.\n   * For sub fields, the `data` will be narrowed down to the sub fields, while `fullData` remains the same.\n   *\n   * Usually, the `data` passed to this function will be the document data. This means that running validation, read access control\n   * or executing filterOptions here will have access to the full document through the passed `fullData` parameter, and that `fullData` and `data` will be identical.\n   *\n   * In some cases however, this function is used to generate form state solely for sub fields - independent from the parent form state.\n   * This means that `data` will be the form state of the sub fields - the document data won't be available here.\n   *\n   * In these cases, you can pass `documentData` which will be used as `fullData` instead of `data`.\n   *\n   * This is useful for lexical blocks, as lexical block fields there are not part of the parent form state, yet we still want\n   * document data to be available for validation and filterOptions, under the `data` key.\n   */\n  documentData?: Data\n  fields: Field[] | undefined\n  /**\n   * The field schema map is required for field rendering.\n   * If fields should not be rendered (=> `renderFieldFn` is not provided),\n   * then the field schema map is not required.\n   */\n  fieldSchemaMap: FieldSchemaMap | undefined\n  id?: number | string\n  /**\n   * Validation, filterOptions and read access control will receive the `blockData`, which is the data of the nearest parent block. You can pass in\n   * the initial block data here, which will be used as `blockData` for the top-level fields, until the first block is encountered.\n   */\n  initialBlockData?: Data\n  mockRSCs?: BuildFormStateArgs['mockRSCs']\n  operation?: 'create' | 'update'\n  permissions: SanitizedFieldsPermissions\n  preferences: DocumentPreferences\n  /**\n   * Optionally accept the previous form state,\n   * to be able to determine if custom fields need to be re-rendered.\n   */\n  previousFormState?: FormState\n  readOnly?: boolean\n  /**\n   * If renderAllFields is true, then no matter what is in previous form state,\n   * all custom fields will be re-rendered.\n   */\n  renderAllFields: boolean\n  renderFieldFn?: RenderFieldMethod\n  req: PayloadRequest\n  schemaPath: string\n  select?: SelectType\n  selectMode?: SelectMode\n  skipValidation?: boolean\n}\n\nexport const fieldSchemasToFormState = async ({\n  id,\n  clientFieldSchemaMap,\n  collectionSlug,\n  data = {},\n  documentData,\n  fields,\n  fieldSchemaMap,\n  initialBlockData,\n  mockRSCs,\n  operation,\n  permissions,\n  preferences,\n  previousFormState,\n  readOnly,\n  renderAllFields,\n  renderFieldFn,\n  req,\n  schemaPath,\n  select,\n  selectMode,\n  skipValidation,\n}: Args): Promise<FormState> => {\n  if (!clientFieldSchemaMap && renderFieldFn) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'clientFieldSchemaMap is not passed to fieldSchemasToFormState - this will reduce performance',\n    )\n  }\n\n  if (fields && fields.length) {\n    const state: FormStateWithoutComponents = {}\n\n    const dataWithDefaultValues = { ...data }\n\n    await calculateDefaultValues({\n      id,\n      data: dataWithDefaultValues,\n      fields,\n      locale: req.locale,\n      req,\n      select,\n      selectMode,\n      siblingData: dataWithDefaultValues,\n      user: req.user,\n    })\n\n    let fullData = dataWithDefaultValues\n\n    if (documentData) {\n      // By the time this function is used to get form state for nested forms, their default values should have already been calculated\n      // => no need to run calculateDefaultValues here\n      fullData = documentData\n    }\n\n    await iterateFields({\n      id,\n      addErrorPathToParent: null,\n      blockData: initialBlockData,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data: dataWithDefaultValues,\n      fields,\n      fieldSchemaMap,\n      fullData,\n      mockRSCs,\n      operation,\n      parentIndexPath: '',\n      parentPassesCondition: true,\n      parentPath: '',\n      parentSchemaPath: schemaPath,\n      permissions,\n      preferences,\n      previousFormState,\n      readOnly,\n      renderAllFields,\n      renderFieldFn,\n      req,\n      select,\n      selectMode,\n      skipValidation,\n      state,\n    })\n\n    return state\n  }\n\n  return {}\n}\n\nexport { iterateFields }\n"],"mappings":"AAiBA,SAASA,sBAAsB,QAAQ;AACvC,SAASC,aAAa,QAAQ;AAgE9B,OAAO,MAAMC,uBAAA,GAA0B,MAAAA,CAAO;EAC5CC,EAAE;EACFC,oBAAoB;EACpBC,cAAc;EACdC,IAAA,GAAO,CAAC,CAAC;EACTC,YAAY;EACZC,MAAM;EACNC,cAAc;EACdC,gBAAgB;EAChBC,QAAQ;EACRC,SAAS;EACTC,WAAW;EACXC,WAAW;EACXC,iBAAiB;EACjBC,QAAQ;EACRC,eAAe;EACfC,aAAa;EACbC,GAAG;EACHC,UAAU;EACVC,MAAM;EACNC,UAAU;EACVC;AAAc,CACT;EACL,IAAI,CAACnB,oBAAA,IAAwBc,aAAA,EAAe;IAC1C;IACAM,OAAA,CAAQC,IAAI,CACV;EAEJ;EAEA,IAAIjB,MAAA,IAAUA,MAAA,CAAOkB,MAAM,EAAE;IAC3B,MAAMC,KAAA,GAAoC,CAAC;IAE3C,MAAMC,qBAAA,GAAwB;MAAE,GAAGtB;IAAK;IAExC,MAAMN,sBAAA,CAAuB;MAC3BG,EAAA;MACAG,IAAA,EAAMsB,qBAAA;MACNpB,MAAA;MACAqB,MAAA,EAAQV,GAAA,CAAIU,MAAM;MAClBV,GAAA;MACAE,MAAA;MACAC,UAAA;MACAQ,WAAA,EAAaF,qBAAA;MACbG,IAAA,EAAMZ,GAAA,CAAIY;IACZ;IAEA,IAAIC,QAAA,GAAWJ,qBAAA;IAEf,IAAIrB,YAAA,EAAc;MAChB;MACA;MACAyB,QAAA,GAAWzB,YAAA;IACb;IAEA,MAAMN,aAAA,CAAc;MAClBE,EAAA;MACA8B,oBAAA,EAAsB;MACtBC,SAAA,EAAWxB,gBAAA;MACXN,oBAAA;MACAC,cAAA;MACAC,IAAA,EAAMsB,qBAAA;MACNpB,MAAA;MACAC,cAAA;MACAuB,QAAA;MACArB,QAAA;MACAC,SAAA;MACAuB,eAAA,EAAiB;MACjBC,qBAAA,EAAuB;MACvBC,UAAA,EAAY;MACZC,gBAAA,EAAkBlB,UAAA;MAClBP,WAAA;MACAC,WAAA;MACAC,iBAAA;MACAC,QAAA;MACAC,eAAA;MACAC,aAAA;MACAC,GAAA;MACAE,MAAA;MACAC,UAAA;MACAC,cAAA;MACAI;IACF;IAEA,OAAOA,KAAA;EACT;EAEA,OAAO,CAAC;AACV;AAEA,SAAS1B,aAAa","ignoreList":[]}