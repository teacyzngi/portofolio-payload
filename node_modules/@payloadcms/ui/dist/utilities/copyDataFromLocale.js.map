{"version":3,"file":"copyDataFromLocale.js","names":["ObjectIdImport","canAccessAdmin","formatErrors","traverseFields","fieldAffectsData","fieldShouldBeLocalized","tabHasName","ObjectId","default","iterateFields","fields","fromLocaleData","toLocaleData","req","parentIsLocalized","map","field","type","name","undefined","includes","item","index","id","toHexString","localized","Array","isArray","length","blockData","block","payload","blocks","blockType","blockReferences","find","slug","tabs","tab","mergeData","removeIdIfParentIsLocalized","data","callback","ref","fillEmpty","copyDataFromLocaleHandler","args","copyDataFromLocale","err","logger","error","msg","fromLocale","toLocale","message","collectionSlug","docID","globalSlug","overrideData","collections","globals","user","Promise","allSettled","findGlobal","depth","locale","overrideAccess","findByID","collection","joins","status","Error","config","fromLocaleDataWithoutID","value","toLocaleDataWithoutID","dataWithID","updateGlobal","update"],"sources":["../../src/utilities/copyDataFromLocale.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\nimport {\n  canAccessAdmin,\n  type CollectionSlug,\n  type Data,\n  type Field,\n  type FlattenedBlock,\n  formatErrors,\n  type PayloadRequest,\n  type ServerFunction,\n  traverseFields,\n} from 'payload'\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from 'payload/shared'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nexport type CopyDataFromLocaleArgs = {\n  collectionSlug?: CollectionSlug\n  docID?: number | string\n  fromLocale: string\n  globalSlug?: string\n  overrideData?: boolean\n  req: PayloadRequest\n  toLocale: string\n}\n\nfunction iterateFields(\n  fields: Field[],\n  fromLocaleData: Data,\n  toLocaleData: Data,\n  req: PayloadRequest,\n  parentIsLocalized: boolean,\n): void {\n  fields.map((field) => {\n    if (fieldAffectsData(field)) {\n      switch (field.type) {\n        case 'array':\n          // if the field has no value, take the source value\n          if (\n            field.name in toLocaleData &&\n            // only replace if the target value is null or undefined\n            [null, undefined].includes(toLocaleData[field.name]) &&\n            field.name in fromLocaleData\n          ) {\n            toLocaleData[field.name] = fromLocaleData[field.name]\n            break\n          }\n\n          // if the field has a value - loop over the data from target\n          if (field.name in toLocaleData) {\n            toLocaleData[field.name].map((item: Data, index: number) => {\n              if (fromLocaleData[field.name]?.[index]) {\n                // Generate new IDs if the field is localized to prevent errors with relational DBs.\n                if (fieldShouldBeLocalized({ field, parentIsLocalized })) {\n                  toLocaleData[field.name][index].id = new ObjectId().toHexString()\n                }\n\n                iterateFields(\n                  field.fields,\n                  fromLocaleData[field.name][index],\n                  item,\n                  req,\n                  parentIsLocalized || field.localized,\n                )\n              }\n            })\n          }\n          break\n\n        case 'blocks':\n          // if the field has no value, take the source value\n          if (\n            field.name in toLocaleData &&\n            // only replace if the target value is null, undefined, or empty array\n            ([null, undefined].includes(toLocaleData[field.name]) ||\n              (Array.isArray(toLocaleData[field.name]) && toLocaleData[field.name].length === 0)) &&\n            field.name in fromLocaleData\n          ) {\n            toLocaleData[field.name] = fromLocaleData[field.name]\n            break\n          }\n\n          // if the field has a value - loop over the data from target\n          if (field.name in toLocaleData) {\n            toLocaleData[field.name].map((blockData: Data, index: number) => {\n              const block =\n                req.payload.blocks[blockData.blockType] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (block) => typeof block !== 'string' && block.slug === blockData.blockType,\n                ) as FlattenedBlock | undefined)\n\n              // Generate new IDs if the field is localized to prevent errors with relational DBs.\n              if (fieldShouldBeLocalized({ field, parentIsLocalized })) {\n                toLocaleData[field.name][index].id = new ObjectId().toHexString()\n              }\n\n              if (block?.fields?.length) {\n                iterateFields(\n                  block?.fields,\n                  fromLocaleData[field.name][index],\n                  blockData,\n                  req,\n                  parentIsLocalized || field.localized,\n                )\n              }\n            })\n          }\n\n          break\n\n        case 'checkbox':\n        case 'code':\n        case 'date':\n        case 'email':\n        case 'json':\n        case 'number':\n        case 'point':\n        case 'radio':\n        case 'relationship':\n        case 'richText':\n        case 'select':\n        case 'text':\n        case 'textarea':\n        case 'upload':\n          if (\n            field.name in toLocaleData &&\n            // only replace if the target value is null or undefined\n            [null, undefined].includes(toLocaleData[field.name]) &&\n            field.name in fromLocaleData\n          ) {\n            toLocaleData[field.name] = fromLocaleData[field.name]\n          }\n          break\n\n        case 'group': {\n          if (\n            fieldAffectsData(field) &&\n            field.name in toLocaleData &&\n            fromLocaleData?.[field.name] !== undefined\n          ) {\n            iterateFields(\n              field.fields,\n              fromLocaleData[field.name],\n              toLocaleData[field.name],\n              req,\n              parentIsLocalized || field.localized,\n            )\n          } else {\n            iterateFields(field.fields, fromLocaleData, toLocaleData, req, parentIsLocalized)\n          }\n          break\n        }\n      }\n    } else {\n      switch (field.type) {\n        case 'collapsible':\n        case 'row':\n          iterateFields(field.fields, fromLocaleData, toLocaleData, req, parentIsLocalized)\n          break\n\n        case 'tabs':\n          field.tabs.map((tab) => {\n            if (tabHasName(tab)) {\n              if (tab.name in toLocaleData && fromLocaleData?.[tab.name] !== undefined) {\n                iterateFields(\n                  tab.fields,\n                  fromLocaleData[tab.name],\n                  toLocaleData[tab.name],\n                  req,\n                  parentIsLocalized,\n                )\n              }\n            } else {\n              iterateFields(tab.fields, fromLocaleData, toLocaleData, req, parentIsLocalized)\n            }\n          })\n          break\n      }\n    }\n  })\n}\n\nfunction mergeData(\n  fromLocaleData: Data,\n  toLocaleData: Data,\n  fields: Field[],\n  req: PayloadRequest,\n  parentIsLocalized: boolean,\n): Data {\n  iterateFields(fields, fromLocaleData, toLocaleData, req, parentIsLocalized)\n\n  return toLocaleData\n}\n\n/**\n * We don't have to recursively remove all ids,\n * just the ones from the fields inside a localized array or block.\n */\nfunction removeIdIfParentIsLocalized(data: Data, fields: Field[]): Data {\n  traverseFields({\n    callback: ({ parentIsLocalized, ref }) => {\n      if (parentIsLocalized) {\n        delete (ref as { id: unknown }).id\n      }\n    },\n    fields,\n    fillEmpty: false,\n    ref: data,\n  })\n\n  return data\n}\n\nexport const copyDataFromLocaleHandler: ServerFunction<CopyDataFromLocaleArgs> = async (args) => {\n  const { req } = args\n\n  try {\n    return await copyDataFromLocale(args)\n  } catch (err) {\n    req.payload.logger.error({\n      err,\n      msg: `There was an error copying data from \"${args.fromLocale}\" to \"${args.toLocale}\"`,\n    })\n\n    if (err.message === 'Unauthorized') {\n      return null\n    }\n\n    return formatErrors(err)\n  }\n}\n\nexport const copyDataFromLocale = async (args: CopyDataFromLocaleArgs) => {\n  const {\n    collectionSlug,\n    docID,\n    fromLocale,\n    globalSlug,\n    overrideData = false,\n    req: {\n      payload,\n      payload: { collections, globals },\n      user,\n    },\n    req,\n    toLocale,\n  } = args\n\n  await canAccessAdmin({ req })\n\n  const [fromLocaleData, toLocaleData] = await Promise.allSettled([\n    globalSlug\n      ? payload.findGlobal({\n          slug: globalSlug,\n          depth: 0,\n          locale: fromLocale,\n          overrideAccess: false,\n          user,\n          // `select` would allow us to select only the fields we need in the future\n        })\n      : payload.findByID({\n          id: docID,\n          collection: collectionSlug,\n          depth: 0,\n          joins: false,\n          locale: fromLocale,\n          overrideAccess: false,\n          user,\n          // `select` would allow us to select only the fields we need in the future\n        }),\n    globalSlug\n      ? payload.findGlobal({\n          slug: globalSlug,\n          depth: 0,\n          locale: toLocale,\n          overrideAccess: false,\n          user,\n          // `select` would allow us to select only the fields we need in the future\n        })\n      : payload.findByID({\n          id: docID,\n          collection: collectionSlug,\n          depth: 0,\n          joins: false,\n          locale: toLocale,\n          overrideAccess: false,\n          user,\n          // `select` would allow us to select only the fields we need in the future\n        }),\n  ])\n\n  if (fromLocaleData.status === 'rejected') {\n    throw new Error(`Error fetching data from locale \"${fromLocale}\"`)\n  }\n\n  if (toLocaleData.status === 'rejected') {\n    throw new Error(`Error fetching data from locale \"${toLocale}\"`)\n  }\n\n  const fields = globalSlug\n    ? globals[globalSlug].config.fields\n    : collections[collectionSlug].config.fields\n\n  const fromLocaleDataWithoutID = fromLocaleData.value\n  const toLocaleDataWithoutID = toLocaleData.value\n\n  const dataWithID = overrideData\n    ? fromLocaleDataWithoutID\n    : mergeData(fromLocaleDataWithoutID, toLocaleDataWithoutID, fields, req, false)\n\n  const data = removeIdIfParentIsLocalized(dataWithID, fields)\n\n  return globalSlug\n    ? await payload.updateGlobal({\n        slug: globalSlug,\n        data,\n        locale: toLocale,\n        overrideAccess: false,\n        req,\n        user,\n      })\n    : await payload.update({\n        id: docID,\n        collection: collectionSlug,\n        data,\n        locale: toLocale,\n        overrideAccess: false,\n        req,\n        user,\n      })\n}\n"],"mappings":"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","ignoreList":[]}