{"version":3,"file":"buildFormState.js","names":["canAccessAdmin","formatErrors","getSelectMode","reduceFieldsToValues","fieldSchemasToFormState","renderField","getClientConfig","getClientSchemaMap","getSchemaMap","handleFormStateLocking","handleLivePreview","buildFormStateHandler","args","req","res","buildFormState","err","payload","logger","error","msg","message","Error","id","idFromArgs","collectionSlug","data","incomingData","docPermissions","docPreferences","documentFormState","formState","globalSlug","initialBlockData","initialBlockFormState","mockRSCs","operation","readOnly","renderAllFields","i18n","config","returnLivePreviewURL","returnLockStatus","schemaPath","select","skipClientConfigAuth","skipValidation","updateLastEdited","selectMode","undefined","schemaMap","clientSchemaMap","importMap","user","fieldOrEntityConfig","get","fields","length","type","documentData","blockData","Array","isArray","formStateResult","clientFieldSchemaMap","fieldSchemaMap","permissions","preferences","previousFormState","renderFieldFn","collections","upload","file","lockedStateResult","lockedState","state","livePreviewURL"],"sources":["../../src/utilities/buildFormState.ts"],"sourcesContent":["import type {\n  BuildFormStateArgs,\n  ClientConfig,\n  ClientUser,\n  ErrorResult,\n  FormState,\n  ServerFunction,\n} from 'payload'\n\nimport { canAccessAdmin, formatErrors } from 'payload'\nimport { getSelectMode, reduceFieldsToValues } from 'payload/shared'\n\nimport { fieldSchemasToFormState } from '../forms/fieldSchemasToFormState/index.js'\nimport { renderField } from '../forms/fieldSchemasToFormState/renderField.js'\nimport { getClientConfig } from './getClientConfig.js'\nimport { getClientSchemaMap } from './getClientSchemaMap.js'\nimport { getSchemaMap } from './getSchemaMap.js'\nimport { handleFormStateLocking } from './handleFormStateLocking.js'\nimport { handleLivePreview } from './handleLivePreview.js'\n\nexport type LockedState = {\n  isLocked: boolean\n  lastEditedAt: string\n  user: ClientUser | number | string\n}\n\ntype BuildFormStateSuccessResult = {\n  clientConfig?: ClientConfig\n  errors?: never\n  indexPath?: string\n  livePreviewURL?: string\n  lockedState?: LockedState\n  state: FormState\n}\n\ntype BuildFormStateErrorResult = {\n  livePreviewURL?: never\n  lockedState?: never\n  state?: never\n} & (\n  | {\n      message: string\n    }\n  | ErrorResult\n)\n\nexport type BuildFormStateResult = BuildFormStateErrorResult | BuildFormStateSuccessResult\n\nexport const buildFormStateHandler: ServerFunction<\n  BuildFormStateArgs,\n  Promise<BuildFormStateResult>\n> = async (args) => {\n  const { req } = args\n\n  try {\n    await canAccessAdmin({ req })\n    const res = await buildFormState(args)\n\n    return res\n  } catch (err) {\n    req.payload.logger.error({ err, msg: `There was an error building form state` })\n\n    if (err.message === 'Could not find field schema for given path') {\n      return {\n        message: err.message,\n      }\n    }\n\n    if (err.message === 'Unauthorized') {\n      throw new Error('Unauthorized')\n    }\n\n    return formatErrors(err)\n  }\n}\n\nexport const buildFormState = async (\n  args: BuildFormStateArgs,\n): Promise<BuildFormStateSuccessResult> => {\n  const {\n    id: idFromArgs,\n    collectionSlug,\n    data: incomingData,\n    docPermissions,\n    docPreferences,\n    documentFormState,\n    formState,\n    globalSlug,\n    initialBlockData,\n    initialBlockFormState,\n    mockRSCs,\n    operation,\n    readOnly,\n    renderAllFields,\n    req,\n    req: {\n      i18n,\n      payload,\n      payload: { config },\n    },\n    returnLivePreviewURL,\n    returnLockStatus,\n    schemaPath = collectionSlug || globalSlug,\n    select,\n    skipClientConfigAuth,\n    skipValidation,\n    updateLastEdited,\n  } = args\n\n  const selectMode = select ? getSelectMode(select) : undefined\n\n  if (!collectionSlug && !globalSlug) {\n    throw new Error('Either collectionSlug or globalSlug must be provided')\n  }\n\n  const schemaMap = getSchemaMap({\n    collectionSlug,\n    config,\n    globalSlug,\n    i18n,\n  })\n\n  const clientSchemaMap = getClientSchemaMap({\n    collectionSlug,\n    config: getClientConfig({\n      config,\n      i18n,\n      importMap: req.payload.importMap,\n      user: skipClientConfigAuth ? true : req.user,\n    }),\n    globalSlug,\n    i18n,\n    payload,\n    schemaMap,\n  })\n\n  const id = collectionSlug ? idFromArgs : undefined\n  const fieldOrEntityConfig = schemaMap.get(schemaPath)\n\n  if (!fieldOrEntityConfig) {\n    throw new Error(`Could not find \"${schemaPath}\" in the fieldSchemaMap`)\n  }\n\n  if (\n    (!('fields' in fieldOrEntityConfig) ||\n      !fieldOrEntityConfig.fields ||\n      !fieldOrEntityConfig.fields.length) &&\n    'type' in fieldOrEntityConfig &&\n    fieldOrEntityConfig.type !== 'blocks'\n  ) {\n    throw new Error(\n      `The field found in fieldSchemaMap for \"${schemaPath}\" does not contain any subfields.`,\n    )\n  }\n\n  // If there is form state but no data, deduce data from that form state, e.g. on initial load\n  // Otherwise, use the incoming data as the source of truth, e.g. on subsequent saves\n  const data = incomingData || reduceFieldsToValues(formState, true)\n\n  let documentData = undefined\n\n  if (documentFormState) {\n    documentData = reduceFieldsToValues(documentFormState, true)\n  }\n\n  let blockData = initialBlockData\n\n  if (initialBlockFormState) {\n    blockData = reduceFieldsToValues(initialBlockFormState, true)\n  }\n\n  /**\n   * When building state for sub schemas we need to adjust:\n   * - `fields`\n   * - `parentSchemaPath`\n   * - `parentPath`\n   *\n   * Type assertion is fine because we wrap sub schemas in an array\n   * so we can safely map over them within `fieldSchemasToFormState`\n   */\n  const fields = Array.isArray(fieldOrEntityConfig)\n    ? fieldOrEntityConfig\n    : 'fields' in fieldOrEntityConfig\n      ? fieldOrEntityConfig.fields\n      : [fieldOrEntityConfig]\n\n  // Ensure data.id is present during form state requests, where the data\n  // is passed from the client as an argument, without the ID\n  if (!data.id && id) {\n    data.id = id\n  }\n\n  const formStateResult = await fieldSchemasToFormState({\n    id,\n    clientFieldSchemaMap: clientSchemaMap,\n    collectionSlug,\n    data,\n    documentData,\n    fields,\n    fieldSchemaMap: schemaMap,\n    initialBlockData: blockData,\n    mockRSCs,\n    operation,\n    permissions: docPermissions?.fields || {},\n    preferences: docPreferences || { fields: {} },\n    previousFormState: formState,\n    readOnly,\n    renderAllFields,\n    renderFieldFn: renderField,\n    req,\n    schemaPath,\n    select,\n    selectMode,\n    skipValidation,\n  })\n\n  // Maintain form state of auth / upload fields\n  if (collectionSlug && formState) {\n    if (payload.collections[collectionSlug]?.config?.upload && formState.file) {\n      formStateResult.file = formState.file\n    }\n  }\n\n  let lockedStateResult\n\n  if (returnLockStatus) {\n    lockedStateResult = await handleFormStateLocking({\n      id,\n      collectionSlug,\n      globalSlug,\n      req,\n      updateLastEdited,\n    })\n  }\n\n  const res: BuildFormStateSuccessResult = {\n    lockedState: lockedStateResult,\n    state: formStateResult,\n  }\n\n  if (returnLivePreviewURL) {\n    const { livePreviewURL } = await handleLivePreview({\n      collectionSlug,\n      config,\n      data,\n      globalSlug,\n      req,\n    })\n\n    // Important: only set this when not undefined,\n    // Otherwise it will travel through the network as `$undefined`\n    if (livePreviewURL) {\n      res.livePreviewURL = livePreviewURL\n    }\n  }\n\n  return res\n}\n"],"mappings":"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","ignoreList":[]}