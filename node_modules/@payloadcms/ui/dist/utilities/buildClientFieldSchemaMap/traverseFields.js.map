{"version":3,"file":"traverseFields.js","names":["createClientFields","fieldAffectsData","getFieldPaths","tabHasName","traverseFields","clientSchemaMap","config","fields","i18n","parentIndexPath","parentSchemaPath","payload","schemaMap","index","field","entries","indexPath","schemaPath","parentPath","set","type","blockReferences","blocks","map","_block","block","blocksMap","find","slug","blockSchemaPath","richTextFieldSchemaMap","Map","path","subField","startsWith","isFieldsOnly","Object","keys","length","clientFields","defaultIDType","db","disableAddingID","importMap","tabs","tab","tabIndex","isNamedTab","tabIndexPath","tabSchemaPath"],"sources":["../../../src/utilities/buildClientFieldSchemaMap/traverseFields.ts"],"sourcesContent":["import type { I18n } from '@payloadcms/translations'\n\nimport {\n  type ClientConfig,\n  type ClientField,\n  type ClientFieldSchemaMap,\n  createClientFields,\n  type Field,\n  type FieldSchemaMap,\n  type Payload,\n} from 'payload'\nimport { fieldAffectsData, getFieldPaths, tabHasName } from 'payload/shared'\n\ntype Args = {\n  clientSchemaMap: ClientFieldSchemaMap\n  config: ClientConfig\n  fields: ClientField[]\n  i18n: I18n<any, any>\n  parentIndexPath: string\n  parentSchemaPath: string\n  payload: Payload\n  schemaMap: FieldSchemaMap\n}\n\nexport const traverseFields = ({\n  clientSchemaMap,\n  config,\n  fields,\n  i18n,\n  parentIndexPath,\n  parentSchemaPath,\n  payload,\n  schemaMap,\n}: Args) => {\n  for (const [index, field] of fields.entries()) {\n    const { indexPath, schemaPath } = getFieldPaths({\n      field,\n      index,\n      parentIndexPath: 'name' in field ? '' : parentIndexPath,\n      parentPath: '',\n      parentSchemaPath,\n    })\n\n    clientSchemaMap.set(schemaPath, field)\n\n    switch (field.type) {\n      case 'array': {\n        traverseFields({\n          clientSchemaMap,\n          config,\n          fields: field.fields,\n          i18n,\n          parentIndexPath: '',\n          parentSchemaPath: schemaPath,\n          payload,\n          schemaMap,\n        })\n\n        break\n      }\n\n      case 'blocks':\n        ;(field.blockReferences ?? field.blocks).map((_block) => {\n          const block =\n            typeof _block === 'string'\n              ? config.blocksMap\n                ? config.blocksMap[_block]\n                : config.blocks.find((block) => typeof block !== 'string' && block.slug === _block)\n              : _block\n\n          const blockSchemaPath = `${schemaPath}.${block.slug}`\n\n          clientSchemaMap.set(blockSchemaPath, block)\n          traverseFields({\n            clientSchemaMap,\n            config,\n            fields: block.fields,\n            i18n,\n            parentIndexPath: '',\n            parentSchemaPath: blockSchemaPath,\n            payload,\n            schemaMap,\n          })\n        })\n\n        break\n\n      case 'collapsible':\n      case 'row':\n        traverseFields({\n          clientSchemaMap,\n          config,\n          fields: field.fields,\n          i18n,\n          parentIndexPath: indexPath,\n          parentSchemaPath,\n          payload,\n          schemaMap,\n        })\n        break\n\n      case 'group': {\n        if (fieldAffectsData(field)) {\n          traverseFields({\n            clientSchemaMap,\n            config,\n            fields: field.fields,\n            i18n,\n            parentIndexPath: '',\n            parentSchemaPath: schemaPath,\n            payload,\n            schemaMap,\n          })\n        } else {\n          traverseFields({\n            clientSchemaMap,\n            config,\n            fields: field.fields,\n            i18n,\n            parentIndexPath: indexPath,\n            parentSchemaPath,\n            payload,\n            schemaMap,\n          })\n        }\n        break\n      }\n\n      case 'richText': {\n        // richText sub-fields are not part of the ClientConfig or the Config.\n        // They only exist in the field schema map.\n        // Thus, we need to\n        // 1. get them from the field schema map\n        // 2. convert them to client fields\n        // 3. add them to the client schema map\n\n        // So these would basically be all fields that are not part of the client config already\n        const richTextFieldSchemaMap: FieldSchemaMap = new Map()\n        for (const [path, subField] of schemaMap.entries()) {\n          if (path.startsWith(`${schemaPath}.`)) {\n            richTextFieldSchemaMap.set(path, subField)\n          }\n        }\n\n        // Now loop through them, convert each entry to a client field and add it to the client schema map\n        for (const [path, subField] of richTextFieldSchemaMap.entries()) {\n          // check if fields is the only key in the subField object\n          const isFieldsOnly = Object.keys(subField).length === 1 && 'fields' in subField\n\n          const clientFields = createClientFields({\n            defaultIDType: payload.config.db.defaultIDType,\n            disableAddingID: true,\n            fields: isFieldsOnly ? subField.fields : [subField as Field],\n            i18n,\n            importMap: payload.importMap,\n          })\n\n          clientSchemaMap.set(\n            path,\n            isFieldsOnly\n              ? {\n                  fields: clientFields,\n                }\n              : clientFields[0],\n          )\n        }\n        break\n      }\n\n      case 'tabs':\n        field.tabs.map((tab, tabIndex) => {\n          const isNamedTab = tabHasName(tab)\n\n          const { indexPath: tabIndexPath, schemaPath: tabSchemaPath } = getFieldPaths({\n            field: {\n              ...tab,\n              type: 'tab',\n            },\n            index: tabIndex,\n            parentIndexPath: indexPath,\n            parentPath: '',\n            parentSchemaPath,\n          })\n\n          clientSchemaMap.set(tabSchemaPath, tab)\n\n          traverseFields({\n            clientSchemaMap,\n            config,\n            fields: tab.fields,\n            i18n,\n            parentIndexPath: isNamedTab ? '' : tabIndexPath,\n            parentSchemaPath: isNamedTab ? tabSchemaPath : parentSchemaPath,\n            payload,\n            schemaMap,\n          })\n        })\n\n        break\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]}