{"version":3,"file":"nodeTypes.js","names":[],"sources":["../src/nodeTypes.ts"],"sourcesContent":["import type {\n  SerializedLineBreakNode as _SerializedLineBreakNode,\n  SerializedTabNode as _SerializedTabNode,\n  SerializedTextNode as _SerializedTextNode,\n  SerializedEditorState,\n  SerializedElementNode,\n  SerializedLexicalNode,\n} from 'lexical'\n\nimport type { SerializedQuoteNode } from './features/blockquote/server/index.js'\nimport type { SerializedBlockNode } from './features/blocks/server/nodes/BlocksNode.js'\nimport type { SerializedInlineBlockNode } from './features/blocks/server/nodes/InlineBlocksNode.js'\nimport type {\n  SerializedTableCellNode,\n  SerializedTableNode,\n  SerializedTableRowNode,\n} from './features/experimental_table/server/index.js'\nimport type { SerializedHeadingNode } from './features/heading/server/index.js'\nimport type { SerializedHorizontalRuleNode } from './features/horizontalRule/server/nodes/HorizontalRuleNode.js'\nimport type { SerializedAutoLinkNode, SerializedLinkNode } from './features/link/nodes/types.js'\nimport type { SerializedListItemNode, SerializedListNode } from './features/lists/plugin/index.js'\nimport type { SerializedRelationshipNode } from './features/relationship/server/nodes/RelationshipNode.js'\nimport type { SerializedUploadNode } from './features/upload/server/nodes/UploadNode.js'\n\n/**\n * Helper type to create strongly typed serialized nodes with flexible children types.\n * Omits 'children' and 'type' from the base node type and redeclares them with proper typing.\n *\n * @param TBase - The base Lexical node type (e.g., _SerializedHeadingNode)\n * @param TType - The node type string (e.g., 'heading')\n * @param TChildren - The type for children (defaults to SerializedLexicalNode)\n */\nexport type StronglyTypedElementNode<\n  TBase,\n  TType extends string,\n  TChildren extends SerializedLexicalNode = SerializedLexicalNode,\n> = {\n  children: TChildren[]\n  type: TType\n} & Omit<TBase, 'children' | 'type'>\n\n/**\n * Helper type to create strongly typed leaf nodes (nodes without children).\n * Omits 'children' and 'type' from the base node type and redeclares 'type' with a literal.\n *\n * @param TBase - The base Lexical node type (e.g., _SerializedTextNode)\n * @param TType - The node type string (e.g., 'text')\n */\nexport type StronglyTypedLeafNode<TBase, TType extends string> = {\n  type: TType\n} & Omit<TBase, 'children' | 'type'>\n\nexport type {\n  SerializedAutoLinkNode,\n  SerializedBlockNode,\n  SerializedHeadingNode,\n  SerializedHorizontalRuleNode,\n  SerializedInlineBlockNode,\n  SerializedLinkNode,\n  SerializedListItemNode,\n  SerializedListNode,\n  SerializedQuoteNode,\n  SerializedRelationshipNode,\n  SerializedTableCellNode,\n  SerializedTableNode,\n  SerializedTableRowNode,\n  SerializedUploadNode,\n}\n\nexport type SerializedParagraphNode<T extends SerializedLexicalNode = SerializedLexicalNode> = {\n  textFormat: number\n} & StronglyTypedElementNode<SerializedElementNode, 'paragraph', T>\n\nexport type SerializedTextNode = StronglyTypedLeafNode<_SerializedTextNode, 'text'>\n\nexport type SerializedTabNode = StronglyTypedLeafNode<_SerializedTabNode, 'tab'>\n\nexport type SerializedLineBreakNode = StronglyTypedLeafNode<_SerializedLineBreakNode, 'linebreak'>\n\n/**\n * Recursively adds typed children to nodes up to a specified depth.\n *\n * Key behaviors:\n * - `T extends any`: Distributive - processes each union member individually\n * - `OriginalUnion`: Preserves full union so nested children accept all node types, not just parent's type. If we just used `T`, the type would be narrowed to the parent's type and the children would only consist of the parent's type.\n * - `'children' extends keyof T`: Only adds children to container nodes; respects leaf nodes that use `Omit<_, 'children'>`\n * - `Depth`: Limits recursion to prevent infinite types (default: 4 levels)\n *\n * @internal - this type may change or be removed in a minor release\n */\nexport type RecursiveNodes<\n  T extends SerializedLexicalNode,\n  Depth extends number = 4,\n  OriginalUnion extends SerializedLexicalNode = T,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n> = T extends any // Make distributive over unions\n  ? Depth extends 0\n    ? T\n    : 'children' extends keyof T\n      ? { children?: RecursiveNodes<OriginalUnion, DecrementDepth<Depth>, OriginalUnion>[] } & T\n      : T // Skip leaf nodes\n  : never\n\n/** Decrements depth: 4→3, 3→2, 2→1, 1→0, 0→0 */\ntype DecrementDepth<N extends number> = [0, 0, 1, 2, 3, 4][N]\n\n/**\n * Alternative type to `SerializedEditorState` that automatically types your nodes\n * more strictly, narrowing down nodes based on the `type` without having to manually\n * type-cast.\n */\nexport type TypedEditorState<T extends SerializedLexicalNode = SerializedLexicalNode> = {\n  [k: string]: unknown\n} & SerializedEditorState<RecursiveNodes<T>>\n\n/**\n * All node types included by default in a lexical editor without configuration.\n */\nexport type DefaultNodeTypes =\n  | SerializedAutoLinkNode\n  //| SerializedBlockNode // Not included by default\n  | SerializedHeadingNode\n  | SerializedHorizontalRuleNode\n  | SerializedLineBreakNode\n  | SerializedLinkNode\n  | SerializedListItemNode\n  | SerializedListNode\n  | SerializedParagraphNode\n  | SerializedQuoteNode\n  | SerializedRelationshipNode\n  | SerializedTabNode\n  | SerializedTextNode\n  | SerializedUploadNode\n\n/**\n * Like `TypedEditorState` but includes all default node types.\n * You can pass *additional* node types as a generic parameter.\n */\nexport type DefaultTypedEditorState<\n  TAdditionalNodeTypes extends null | SerializedLexicalNode = null,\n> = [TAdditionalNodeTypes] extends null\n  ? TypedEditorState<DefaultNodeTypes>\n  : TypedEditorState<DefaultNodeTypes | NonNullable<TAdditionalNodeTypes>>\n"],"mappings":"AAsIA;;;GAIA","ignoreList":[]}