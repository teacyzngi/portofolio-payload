{"version":3,"file":"index.js","names":["afterChangeTraverseFields","afterReadTraverseFields","beforeChangeTraverseFields","beforeValidateTraverseFields","checkDependencies","withNullableJSONSchemaType","getDefaultSanitizedEditorConfig","i18n","defaultEditorFeatures","populateLexicalPopulationPromises","featuresInputToEditorConfig","getGenerateImportMap","getGenerateSchemaMap","recurseNodeTree","richTextValidateHOC","checkedDependencies","lexicalTargetVersion","lexicalEditor","args","process","env","NODE_ENV","PAYLOAD_DISABLE_DEPENDENCY_CHECKER","dependencyGroups","name","dependencies","targetVersion","config","isRoot","parentIsLocalized","features","resolvedFeatureMap","finalSanitizedEditorConfig","lexical","result","sanitizedConfig","featureI18n","lang","general","CellComponent","path","serverProps","admin","sanitizedEditorConfig","DiffComponent","editorConfig","FieldComponent","generateImportMap","generateSchemaMap","graphQLPopulationPromises","context","currentDepth","depth","draft","field","fieldPromises","findMany","flattenLocales","overrideAccess","populationPromises","req","showHiddenFields","siblingDoc","size","editorPopulationPromises","hooks","afterChange","collection","_context","data","global","indexPath","operation","originalDoc","previousDoc","previousValue","schemaPath","value","length","hook","nodeHooks","getSubFields","nodeIDMap","previousNodeIDMap","originalNodeIDMap","internal","richText","join","Object","keys","nodes","root","children","id","node","entries","afterChangeHooks","afterChangeHooksForNode","get","type","console","warn","originalNode","parentRichTextFieldPath","parentRichTextFieldSchemaPath","previousNode","subFieldFn","subFieldDataFn","getSubFieldsData","subFields","nodeSiblingData","nodeSiblingDoc","nodePreviousSiblingDoc","blockData","doc","fields","parentIndexPath","localized","parentPath","parentSchemaPath","previousSiblingDoc","siblingData","afterRead","fallbackLocale","locale","populate","triggerAccessControl","triggerHooks","flattenedNodes","afterReadHooks","afterReadHooksForNode","populateArg","beforeChange","docWithLocales","errors","fieldLabelPath","mergeLocaleActions","siblingDocWithLocales","skipValidation","originalNodeWithLocalesIDMap","beforeChangeHooks","beforeChangeHooksForNode","originalNodeWithLocales","nodeSiblingDocWithLocales","newOriginalNodeIDMap","previousOriginalValue","beforeValidate","beforeValidateHooks","beforeValidateHooksForNode","outputSchema","collectionIDFieldTypes","interfaceNameDefinitions","isRequired","properties","additionalProperties","items","tsType","version","required","direction","oneOf","enum","format","indent","modifyOutputSchema","generatedTypes","modifyOutputSchemas","currentSchema","validate","AlignFeature","BlockquoteFeature","CodeBlock","BlocksFeature","$createServerBlockNode","$isServerBlockNode","ServerBlockNode","convertHTMLToLexical","lexicalHTMLField","LinebreakHTMLConverter","ParagraphHTMLConverter","TabHTMLConverter","TextHTMLConverter","defaultHTMLConverters","convertLexicalNodesToHTML","convertLexicalToHTML","consolidateHTMLConverters","lexicalHTML","HTMLConverterFeature","convertLexicalToMarkdown","convertMarkdownToLexical","getPayloadPopulateFn","getRestPopulateFn","DebugJsxConverterFeature","TestRecorderFeature","TreeViewFeature","EXPERIMENTAL_TableFeature","BoldFeature","InlineCodeFeature","ItalicFeature","StrikethroughFeature","SubscriptFeature","SuperscriptFeature","UnderlineFeature","HeadingFeature","HorizontalRuleFeature","IndentFeature","$createAutoLinkNode","$isAutoLinkNode","AutoLinkNode","$createLinkNode","$isLinkNode","LinkNode","LinkFeature","ChecklistFeature","OrderedListFeature","UnorderedListFeature","ParagraphFeature","RelationshipFeature","RelationshipServerNode","defaultColors","TextStateFeature","FixedToolbarFeature","InlineToolbarFeature","createNode","UploadFeature","UploadServerNode","defaultEditorConfig","defaultEditorLexicalConfig","loadFeatures","sortFeaturesForOptimalLoading","sanitizeServerEditorConfig","sanitizeServerFeatures","getEnabledNodes","getEnabledNodesFromServerNodes","DETAIL_TYPE_TO_DETAIL","DOUBLE_LINE_BREAK","ELEMENT_FORMAT_TO_TYPE","ELEMENT_TYPE_TO_FORMAT","IS_ALL_FORMATTING","LTR_REGEX","NodeFormat","NON_BREAKING_SPACE","RTL_REGEX","TEXT_MODE_TO_TYPE","TEXT_TYPE_TO_FORMAT","TEXT_TYPE_TO_MODE","sanitizeUrl","validateUrl","$convertFromMarkdownString","defaultRichTextValue","buildDefaultEditorState","buildEditorState","createServerFeature","editorConfigFactory","extractPropsFromJSXPropsString","extractFrontmatter","frontmatterToObject","objectToFrontmatter","propsToJSXString","upgradeLexicalData"],"sources":["../src/index.ts"],"sourcesContent":["import type { JSONSchema4 } from 'json-schema'\nimport type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\n\nimport {\n  afterChangeTraverseFields,\n  afterReadTraverseFields,\n  beforeChangeTraverseFields,\n  beforeValidateTraverseFields,\n  checkDependencies,\n  withNullableJSONSchemaType,\n} from 'payload'\n\nimport type { FeatureProviderServer, ResolvedServerFeatureMap } from './features/typesServer.js'\nimport type { SanitizedServerEditorConfig } from './lexical/config/types.js'\nimport type { AdapterProps, LexicalEditorProps, LexicalRichTextAdapterProvider } from './types.js'\n\nimport { getDefaultSanitizedEditorConfig } from './getDefaultSanitizedEditorConfig.js'\nimport { i18n } from './i18n.js'\nimport { defaultEditorFeatures } from './lexical/config/server/default.js'\nimport { populateLexicalPopulationPromises } from './populateGraphQL/populateLexicalPopulationPromises.js'\nimport { featuresInputToEditorConfig } from './utilities/editorConfigFactory.js'\nimport { getGenerateImportMap } from './utilities/generateImportMap.js'\nimport { getGenerateSchemaMap } from './utilities/generateSchemaMap.js'\nimport { recurseNodeTree } from './utilities/recurseNodeTree.js'\nimport { richTextValidateHOC } from './validate/index.js'\n\nlet checkedDependencies = false\n\nexport const lexicalTargetVersion = '0.35.0'\n\nexport function lexicalEditor(args?: LexicalEditorProps): LexicalRichTextAdapterProvider {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    process.env.PAYLOAD_DISABLE_DEPENDENCY_CHECKER !== 'true' &&\n    !checkedDependencies\n  ) {\n    checkedDependencies = true\n    void checkDependencies({\n      dependencyGroups: [\n        {\n          name: 'lexical',\n          dependencies: [\n            'lexical',\n            '@lexical/headless',\n            '@lexical/link',\n            '@lexical/list',\n            '@lexical/mark',\n            '@lexical/react',\n            '@lexical/rich-text',\n            '@lexical/selection',\n            '@lexical/utils',\n          ],\n          targetVersion: lexicalTargetVersion,\n        },\n      ],\n    })\n  }\n  return async ({ config, isRoot, parentIsLocalized }) => {\n    let features: FeatureProviderServer<unknown, unknown, unknown>[] = []\n    let resolvedFeatureMap: ResolvedServerFeatureMap\n\n    let finalSanitizedEditorConfig: SanitizedServerEditorConfig // For server only\n    if (!args || (!args.features && !args.lexical)) {\n      finalSanitizedEditorConfig = await getDefaultSanitizedEditorConfig({\n        config,\n        parentIsLocalized,\n      })\n\n      features = defaultEditorFeatures\n\n      resolvedFeatureMap = finalSanitizedEditorConfig.resolvedFeatureMap\n    } else {\n      const result = await featuresInputToEditorConfig({\n        config,\n        features: args?.features,\n        isRoot,\n        lexical: args?.lexical,\n        parentIsLocalized,\n      })\n      finalSanitizedEditorConfig = result.sanitizedConfig\n      features = result.features\n      resolvedFeatureMap = result.resolvedFeatureMap\n    }\n\n    const featureI18n = finalSanitizedEditorConfig.features.i18n\n    for (const lang in i18n) {\n      if (!featureI18n[lang as keyof typeof featureI18n]) {\n        featureI18n[lang as keyof typeof featureI18n] = {\n          lexical: {},\n        }\n      }\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      featureI18n[lang].lexical.general = i18n[lang]\n    }\n\n    return {\n      CellComponent: {\n        path: '@payloadcms/richtext-lexical/rsc#RscEntryLexicalCell',\n        serverProps: {\n          admin: args?.admin,\n          sanitizedEditorConfig: finalSanitizedEditorConfig,\n        },\n      },\n      DiffComponent: {\n        path: '@payloadcms/richtext-lexical/rsc#LexicalDiffComponent',\n        serverProps: {\n          admin: args?.admin,\n          sanitizedEditorConfig: finalSanitizedEditorConfig,\n        },\n      },\n      editorConfig: finalSanitizedEditorConfig,\n      features,\n      FieldComponent: {\n        path: '@payloadcms/richtext-lexical/rsc#RscEntryLexicalField',\n        serverProps: {\n          admin: args?.admin,\n          sanitizedEditorConfig: finalSanitizedEditorConfig,\n        },\n      },\n      generateImportMap: getGenerateImportMap({\n        resolvedFeatureMap,\n      }),\n      generateSchemaMap: getGenerateSchemaMap({\n        resolvedFeatureMap,\n      }),\n      graphQLPopulationPromises({\n        context,\n        currentDepth,\n        depth,\n        draft,\n        field,\n        fieldPromises,\n        findMany,\n        flattenLocales,\n        overrideAccess,\n        parentIsLocalized,\n        populationPromises,\n        req,\n        showHiddenFields,\n        siblingDoc,\n      }) {\n        // check if there are any features with nodes which have populationPromises for this field\n        if (finalSanitizedEditorConfig?.features?.graphQLPopulationPromises?.size) {\n          populateLexicalPopulationPromises({\n            context,\n            currentDepth: currentDepth ?? 0,\n            depth,\n            draft,\n            editorPopulationPromises: finalSanitizedEditorConfig.features.graphQLPopulationPromises,\n            field,\n            fieldPromises,\n            findMany,\n            flattenLocales,\n            overrideAccess,\n            parentIsLocalized,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc,\n          })\n        }\n      },\n      hooks: {\n        afterChange: [\n          async (args) => {\n            const {\n              collection,\n              context: _context,\n              data,\n              field,\n              global,\n              indexPath,\n              operation,\n              originalDoc,\n              parentIsLocalized,\n              path,\n              previousDoc,\n              previousValue,\n              req,\n              schemaPath,\n            } = args\n\n            let { value } = args\n            if (finalSanitizedEditorConfig?.features?.hooks?.afterChange?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.afterChange) {\n                value = await hook(args)\n              }\n            }\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n            // TO-DO: We should not use context, as it is intended for external use only\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const context: any = _context\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            const previousNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            /**\n             * Get the originalNodeIDMap from the beforeValidate hook, which is always run before this hook.\n             */\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = context?.internal?.richText?.[path.join('.')]?.originalNodeIDMap\n\n            if (!originalNodeIDMap || !Object.keys(originalNodeIDMap).length || !value) {\n              return value\n            }\n\n            recurseNodeTree({\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            recurseNodeTree({\n              nodeIDMap: previousNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const afterChangeHooks = finalSanitizedEditorConfig.features.nodeHooks?.afterChange\n              const afterChangeHooksForNode = afterChangeHooks?.get(node.type)\n              if (afterChangeHooksForNode) {\n                for (const hook of afterChangeHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(afterChange) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n\n                    previousNode: previousNodeIDMap[id]!,\n                    req,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n\n                const nodeSiblingDoc = subFieldDataFn({ node: originalNodeIDMap[id]!, req }) ?? {}\n                const nodePreviousSiblingDoc =\n                  subFieldDataFn({ node: previousNodeIDMap[id]!, req }) ?? {}\n\n                if (subFields?.length) {\n                  await afterChangeTraverseFields({\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    data: data ?? {},\n                    doc: originalDoc,\n                    fields: subFields,\n                    global,\n                    operation,\n                    parentIndexPath: indexPath.join('-'),\n                    parentIsLocalized: parentIsLocalized || field.localized || false,\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    previousDoc,\n                    previousSiblingDoc: { ...nodePreviousSiblingDoc },\n                    req,\n                    siblingData: nodeSiblingData || {},\n                    siblingDoc: { ...nodeSiblingDoc },\n                  })\n                }\n              }\n            }\n            return value\n          },\n        ],\n        afterRead: [\n          /**\n           * afterRead hooks do not receive the originalNode. Thus, they can run on all nodes, not just nodes with an ID.\n           */\n          async (args) => {\n            const {\n              collection,\n              context: context,\n              currentDepth,\n              depth,\n              draft,\n              fallbackLocale,\n              field,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              indexPath,\n              locale,\n              originalDoc,\n              overrideAccess,\n              parentIsLocalized,\n              path,\n              populate,\n              populationPromises,\n              req,\n              schemaPath,\n              showHiddenFields,\n              triggerAccessControl,\n              triggerHooks,\n            } = args\n\n            let { value } = args\n\n            if (finalSanitizedEditorConfig?.features?.hooks?.afterRead?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.afterRead) {\n                value = await hook(args)\n              }\n            }\n\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterRead?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n            const flattenedNodes: SerializedLexicalNode[] = []\n\n            recurseNodeTree({\n              flattenedNodes,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            for (let node of flattenedNodes) {\n              const afterReadHooks = finalSanitizedEditorConfig.features.nodeHooks?.afterRead\n              const afterReadHooksForNode = afterReadHooks?.get(node.type)\n              if (afterReadHooksForNode) {\n                for (const hook of afterReadHooksForNode) {\n                  node = await hook({\n                    context,\n                    currentDepth: currentDepth!,\n                    depth: depth!,\n                    draft: draft!,\n                    fallbackLocale: fallbackLocale!,\n                    fieldPromises: fieldPromises!,\n                    findMany: findMany!,\n                    flattenLocales: flattenLocales!,\n                    locale: locale!,\n                    node,\n                    overrideAccess: overrideAccess!,\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    populateArg: populate,\n                    populationPromises: populationPromises!,\n                    req,\n                    showHiddenFields: showHiddenFields!,\n                    triggerAccessControl: triggerAccessControl!,\n                    triggerHooks: triggerHooks!,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n\n                if (subFields?.length) {\n                  afterReadTraverseFields({\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    currentDepth: currentDepth!,\n                    depth: depth!,\n                    doc: originalDoc,\n                    draft: draft!,\n                    fallbackLocale: fallbackLocale!,\n                    fieldPromises: fieldPromises!,\n                    fields: subFields,\n                    findMany: findMany!,\n                    flattenLocales: flattenLocales!,\n                    global,\n                    locale: locale!,\n                    overrideAccess: overrideAccess!,\n                    parentIndexPath: indexPath.join('-'),\n                    parentIsLocalized: parentIsLocalized || field.localized || false,\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    populate,\n                    populationPromises: populationPromises!,\n                    req,\n                    showHiddenFields: showHiddenFields!,\n                    siblingDoc: nodeSiblingData,\n                    triggerAccessControl,\n                    triggerHooks,\n                  })\n                }\n              }\n            }\n\n            return value\n          },\n        ],\n        beforeChange: [\n          async (args) => {\n            const {\n              collection,\n              context: _context,\n              data,\n              docWithLocales,\n              errors,\n              field,\n              fieldLabelPath,\n              global,\n              indexPath,\n              mergeLocaleActions,\n              operation,\n              originalDoc,\n              overrideAccess,\n              parentIsLocalized,\n              path,\n              previousValue,\n              req,\n              schemaPath,\n              siblingData,\n              siblingDocWithLocales,\n              skipValidation,\n            } = args\n\n            let { value } = args\n\n            if (finalSanitizedEditorConfig?.features?.hooks?.beforeChange?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.beforeChange) {\n                value = await hook(args)\n              }\n            }\n\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n\n            // TO-DO: We should not use context, as it is intended for external use only\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const context: any = _context\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            /**\n             * Get the originalNodeIDMap from the beforeValidate hook, which is always run before this hook.\n             */\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = context?.internal?.richText?.[path.join('.')]?.originalNodeIDMap\n\n            if (!originalNodeIDMap || !Object.keys(originalNodeIDMap).length || !value) {\n              return value\n            }\n\n            const previousNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            const originalNodeWithLocalesIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            recurseNodeTree({\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            recurseNodeTree({\n              nodeIDMap: previousNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n            if (field.name && siblingDocWithLocales?.[field.name]) {\n              recurseNodeTree({\n                nodeIDMap: originalNodeWithLocalesIDMap,\n                nodes:\n                  (siblingDocWithLocales[field.name] as SerializedEditorState)?.root?.children ??\n                  [],\n              })\n            }\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const beforeChangeHooks = finalSanitizedEditorConfig.features.nodeHooks?.beforeChange\n              const beforeChangeHooksForNode = beforeChangeHooks?.get(node.type)\n              if (beforeChangeHooksForNode) {\n                for (const hook of beforeChangeHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(beforeChange) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    errors: errors!,\n                    mergeLocaleActions: mergeLocaleActions!,\n                    node,\n                    operation: operation!,\n                    originalNode: originalNodeIDMap[id],\n                    originalNodeWithLocales: originalNodeWithLocalesIDMap[id],\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    previousNode: previousNodeIDMap[id]!,\n                    req,\n                    skipValidation: skipValidation!,\n                  })\n                }\n              }\n\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n                const nodeSiblingDocWithLocales =\n                  subFieldDataFn({\n                    node: originalNodeWithLocalesIDMap[id]!,\n                    req,\n                  }) ?? {}\n                const nodePreviousSiblingDoc =\n                  subFieldDataFn({ node: previousNodeIDMap[id]!, req }) ?? {}\n\n                if (subFields?.length) {\n                  await beforeChangeTraverseFields({\n                    id,\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    data: data ?? {},\n                    doc: originalDoc ?? {},\n                    docWithLocales: docWithLocales ?? {},\n                    errors: errors!,\n                    fieldLabelPath,\n                    fields: subFields,\n                    global,\n                    mergeLocaleActions: mergeLocaleActions!,\n                    operation: operation!,\n                    overrideAccess,\n                    parentIndexPath: indexPath.join('-'),\n                    parentIsLocalized: parentIsLocalized || field.localized || false,\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    req,\n                    siblingData: nodeSiblingData,\n                    siblingDoc: nodePreviousSiblingDoc,\n                    siblingDocWithLocales: nodeSiblingDocWithLocales ?? {},\n                    skipValidation,\n                  })\n                }\n              }\n            }\n\n            /**\n             * within the beforeChange hook, id's may be re-generated.\n             * Example:\n             * 1. Seed data contains IDs for block feature blocks.\n             * 2. Those are used in beforeValidate\n             * 3. in beforeChange, those IDs are regenerated, because you cannot provide IDs during document creation. See baseIDField beforeChange hook for reasoning\n             * 4. Thus, in order for all post-beforeChange hooks to receive the correct ID, we need to update the originalNodeIDMap with the new ID's, by regenerating the nodeIDMap.\n             * The reason this is not generated for every hook, is to save on performance. We know we only really have to generate it in beforeValidate, which is the first hook,\n             * and in beforeChange, which is where modifications to the provided IDs can occur.\n             */\n            const newOriginalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            const previousOriginalValue = siblingData[field.name!]\n\n            recurseNodeTree({\n              nodeIDMap: newOriginalNodeIDMap,\n              nodes: (previousOriginalValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (!context.internal) {\n              // Add to context, for other hooks to use\n              context.internal = {}\n            }\n            if (!context.internal.richText) {\n              context.internal.richText = {}\n            }\n            context.internal.richText[path.join('.')] = {\n              originalNodeIDMap: newOriginalNodeIDMap,\n            }\n\n            return value\n          },\n        ],\n        beforeValidate: [\n          async (args) => {\n            const {\n              collection,\n              context,\n              data,\n              field,\n              global,\n              indexPath,\n              operation,\n              originalDoc,\n              overrideAccess,\n              parentIsLocalized,\n              path,\n              previousValue,\n              req,\n              schemaPath,\n            } = args\n\n            let { value } = args\n            if (finalSanitizedEditorConfig?.features?.hooks?.beforeValidate?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.beforeValidate) {\n                value = await hook(args)\n              }\n            }\n\n            // return value if there are NO hooks\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeValidate?.size &&\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterChange?.size &&\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n\n            /**\n             * beforeValidate is the first field hook which runs. This is where we can create the node map, which can then be used in the other hooks.\n             *\n             */\n\n            /**\n             * flattenedNodes contains all nodes in the editor, in the order they appear in the editor. They will be used for the following hooks:\n             * - afterRead\n             *\n             * The other hooks require nodes to have IDs, which is why those are ran only from the nodeIDMap. They require IDs because they have both doc/siblingDoc and data/siblingData, and\n             * thus require a reliable way to match new node data to old node data. Given that node positions can change in between hooks, this is only reliably possible for nodes which are saved with\n             * an ID.\n             */\n            //const flattenedNodes: SerializedLexicalNode[] = []\n\n            /**\n             * Only nodes with id's (so, nodes with hooks added to them) will be added to the nodeIDMap. They will be used for the following hooks:\n             * - afterChange\n             * - beforeChange\n             * - beforeValidate\n             *\n             * Other hooks are handled by the flattenedNodes. All nodes in the nodeIDMap are part of flattenedNodes.\n             */\n\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            recurseNodeTree({\n              nodeIDMap: originalNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (!context.internal) {\n              // Add to context, for other hooks to use\n              context.internal = {}\n            }\n            if (!(context as any).internal.richText) {\n              ;(context as any).internal.richText = {}\n            }\n            ;(context as any).internal.richText[path.join('.')] = {\n              originalNodeIDMap,\n            }\n\n            /**\n             * Now that the maps for all hooks are set up, we can run the validate hook\n             */\n            if (!finalSanitizedEditorConfig.features.nodeHooks?.beforeValidate?.size) {\n              return value\n            }\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n            recurseNodeTree({\n              //flattenedNodes,\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const beforeValidateHooks =\n                finalSanitizedEditorConfig.features.nodeHooks.beforeValidate\n              const beforeValidateHooksForNode = beforeValidateHooks?.get(node.type)\n              if (beforeValidateHooksForNode) {\n                for (const hook of beforeValidateHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(beforeValidate) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    overrideAccess: overrideAccess!,\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    req,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n\n                const nodeSiblingDoc = subFieldDataFn({ node: originalNodeIDMap[id]!, req }) ?? {}\n\n                if (subFields?.length) {\n                  await beforeValidateTraverseFields({\n                    id,\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    data,\n                    doc: originalDoc,\n                    fields: subFields,\n                    global,\n                    operation,\n                    overrideAccess: overrideAccess!,\n                    parentIndexPath: indexPath.join('-'),\n                    parentIsLocalized: parentIsLocalized || field.localized || false,\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    req,\n                    siblingData: nodeSiblingData,\n                    siblingDoc: nodeSiblingDoc,\n                  })\n                }\n              }\n            }\n\n            return value\n          },\n        ],\n      },\n      i18n: featureI18n,\n      outputSchema: ({\n        collectionIDFieldTypes,\n        config,\n        field,\n        i18n,\n        interfaceNameDefinitions,\n        isRequired,\n      }) => {\n        let outputSchema: JSONSchema4 = {\n          // This schema matches the SerializedEditorState type so far, that it's possible to cast SerializedEditorState to this schema without any errors.\n          // In the future, we should\n          // 1) allow recursive children\n          // 2) Pass in all the different types for every node added to the editorconfig. This can be done with refs in the schema.\n          type: withNullableJSONSchemaType('object', isRequired),\n          properties: {\n            root: {\n              type: 'object',\n              additionalProperties: false,\n              properties: {\n                type: {\n                  type: 'string',\n                },\n                children: {\n                  type: 'array',\n                  items: {\n                    type: 'object',\n                    additionalProperties: true,\n                    properties: {\n                      type: {\n                        type: 'string',\n                        tsType: 'any',\n                      },\n                      version: {\n                        type: 'integer',\n                      },\n                    },\n                    required: ['type', 'version'],\n                  },\n                },\n                direction: {\n                  oneOf: [\n                    {\n                      enum: ['ltr', 'rtl'],\n                    },\n                    {\n                      type: 'null',\n                    },\n                  ],\n                },\n                format: {\n                  type: 'string',\n                  enum: ['left', 'start', 'center', 'right', 'end', 'justify', ''], // ElementFormatType, since the root node is an element\n                },\n                indent: {\n                  type: 'integer',\n                },\n                version: {\n                  type: 'integer',\n                },\n              },\n              required: ['children', 'direction', 'format', 'indent', 'type', 'version'],\n            },\n          },\n          required: ['root'],\n        }\n        for (const modifyOutputSchema of finalSanitizedEditorConfig.features.generatedTypes\n          .modifyOutputSchemas) {\n          outputSchema = modifyOutputSchema({\n            collectionIDFieldTypes,\n            config,\n            currentSchema: outputSchema,\n            field,\n            i18n,\n            interfaceNameDefinitions,\n            isRequired,\n          })\n        }\n\n        return outputSchema\n      },\n      validate: richTextValidateHOC({\n        editorConfig: finalSanitizedEditorConfig,\n      }),\n    }\n  }\n}\n\nexport { AlignFeature } from './features/align/server/index.js'\nexport { BlockquoteFeature } from './features/blockquote/server/index.js'\nexport { CodeBlock } from './features/blocks/premade/CodeBlock/index.js'\nexport { BlocksFeature, type BlocksFeatureProps } from './features/blocks/server/index.js'\n\nexport {\n  $createServerBlockNode,\n  $isServerBlockNode,\n  type BlockFields,\n  ServerBlockNode,\n} from './features/blocks/server/nodes/BlocksNode.js'\n\nexport { convertHTMLToLexical } from './features/converters/htmlToLexical/index.js'\n\nexport { lexicalHTMLField } from './features/converters/lexicalToHtml/async/field/index.js'\nexport { LinebreakHTMLConverter } from './features/converters/lexicalToHtml_deprecated/converter/converters/linebreak.js'\n\nexport { ParagraphHTMLConverter } from './features/converters/lexicalToHtml_deprecated/converter/converters/paragraph.js'\n\nexport { TabHTMLConverter } from './features/converters/lexicalToHtml_deprecated/converter/converters/tab.js'\nexport { TextHTMLConverter } from './features/converters/lexicalToHtml_deprecated/converter/converters/text.js'\nexport { defaultHTMLConverters } from './features/converters/lexicalToHtml_deprecated/converter/defaultConverters.js'\n\nexport {\n  convertLexicalNodesToHTML,\n  convertLexicalToHTML,\n} from './features/converters/lexicalToHtml_deprecated/converter/index.js'\nexport type { HTMLConverter } from './features/converters/lexicalToHtml_deprecated/converter/types.js'\nexport {\n  consolidateHTMLConverters,\n  lexicalHTML,\n} from './features/converters/lexicalToHtml_deprecated/field/index.js'\nexport {\n  HTMLConverterFeature,\n  type HTMLConverterFeatureProps,\n} from './features/converters/lexicalToHtml_deprecated/index.js'\nexport { convertLexicalToMarkdown } from './features/converters/lexicalToMarkdown/index.js'\nexport { convertMarkdownToLexical } from './features/converters/markdownToLexical/index.js'\nexport { getPayloadPopulateFn } from './features/converters/utilities/payloadPopulateFn.js'\n\nexport { getRestPopulateFn } from './features/converters/utilities/restPopulateFn.js'\nexport { DebugJsxConverterFeature } from './features/debug/jsxConverter/server/index.js'\nexport { TestRecorderFeature } from './features/debug/testRecorder/server/index.js'\nexport { TreeViewFeature } from './features/debug/treeView/server/index.js'\nexport { EXPERIMENTAL_TableFeature } from './features/experimental_table/server/index.js'\nexport { BoldFeature } from './features/format/bold/feature.server.js'\nexport { InlineCodeFeature } from './features/format/inlineCode/feature.server.js'\n\nexport { ItalicFeature } from './features/format/italic/feature.server.js'\nexport { StrikethroughFeature } from './features/format/strikethrough/feature.server.js'\nexport { SubscriptFeature } from './features/format/subscript/feature.server.js'\nexport { SuperscriptFeature } from './features/format/superscript/feature.server.js'\nexport { UnderlineFeature } from './features/format/underline/feature.server.js'\nexport { HeadingFeature, type HeadingFeatureProps } from './features/heading/server/index.js'\nexport { HorizontalRuleFeature } from './features/horizontalRule/server/index.js'\n\nexport { IndentFeature } from './features/indent/server/index.js'\nexport {\n  $createAutoLinkNode,\n  $isAutoLinkNode,\n  AutoLinkNode,\n} from './features/link/nodes/AutoLinkNode.js'\nexport { $createLinkNode, $isLinkNode, LinkNode } from './features/link/nodes/LinkNode.js'\n\nexport type { LinkFields } from './features/link/nodes/types.js'\nexport { LinkFeature, type LinkFeatureServerProps } from './features/link/server/index.js'\n\nexport { ChecklistFeature } from './features/lists/checklist/server/index.js'\nexport { OrderedListFeature } from './features/lists/orderedList/server/index.js'\n\nexport { UnorderedListFeature } from './features/lists/unorderedList/server/index.js'\nexport type {\n  SlateNode,\n  SlateNodeConverter,\n} from './features/migrations/slateToLexical/converter/types.js'\nexport { ParagraphFeature } from './features/paragraph/server/index.js'\n\nexport {\n  RelationshipFeature,\n  type RelationshipFeatureProps,\n} from './features/relationship/server/index.js'\n\nexport {\n  type RelationshipData,\n  RelationshipServerNode,\n} from './features/relationship/server/nodes/RelationshipNode.js'\nexport { defaultColors } from './features/textState/defaultColors.js'\nexport { TextStateFeature } from './features/textState/feature.server.js'\n\nexport { FixedToolbarFeature } from './features/toolbars/fixed/server/index.js'\n\nexport { InlineToolbarFeature } from './features/toolbars/inline/server/index.js'\nexport type { ToolbarGroup, ToolbarGroupItem } from './features/toolbars/types.js'\nexport type {\n  BaseClientFeatureProps,\n  ClientFeature,\n  ClientFeatureProviderMap,\n  FeatureProviderClient,\n  FeatureProviderProviderClient,\n  PluginComponent,\n  PluginComponentWithAnchor,\n  ResolvedClientFeature,\n  ResolvedClientFeatureMap,\n  SanitizedClientFeatures,\n  SanitizedPlugin,\n} from './features/typesClient.js'\n\nexport type {\n  AfterChangeNodeHook,\n  AfterChangeNodeHookArgs,\n  AfterReadNodeHook,\n  AfterReadNodeHookArgs,\n  BaseNodeHookArgs,\n  BeforeChangeNodeHook,\n  BeforeChangeNodeHookArgs,\n  BeforeValidateNodeHook,\n  BeforeValidateNodeHookArgs,\n  FeatureProviderProviderServer,\n  FeatureProviderServer,\n  NodeValidation,\n  NodeWithHooks,\n  PopulationPromise,\n  ResolvedServerFeature,\n  ResolvedServerFeatureMap,\n  SanitizedServerFeatures,\n  ServerFeature,\n  ServerFeatureProviderMap,\n} from './features/typesServer.js'\n\nexport { createNode } from './features/typeUtilities.js' // Only useful in feature.server.ts\n\nexport { UploadFeature } from './features/upload/server/index.js'\nexport type { UploadFeatureProps } from './features/upload/server/index.js'\n\nexport { type UploadData, UploadServerNode } from './features/upload/server/nodes/UploadNode.js'\nexport type { EditorConfigContextType } from './lexical/config/client/EditorConfigProvider.js'\n\nexport {\n  defaultEditorConfig,\n  defaultEditorFeatures,\n  defaultEditorLexicalConfig,\n} from './lexical/config/server/default.js'\nexport { loadFeatures, sortFeaturesForOptimalLoading } from './lexical/config/server/loader.js'\n\nexport {\n  sanitizeServerEditorConfig,\n  sanitizeServerFeatures,\n} from './lexical/config/server/sanitize.js'\nexport type {\n  ClientEditorConfig,\n  SanitizedClientEditorConfig,\n  SanitizedServerEditorConfig,\n  ServerEditorConfig,\n} from './lexical/config/types.js'\nexport type { AdapterProps }\n\nexport { getEnabledNodes, getEnabledNodesFromServerNodes } from './lexical/nodes/index.js'\n\nexport type {\n  SlashMenuGroup,\n  SlashMenuItem,\n} from './lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/types.js'\nexport {\n  DETAIL_TYPE_TO_DETAIL,\n  DOUBLE_LINE_BREAK,\n  ELEMENT_FORMAT_TO_TYPE,\n  ELEMENT_TYPE_TO_FORMAT,\n  IS_ALL_FORMATTING,\n  LTR_REGEX,\n  NodeFormat,\n  NON_BREAKING_SPACE,\n  RTL_REGEX,\n  TEXT_MODE_TO_TYPE,\n  TEXT_TYPE_TO_FORMAT,\n  TEXT_TYPE_TO_MODE,\n} from './lexical/utils/nodeFormat.js'\n\nexport { sanitizeUrl, validateUrl } from './lexical/utils/url.js'\n\nexport type * from './nodeTypes.js'\n\nexport { $convertFromMarkdownString } from './packages/@lexical/markdown/index.js'\nexport { defaultRichTextValue } from './populateGraphQL/defaultValue.js'\nexport { populate } from './populateGraphQL/populate.js'\n\nexport type { LexicalEditorProps, LexicalFieldAdminProps, LexicalRichTextAdapter } from './types.js'\n\nexport { buildDefaultEditorState, buildEditorState } from './utilities/buildEditorState.js'\nexport { createServerFeature } from './utilities/createServerFeature.js'\n\nexport { editorConfigFactory } from './utilities/editorConfigFactory.js'\nexport type { FieldsDrawerProps } from './utilities/fieldsDrawer/Drawer.js'\n\nexport { extractPropsFromJSXPropsString } from './utilities/jsx/extractPropsFromJSXPropsString.js'\n\nexport {\n  extractFrontmatter,\n  frontmatterToObject,\n  objectToFrontmatter,\n  propsToJSXString,\n} from './utilities/jsx/jsx.js'\nexport { upgradeLexicalData } from './utilities/upgradeLexicalData/index.js'\n"],"mappings":"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","ignoreList":[]}