{"version":3,"file":"index.js","names":["c","_c","FieldContext","FieldPathContext","ServerFunctionsContext","ShimmerEffect","useServerFunctions","React","useCallback","useEffect","useRef","RenderLexical","args","$","field","initialValue","Loading","path","schemaPath","setValue","value","Component","setComponent","useState","serverFunctionContext","_internal_renderField","entityType","entitySlug","split","fieldPath","name","t0","render","Field","type","admin","hidden","undefined","renderLexical","mounted","t1","t2","current","_jsx","adjustedServerFunctionContext","getFormState","getFormStateArgs","collectionSlug","globalSlug","children","fieldValue","disabled","formInitializing","formProcessing","formSubmitted","_temp","showError"],"sources":["../../../src/field/RenderLexical/index.tsx"],"sourcesContent":["'use client'\nimport type { RichTextField } from 'payload'\n\nimport {\n  FieldContext,\n  FieldPathContext,\n  type FieldType,\n  type RenderFieldServerFnArgs,\n  ServerFunctionsContext,\n  type ServerFunctionsContextType,\n  ShimmerEffect,\n  useServerFunctions,\n} from '@payloadcms/ui'\nimport React, { useCallback, useEffect, useRef } from 'react'\n\nimport type { DefaultTypedEditorState } from '../../nodeTypes.js'\nimport type { LexicalRichTextField } from '../../types.js'\n\n/**\n * Utility to render a lexical editor on the client.\n *\n * @experimental - may break in minor releases\n * @todo - replace this with a general utility that works for all fields. Maybe merge with packages/ui/src/forms/RenderFields/RenderField.tsx\n */\nexport const RenderLexical: React.FC<\n  /**\n   * If value or setValue, or both, is provided, this component will manage its own value.\n   * If neither is passed, it will rely on the parent form to manage the value.\n   */\n  {\n    /**\n     * Override the loading state while the field component is being fetched and rendered.\n     */\n    Loading?: React.ReactElement\n\n    setValue?: FieldType<DefaultTypedEditorState | undefined>['setValue']\n    value?: FieldType<DefaultTypedEditorState | undefined>['value']\n  } & RenderFieldServerFnArgs<LexicalRichTextField>\n> = (args) => {\n  const { field, initialValue, Loading, path, schemaPath, setValue, value } = args\n  const [Component, setComponent] = React.useState<null | React.ReactNode>(null)\n  const serverFunctionContext = useServerFunctions()\n  const { _internal_renderField } = serverFunctionContext\n\n  const [entityType, entitySlug] = schemaPath.split('.')\n\n  const fieldPath = path ?? (field && 'name' in field ? field?.name : '') ?? ''\n\n  const renderLexical = useCallback(() => {\n    async function render() {\n      const { Field } = await _internal_renderField({\n        field: {\n          ...((field as RichTextField) || {}),\n          type: 'richText',\n          admin: {\n            ...((field as RichTextField)?.admin || {}),\n            // When using \"fake\" anchor fields, hidden is often set to true. We need to override that here to ensure the field is rendered.\n            hidden: false,\n          },\n        },\n        initialValue: initialValue ?? undefined,\n        path,\n        schemaPath,\n      })\n\n      setComponent(Field)\n    }\n    void render()\n  }, [_internal_renderField, schemaPath, path, field, initialValue])\n\n  const mounted = useRef(false)\n\n  useEffect(() => {\n    if (mounted.current) {\n      return\n    }\n    mounted.current = true\n    void renderLexical()\n  }, [renderLexical])\n\n  if (!Component) {\n    return typeof Loading !== 'undefined' ? Loading : <ShimmerEffect />\n  }\n\n  /**\n   * By default, the lexical will make form state requests (e.g. to get drawer fields), passing in the arguments\n   * of the current field. However, we need to override those arguments to get it to make requests based on the\n   * *target* field. The server only knows the schema map of the target field.\n   */\n  const adjustedServerFunctionContext: ServerFunctionsContextType = {\n    ...serverFunctionContext,\n    getFormState: async (getFormStateArgs) => {\n      return serverFunctionContext.getFormState({\n        ...getFormStateArgs,\n        collectionSlug: entityType === 'collection' ? entitySlug : undefined,\n        globalSlug: entityType === 'global' ? entitySlug : undefined,\n      })\n    },\n  }\n\n  if (typeof value === 'undefined' && !setValue) {\n    return (\n      <ServerFunctionsContext value={{ ...adjustedServerFunctionContext }}>\n        <FieldPathContext key={fieldPath} value={fieldPath}>\n          {Component}\n        </FieldPathContext>\n      </ServerFunctionsContext>\n    )\n  }\n\n  const fieldValue: FieldType<DefaultTypedEditorState | undefined> = {\n    disabled: false,\n    formInitializing: false,\n    formProcessing: false,\n    formSubmitted: false,\n    initialValue: value,\n    path: fieldPath,\n    setValue: setValue ?? (() => undefined),\n    showError: false,\n    value,\n  }\n\n  return (\n    <ServerFunctionsContext value={{ ...adjustedServerFunctionContext }}>\n      <FieldPathContext key={fieldPath} value={fieldPath}>\n        <FieldContext value={fieldValue}>{Component}</FieldContext>\n      </FieldPathContext>\n    </ServerFunctionsContext>\n  )\n}\n"],"mappings":"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","ignoreList":[]}