{"version":3,"file":"loader.js","names":["createDependencyGraph","featureProviders","graph","fp","key","dependencies","dependenciesPriority","dependenciesSoft","featureProvider","topologicallySortFeatures","visited","stack","visit","reverse","currentPath","Error","includes","join","push","dep","pop","sortFeaturesForOptimalLoading","loadFeatures","config","isRoot","parentIsLocalized","unSanitizedEditorConfig","features","filter","f","i","arr","firstIndex","findIndex","f2","featureProviderMap","Map","map","resolvedFeatures","loaded","length","dependencyKey","found","find","priorityDependencyKey","get","existsInEditorConfig","feature","resolvedFeature","order","set"],"sources":["../../../../src/lexical/config/server/loader.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  FeatureProviderServer,\n  ResolvedServerFeature,\n  ResolvedServerFeatureMap,\n  ServerFeatureProviderMap,\n} from '../../../features/typesServer.js'\nimport type { ServerEditorConfig } from '../types.js'\n\ntype DependencyGraph = {\n  [key: string]: {\n    dependencies: string[]\n    dependenciesPriority: string[]\n    dependenciesSoft: string[]\n    featureProvider: FeatureProviderServer<unknown, unknown, unknown>\n  }\n}\n\nfunction createDependencyGraph(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): DependencyGraph {\n  const graph: DependencyGraph = {}\n  for (const fp of featureProviders) {\n    graph[fp.key] = {\n      dependencies: fp.dependencies || [],\n      dependenciesPriority: fp.dependenciesPriority || [],\n      dependenciesSoft: fp.dependenciesSoft || [],\n      featureProvider: fp,\n    }\n  }\n  return graph\n}\n\nfunction topologicallySortFeatures(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): FeatureProviderServer<unknown, unknown, unknown>[] {\n  const graph = createDependencyGraph(featureProviders)\n  const visited: { [key: string]: boolean } = {}\n  const stack: FeatureProviderServer<unknown, unknown, unknown>[] = []\n\n  for (const key in graph) {\n    if (!visited[key]) {\n      visit(graph, key, visited, stack)\n    }\n  }\n\n  return stack.reverse()\n}\n\nfunction visit(\n  graph: DependencyGraph,\n  key: string,\n  visited: { [key: string]: boolean },\n  stack: FeatureProviderServer<unknown, unknown, unknown>[],\n  currentPath: string[] = [],\n) {\n  if (!graph[key]) {\n    throw new Error(`Feature key ${key} is not present in the dependency graph.`)\n  }\n\n  if (currentPath.includes(key)) {\n    throw new Error(`Circular dependency detected: ${currentPath.join(' -> ')} -> ${key}`)\n  }\n\n  if (visited[key]) {\n    return\n  }\n\n  visited[key] = true\n  currentPath.push(key)\n\n  // First process the hard priority dependencies\n  for (const dep of graph[key].dependenciesPriority) {\n    if (!visited[dep]) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  // Then process the normal dependencies, but make sure to not violate hard dependencies\n  for (const dep of graph[key].dependencies) {\n    if (!visited[dep] && !graph[key].dependenciesPriority.includes(dep)) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  // Then process the soft dependencies. Make sure to not violate hard and normal dependencies.\n  for (const dep of graph[key].dependenciesSoft) {\n    if (\n      graph[dep] &&\n      !visited[dep] &&\n      !graph[key].dependenciesPriority.includes(dep) &&\n      !graph[key].dependencies.includes(dep)\n    ) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  stack.push(graph[key].featureProvider)\n  currentPath.pop()\n}\n\nexport function sortFeaturesForOptimalLoading(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): FeatureProviderServer<unknown, unknown, unknown>[] {\n  return topologicallySortFeatures(featureProviders)\n}\n\nexport async function loadFeatures({\n  config,\n  isRoot,\n  parentIsLocalized,\n  unSanitizedEditorConfig,\n}: {\n  config: SanitizedConfig\n  isRoot?: boolean\n  parentIsLocalized: boolean\n  unSanitizedEditorConfig: ServerEditorConfig\n}): Promise<ResolvedServerFeatureMap> {\n  // First remove all duplicate features. The LAST feature with a given key wins.\n  unSanitizedEditorConfig.features = unSanitizedEditorConfig.features\n    .reverse()\n    .filter((f, i, arr) => {\n      const firstIndex = arr.findIndex((f2) => f2.key === f.key)\n      return firstIndex === i\n    })\n    .reverse()\n\n  unSanitizedEditorConfig.features = sortFeaturesForOptimalLoading(unSanitizedEditorConfig.features)\n\n  const featureProviderMap: ServerFeatureProviderMap = new Map(\n    unSanitizedEditorConfig.features.map(\n      (f) => [f.key, f] as [string, FeatureProviderServer<unknown, unknown, unknown>],\n    ),\n  )\n\n  const resolvedFeatures: ResolvedServerFeatureMap = new Map()\n\n  // Make sure all dependencies declared in the respective features exist\n  let loaded = 0\n  for (const featureProvider of unSanitizedEditorConfig.features) {\n    if (!featureProvider.key) {\n      throw new Error(\n        `A Feature you've added does not have a key. Please add a key to the feature. This is used to uniquely identify the feature.`,\n      )\n    }\n    if (featureProvider.dependencies?.length) {\n      for (const dependencyKey of featureProvider.dependencies) {\n        const found = unSanitizedEditorConfig.features.find((f) => f.key === dependencyKey)\n        if (!found) {\n          throw new Error(\n            `Feature ${featureProvider.key} has a dependency ${dependencyKey} which does not exist.`,\n          )\n        }\n      }\n    }\n\n    if (featureProvider.dependenciesPriority?.length) {\n      for (const priorityDependencyKey of featureProvider.dependenciesPriority) {\n        // look in the resolved features instead of the editorConfig.features, as a dependency requires the feature to be loaded before it, contrary to a soft-dependency\n        const found = resolvedFeatures.get(priorityDependencyKey)\n        if (!found) {\n          const existsInEditorConfig = unSanitizedEditorConfig.features.find(\n            (f) => f.key === priorityDependencyKey,\n          )\n          if (!existsInEditorConfig) {\n            throw new Error(\n              `Feature ${featureProvider.key} has a priority dependency ${priorityDependencyKey} which does not exist.`,\n            )\n          } else {\n            throw new Error(\n              `Feature ${featureProvider.key} has a priority dependency ${priorityDependencyKey} which is not loaded before it.`,\n            )\n          }\n        }\n      }\n    }\n\n    const feature =\n      typeof featureProvider.feature === 'function'\n        ? await featureProvider.feature({\n            config,\n            featureProviderMap,\n            isRoot,\n            parentIsLocalized,\n            resolvedFeatures,\n            unSanitizedEditorConfig,\n          })\n        : featureProvider.feature\n\n    const resolvedFeature: ResolvedServerFeature<any, any> = feature as ResolvedServerFeature<\n      any,\n      any\n    >\n\n    // All these new properties would be added to the feature, as it's mutated. However, this does not cause any damage and allows\n    // us to prevent an unnecessary spread operation.\n    resolvedFeature.key = featureProvider.key\n    resolvedFeature.order = loaded\n    resolvedFeature.dependencies = featureProvider.dependencies!\n    resolvedFeature.dependenciesPriority = featureProvider.dependenciesPriority!\n    resolvedFeature.dependenciesSoft = featureProvider.dependenciesSoft!\n\n    resolvedFeatures.set(featureProvider.key, resolvedFeature)\n\n    loaded++\n  }\n\n  return resolvedFeatures\n}\n"],"mappings":"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","ignoreList":[]}