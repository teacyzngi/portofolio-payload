{"version":3,"file":"index.js","names":["useLexicalComposerContext","mergeRegister","$getSelection","$isRangeSelection","$isTextNode","COMMAND_PRIORITY_LOW","createCommand","getDOMSelection","useCallback","useEffect","useState","React","LexicalMenu","useMenuAnchorRef","PUNCTUATION","getTextUpToAnchor","selection","anchor","type","anchorNode","getNode","isSimpleText","anchorOffset","offset","getTextContent","slice","tryToPositionRange","leadOffset","range","editorWindow","domSelection","isCollapsed","startOffset","endOffset","setStart","setEnd","error","getQueryTextForSearch","editor","text","getEditorState","read","isSelectionOnEntityBoundary","prevSibling","getPreviousSibling","isTextEntity","startTransition","callback","useDynamicPositioning","ENABLE_SLASH_MENU_COMMAND","LexicalTypeaheadMenuPlugin","anchorClassName","anchorElem","groups","menuRenderFn","onClose","onOpen","onQueryChange","triggerFn","resolution","setResolution","anchorElementRef","closeTypeahead","openTypeahead","res","registerCommand","node","match","matchingString","replaceableString","_window","window","document","createRange","isRangePositioned","getRect","getBoundingClientRect","updateListener","undefined","query","removeUpdateListener","registerUpdateListener","current","_jsx","close","shouldSplitNodeWithQuery"],"sources":["../../../../../src/lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/index.tsx"],"sourcesContent":["'use client'\nimport type { LexicalCommand, LexicalEditor, ParagraphNode, RangeSelection } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $getSelection,\n  $isRangeSelection,\n  $isTextNode,\n  COMMAND_PRIORITY_LOW,\n  createCommand,\n  getDOMSelection,\n} from 'lexical'\nimport { type JSX, useCallback, useEffect, useState } from 'react'\nimport * as React from 'react'\n\nimport type { MenuTextMatch, TriggerFn } from '../useMenuTriggerMatch.js'\nimport type { MenuRenderFn, MenuResolution } from './LexicalMenu.js'\nimport type { SlashMenuGroupInternal } from './types.js'\n\nimport { LexicalMenu, useMenuAnchorRef } from './LexicalMenu.js'\n\nexport const PUNCTUATION = '\\\\.,\\\\+\\\\*\\\\?\\\\$\\\\@\\\\|#{}\\\\(\\\\)\\\\^\\\\-\\\\[\\\\]\\\\\\\\/!%\\'\"~=<>_:;'\n\nfunction getTextUpToAnchor(selection: RangeSelection): null | string {\n  const anchor = selection.anchor\n  if (anchor.type !== 'text') {\n    return null\n  }\n  const anchorNode = anchor.getNode()\n  if (!anchorNode.isSimpleText()) {\n    return null\n  }\n  const anchorOffset = anchor.offset\n  return anchorNode.getTextContent().slice(0, anchorOffset)\n}\n\nfunction tryToPositionRange(leadOffset: number, range: Range, editorWindow: Window): boolean {\n  const domSelection = getDOMSelection(editorWindow)\n  if (domSelection === null || !domSelection.isCollapsed) {\n    return false\n  }\n\n  const anchorNode = domSelection.anchorNode\n  const startOffset = leadOffset\n  const endOffset = domSelection.anchorOffset\n\n  if (anchorNode == null || endOffset == null) {\n    return false\n  }\n\n  try {\n    range.setStart(anchorNode, startOffset)\n    // if endOffset is 0, positioning the range for when you click the plus button to open the slash menu will fial\n    range.setEnd(anchorNode, endOffset > 1 ? endOffset : 1)\n  } catch (error) {\n    return false\n  }\n\n  return true\n}\n\nfunction getQueryTextForSearch(editor: LexicalEditor): string | undefined {\n  let text\n  editor.getEditorState().read(() => {\n    const selection = $getSelection()\n    if (!$isRangeSelection(selection)) {\n      return\n    }\n    text = getTextUpToAnchor(selection)\n  })\n  return text\n}\n\nfunction isSelectionOnEntityBoundary(editor: LexicalEditor, offset: number): boolean {\n  if (offset !== 0) {\n    return false\n  }\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection()\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor\n      const anchorNode = anchor.getNode()\n      const prevSibling = anchorNode.getPreviousSibling()\n      return $isTextNode(prevSibling) && prevSibling.isTextEntity()\n    }\n    return false\n  })\n}\n\nfunction startTransition(callback: () => void) {\n  if (React.startTransition) {\n    React.startTransition(callback)\n  } else {\n    callback()\n  }\n}\n\nexport { useDynamicPositioning } from './LexicalMenu.js'\n\nexport type TypeaheadMenuPluginProps = {\n  anchorClassName?: string\n  anchorElem: HTMLElement\n  groups: Array<SlashMenuGroupInternal>\n  menuRenderFn: MenuRenderFn\n  onClose?: () => void\n  onOpen?: (resolution: MenuResolution) => void\n  onQueryChange: (matchingString: null | string) => void\n  triggerFn: TriggerFn\n}\n\nexport const ENABLE_SLASH_MENU_COMMAND: LexicalCommand<{\n  node: ParagraphNode\n}> = createCommand('ENABLE_SLASH_MENU_COMMAND')\n\nexport function LexicalTypeaheadMenuPlugin({\n  anchorClassName,\n  anchorElem,\n  groups,\n  menuRenderFn,\n  onClose,\n  onOpen,\n  onQueryChange,\n  triggerFn,\n}: TypeaheadMenuPluginProps): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n  const [resolution, setResolution] = useState<MenuResolution | null>(null)\n  const anchorElementRef = useMenuAnchorRef(anchorElem, resolution, setResolution, anchorClassName)\n\n  const closeTypeahead = useCallback(() => {\n    setResolution(null)\n    if (onClose != null && resolution !== null) {\n      onClose()\n    }\n  }, [onClose, resolution])\n\n  const openTypeahead = useCallback(\n    (res: MenuResolution) => {\n      setResolution(res)\n      if (onOpen != null && resolution === null) {\n        onOpen(res)\n      }\n    },\n    [onOpen, resolution],\n  )\n\n  // This is mainly used for the AddBlockHandlePlugin, so that the slash menu can be opened from there\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        ENABLE_SLASH_MENU_COMMAND,\n        ({ node }) => {\n          editor.getEditorState().read(() => {\n            const match: MenuTextMatch = {\n              leadOffset: 0,\n              matchingString: '',\n              replaceableString: '',\n            }\n            if (!isSelectionOnEntityBoundary(editor, match.leadOffset)) {\n              if (node !== null) {\n                const editorWindow = editor._window ?? window\n                const range = editorWindow.document.createRange()\n\n                const isRangePositioned = tryToPositionRange(match.leadOffset, range, editorWindow)\n                if (isRangePositioned !== null) {\n                  startTransition(() =>\n                    openTypeahead({\n                      getRect: () => {\n                        return range.getBoundingClientRect()\n                      },\n                      match,\n                    }),\n                  )\n                }\n\n                return\n              }\n            }\n          })\n\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor, openTypeahead])\n\n  useEffect(() => {\n    const updateListener = () => {\n      editor.getEditorState().read(() => {\n        const editorWindow = editor._window ?? window\n        const range = editorWindow.document.createRange()\n        const selection = $getSelection()\n        const text = getQueryTextForSearch(editor)\n\n        if (\n          !$isRangeSelection(selection) ||\n          !selection.isCollapsed() ||\n          text === undefined ||\n          range === null\n        ) {\n          closeTypeahead()\n          return\n        }\n\n        const match = triggerFn({ editor, query: text })\n        onQueryChange(match ? match.matchingString : null)\n\n        if (match !== null && !isSelectionOnEntityBoundary(editor, match.leadOffset)) {\n          const isRangePositioned = tryToPositionRange(match.leadOffset, range, editorWindow)\n          if (isRangePositioned !== null) {\n            startTransition(() =>\n              openTypeahead({\n                getRect: () => {\n                  return range.getBoundingClientRect()\n                },\n                match,\n              }),\n            )\n            return\n          }\n        }\n        closeTypeahead()\n      })\n    }\n\n    const removeUpdateListener = editor.registerUpdateListener(updateListener)\n\n    return () => {\n      removeUpdateListener()\n    }\n  }, [editor, triggerFn, onQueryChange, resolution, closeTypeahead, openTypeahead])\n\n  return anchorElementRef.current === null || resolution === null || editor === null ? null : (\n    <LexicalMenu\n      anchorElementRef={anchorElementRef}\n      close={closeTypeahead}\n      editor={editor}\n      groups={groups}\n      menuRenderFn={menuRenderFn}\n      resolution={resolution}\n      shouldSplitNodeWithQuery\n    />\n  )\n}\n\nexport type { MenuRenderFn, MenuResolution, MenuTextMatch, TriggerFn }\n"],"mappings":"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","ignoreList":[]}