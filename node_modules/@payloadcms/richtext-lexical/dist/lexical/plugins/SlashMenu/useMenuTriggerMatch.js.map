{"version":3,"file":"useMenuTriggerMatch.js","names":["c","_c","useCallback","PUNCTUATION","useMenuTriggerMatch","trigger","t0","$","maxLength","t1","minLength","t2","undefined","t3","t4","query","validChars","TypeaheadTriggerRegex","RegExp","match","exec","maybeLeadingWhitespace","matchingString","length","leadOffset","index","replaceableString"],"sources":["../../../../src/lexical/plugins/SlashMenu/useMenuTriggerMatch.ts"],"sourcesContent":["'use client'\nimport type { LexicalEditor } from 'lexical'\n\nimport { useCallback } from 'react'\n\nimport { PUNCTUATION } from './LexicalTypeaheadMenuPlugin/index.js'\n\nexport type TriggerFn = ({\n  editor,\n  query,\n}: {\n  editor: LexicalEditor\n  /** The query string is the POTENTIAL trigger AND the text after the trigger text. */\n  query: string\n}) => MenuTextMatch | null\n\nexport type MenuTextMatch = {\n  leadOffset: number\n  matchingString: string\n  replaceableString: string\n}\n\n/**\n * Returns a function which checks if the trigger (e.g. '/') is present in the query and, if so, returns the matching string (text after the trigger)\n */\nexport function useMenuTriggerMatch(\n  /**\n   * Text which triggers the menu. Everything after this text will be used as the query.\n   */\n  trigger: string,\n  { maxLength = 75, minLength = 1 }: { maxLength?: number; minLength?: number },\n): TriggerFn {\n  return useCallback(\n    ({ query }) => {\n      const validChars = '[^' + trigger + PUNCTUATION + '\\\\s]'\n      const TypeaheadTriggerRegex = new RegExp(\n        '(^|\\\\s|\\\\()(' +\n          '[' +\n          trigger +\n          ']' +\n          '((?:' +\n          validChars +\n          '){0,' +\n          maxLength +\n          '})' +\n          ')$',\n      )\n      const match = TypeaheadTriggerRegex.exec(query)\n      if (match !== null) {\n        const maybeLeadingWhitespace = match[1]!\n\n        /**\n         * matchingString is only the text AFTER the trigger text. (So everything after the /)\n         */\n        const matchingString = match[3]!\n\n        if (matchingString.length >= minLength) {\n          return {\n            leadOffset: match.index + maybeLeadingWhitespace.length,\n            matchingString,\n            replaceableString: match[2]!, // replaceableString is the trigger text + the matching string\n          }\n        }\n      }\n      return null\n    },\n    [maxLength, minLength, trigger],\n  )\n}\n"],"mappings":"AAAA;;AAAA,SAAAA,CAAA,IAAAC,EAAA;AAGA,SAASC,WAAW,QAAQ;AAE5B,SAASC,WAAW,QAAQ;AAiB5B;;;AAGA,OAAO,SAAAC,oBAAAC,OAAA,EAAAC,EAAA;EAAA,MAAAC,CAAA,GAAAN,EAAA;EAKL;IAAAO,SAAA,EAAAC,EAAA;IAAAC,SAAA,EAAAC;EAAA,IAAAL,EAA6E;EAA3E,MAAAE,SAAA,GAAAC,EAAc,KAAAG,SAAA,QAAdH,EAAc;EAAE,MAAAC,SAAA,GAAAC,EAAa,KAAAC,SAAA,OAAbD,EAAa;EAAA,IAAAE,EAAA;EAAA,IAAAN,CAAA,QAAAC,SAAA,IAAAD,CAAA,QAAAG,SAAA,IAAAH,CAAA,QAAAF,OAAA;IAG7BQ,EAAA,GAAAC,EAAA;MAAC;QAAAC;MAAA,IAAAD,EAAS;MACR,MAAAE,UAAA,GAAmB,OAAOX,OAAA,GAAAF,WAAU,GAAc;MAClD,MAAAc,qBAAA,OAAAC,MAAA,CACE,eACE,GACAb,OAAA,GACA,MACA,SACAW,UAAA,GACA,SACAR,SAAA,GACA,OACA;MAEJ,MAAAW,KAAA,GAAcF,qBAAA,CAAAG,IAAA,CAA2BL,KAAA;MAAA,IACrCI,KAAA,SAAU;QACZ,MAAAE,sBAAA,GAA+BF,KAAK;QAKpC,MAAAG,cAAA,GAAuBH,KAAK;QAAG,IAE3BG,cAAA,CAAAC,MAAA,IAAyBb,SAAA;UAAA;YAAAc,UAAA,EAEbL,KAAA,CAAAM,KAAA,GAAcJ,sBAAA,CAAAE,MAA6B;YAAAD,cAAA;YAAAI,iBAAA,EAEpCP,KAAK;UAAA;QAAA;MAAA;MAAA;IAAA;IAKhCZ,CAAA,MAAAC,SAAA;IAAAD,CAAA,MAAAG,SAAA;IAAAH,CAAA,MAAAF,OAAA;IAAAE,CAAA,MAAAM,EAAA;EAAA;IAAAA,EAAA,GAAAN,CAAA;EAAA;EAAA,OAjCKM,EAkC0B;AAAA","ignoreList":[]}