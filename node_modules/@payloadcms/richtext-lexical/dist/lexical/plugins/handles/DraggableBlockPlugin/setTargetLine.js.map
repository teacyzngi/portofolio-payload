{"version":3,"file":"setTargetLine.js","names":["getCollapsedMargins","TARGET_LINE_HALF_HEIGHT","TEXT_BOX_HORIZONTAL_PADDING","DEBUG","animationTimer","setTargetLine","offsetWidth","offsetLeft","targetLineElem","targetBlockElem","lastTargetBlock","mouseY","anchorElem","event","debugHighlightRef","isFoundNodeEmptyParagraph","height","targetBlockElemHeight","top","targetBlockElemTop","getBoundingClientRect","anchorTop","width","anchorWidth","marginBottom","marginTop","lineTop","isBelow","window","scrollY","willStayInSamePosition","elem","nextElementSibling","previousElementSibling","lastBoundingBoxPosition","boundingBox","y","currentBoundingBoxPosition","targetElemTranslate2","left","style","opacity","transform"],"sources":["../../../../../src/lexical/plugins/handles/DraggableBlockPlugin/setTargetLine.ts"],"sourcesContent":["'use client'\nimport { getCollapsedMargins } from '../utils/getCollapsedMargins.js'\nconst TARGET_LINE_HALF_HEIGHT = 0\nconst TEXT_BOX_HORIZONTAL_PADDING = -24\nconst DEBUG = false\n\nlet animationTimer = 0\n\nexport function setTargetLine(\n  offsetWidth: string,\n  offsetLeft: number,\n  targetLineElem: HTMLElement,\n  targetBlockElem: HTMLElement,\n  lastTargetBlock: {\n    boundingBox?: DOMRect\n    elem: HTMLElement | null\n    isBelow: boolean\n  },\n  mouseY: number,\n  anchorElem: HTMLElement,\n  event: DragEvent,\n  debugHighlightRef: React.RefObject<HTMLDivElement | null>,\n  isFoundNodeEmptyParagraph: boolean = false,\n) {\n  const { height: targetBlockElemHeight, top: targetBlockElemTop } =\n    targetBlockElem.getBoundingClientRect() // used to be getBoundingClientRectWithoutTransform. Not sure what's better, but the normal getBoundingClientRect seems to work fine\n  const { top: anchorTop, width: anchorWidth } = anchorElem.getBoundingClientRect()\n\n  const { marginBottom, marginTop } = getCollapsedMargins(targetBlockElem)\n  let lineTop = targetBlockElemTop\n\n  const isBelow = mouseY >= targetBlockElemTop + targetBlockElemHeight / 2 + window.scrollY\n\n  let willStayInSamePosition = false\n\n  /**\n   * Do not run any transform or changes if the actual new line position would be the same (even if it's now inserted BEFORE rather than AFTER - position would still be the same)\n   * This prevents unnecessary flickering.\n   *\n   * We still need to let it run even if the position (IGNORING the transform) would not change, as the transform animation is not finished yet. This is what animationTimer does. Otherwise, the positioning will be inaccurate\n   */\n  if (lastTargetBlock?.elem) {\n    if (targetBlockElem !== lastTargetBlock?.elem) {\n      if (\n        isBelow &&\n        lastTargetBlock?.elem &&\n        lastTargetBlock?.elem === targetBlockElem.nextElementSibling\n      ) {\n        animationTimer++\n\n        if (animationTimer < 200) {\n          willStayInSamePosition = true\n        }\n      } else if (\n        !isBelow &&\n        lastTargetBlock?.elem &&\n        lastTargetBlock?.elem === targetBlockElem.previousElementSibling\n      ) {\n        animationTimer++\n        if (animationTimer < 200) {\n          willStayInSamePosition = true\n        }\n      }\n    } else {\n      animationTimer++\n\n      const lastBoundingBoxPosition = lastTargetBlock?.boundingBox?.y\n      const currentBoundingBoxPosition = targetBlockElem.getBoundingClientRect().y\n\n      if (\n        (isBelow === lastTargetBlock?.isBelow &&\n          lastBoundingBoxPosition === currentBoundingBoxPosition) ||\n        animationTimer < 200\n      ) {\n        willStayInSamePosition = false\n      }\n    }\n  }\n  if (willStayInSamePosition) {\n    return {\n      isBelow,\n      willStayInSamePosition,\n    }\n  }\n\n  /**\n   * Paragraphs need no isBelow/above handling,\n   */\n  if (!isFoundNodeEmptyParagraph) {\n    //if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      // below targetBlockElem\n      lineTop += targetBlockElemHeight + marginBottom / 2\n    } else {\n      // above targetBlockElem\n      lineTop -= marginTop / 2\n    }\n  } else {\n    lineTop += targetBlockElemHeight / 2\n  }\n\n  let targetElemTranslate2 = 0\n\n  if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      targetElemTranslate2 = -TARGET_LINE_HALF_HEIGHT\n    } else {\n      targetElemTranslate2 = TARGET_LINE_HALF_HEIGHT\n    }\n  }\n\n  const top = lineTop - anchorTop + targetElemTranslate2\n\n  const left = TEXT_BOX_HORIZONTAL_PADDING - offsetLeft\n\n  targetLineElem.style.width = `calc(${anchorWidth}px - ${offsetWidth})`\n  targetLineElem.style.opacity = '.8'\n\n  // if (DEBUG) {\n  //   //targetBlockElem.style.border = '3px solid red'\n  //   highlightElemOriginalPosition(debugHighlightRef, targetBlockElem, anchorElem)\n  // }\n\n  targetLineElem.style.transform = `translate(${left}px, calc(${top}px - ${'2px'}))`\n\n  /**\n   * Properly reset previous targetBlockElem styles\n   */\n  if (lastTargetBlock?.elem) {\n    lastTargetBlock.elem.style.opacity = ''\n\n    if (lastTargetBlock?.elem === targetBlockElem) {\n      if (isBelow) {\n        lastTargetBlock.elem.style.marginTop = ''\n      } else {\n        lastTargetBlock.elem.style.marginBottom = ''\n      }\n    } else {\n      lastTargetBlock.elem.style.marginBottom = ''\n      lastTargetBlock.elem.style.marginTop = ''\n    }\n  }\n\n  animationTimer = 0\n  return {\n    isBelow,\n    willStayInSamePosition,\n  }\n}\n"],"mappings":"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","ignoreList":[]}