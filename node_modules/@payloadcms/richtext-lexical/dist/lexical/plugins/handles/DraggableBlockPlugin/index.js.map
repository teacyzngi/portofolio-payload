{"version":3,"file":"index.js","names":["useLexicalComposerContext","eventFiles","$getNearestNodeFromDOMNode","$getNodeByKey","isHTMLElement","React","useEffect","useRef","useState","createPortal","useEditorConfigContext","Point","calculateDistanceFromScrollerElem","getNodeCloseToPoint","getTopLevelNodeKeys","isOnHandleElement","setHandlePosition","getBoundingClientRectWithoutTransform","setTargetLine","DRAGGABLE_BLOCK_MENU_CLASSNAME","DRAG_DATA_FORMAT","prevIndex","Infinity","getCurrentIndex","keysLength","Math","floor","setDragImage","dataTransfer","draggableBlockElem","transform","style","setTimeout","hideTargetLine","targetLineElem","lastTargetBlockElem","opacity","marginBottom","marginTop","useDraggableBlockMenu","editor","anchorElem","isEditable","scrollerElem","parentElement","menuRef","targetLineRef","debugHighlightRef","isDraggingBlockRef","setDraggableBlockElem","lastTargetBlock","setLastTargetBlock","editorConfig","blockHandleHorizontalOffset","admin","hideGutter","onDocumentMouseMove","event","target","distanceFromScrollerElem","pageX","pageY","topLevelNodeKeys","blockElem","_draggableBlockElem","foundAtIndex","isFoundNodeEmptyParagraph","cache_threshold","horizontalOffset","point","x","y","startIndex","length","useEdgeAsDefault","verbose","document","addEventListener","removeEventListener","current","onDragover","isFileTransfer","targetBlockElem","fuzzy","isBelow","willStayInSamePosition","getBoundingClientRect","width","preventDefault","boundingBox","elem","onDrop","dragData","getData","update","draggedNode","targetNode","height","targetBlockElemHeight","top","targetBlockElemTop","mouseY","window","scrollY","insertAfter","insertBefore","remove","allPrevHighlighters","querySelectorAll","forEach","highlighter","newInsertedElem","getElementByKey","getKey","newInsertedElemRect","highlightElem","createElement","className","backgroundColor","transition","zIndex","pointerEvents","boxSizing","borderRadius","position","body","appendChild","left","onDragStart","nodeKey","node","setData","onDragEnd","_jsxs","Fragment","_jsx","draggable","ref","type","DraggableBlockPlugin","t0","t1","undefined","_editable"],"sources":["../../../../../src/lexical/plugins/handles/DraggableBlockPlugin/index.tsx"],"sourcesContent":["'use client'\nimport type { LexicalEditor } from 'lexical'\nimport type { DragEvent as ReactDragEvent } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { eventFiles } from '@lexical/rich-text'\nimport { $getNearestNodeFromDOMNode, $getNodeByKey, isHTMLElement } from 'lexical'\nimport * as React from 'react'\nimport { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useEditorConfigContext } from '../../../config/client/EditorConfigProvider.js'\nimport { Point } from '../../../utils/point.js'\nimport { calculateDistanceFromScrollerElem } from '../utils/calculateDistanceFromScrollerElem.js'\nimport { getNodeCloseToPoint } from '../utils/getNodeCloseToPoint.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\nimport { isOnHandleElement } from '../utils/isOnHandleElement.js'\nimport { setHandlePosition } from '../utils/setHandlePosition.js'\nimport { getBoundingClientRectWithoutTransform } from './getBoundingRectWithoutTransform.js'\nimport './index.scss'\nimport { setTargetLine } from './setTargetLine.js'\n\nconst DRAGGABLE_BLOCK_MENU_CLASSNAME = 'draggable-block-menu'\nconst DRAG_DATA_FORMAT = 'application/x-lexical-drag-block'\n\nlet prevIndex = Infinity\n\nfunction getCurrentIndex(keysLength: number): number {\n  if (keysLength === 0) {\n    return Infinity\n  }\n  if (prevIndex >= 0 && prevIndex < keysLength) {\n    return prevIndex\n  }\n\n  return Math.floor(keysLength / 2)\n}\n\nfunction setDragImage(dataTransfer: DataTransfer, draggableBlockElem: HTMLElement) {\n  const { transform } = draggableBlockElem.style\n\n  // Remove dragImage borders\n  dataTransfer.setDragImage(draggableBlockElem, 0, 0)\n\n  setTimeout(() => {\n    draggableBlockElem.style.transform = transform\n  })\n}\n\nfunction hideTargetLine(\n  targetLineElem: HTMLElement | null,\n  lastTargetBlockElem: HTMLElement | null,\n) {\n  if (targetLineElem) {\n    targetLineElem.style.opacity = '0'\n  }\n  if (lastTargetBlockElem) {\n    lastTargetBlockElem.style.opacity = ''\n    // Delete marginBottom and marginTop values we set\n    lastTargetBlockElem.style.marginBottom = ''\n    lastTargetBlockElem.style.marginTop = ''\n    //lastTargetBlock.style.border = 'none'\n  }\n}\n\nfunction useDraggableBlockMenu(\n  editor: LexicalEditor,\n  anchorElem: HTMLElement,\n  isEditable: boolean,\n): React.ReactElement {\n  const scrollerElem = anchorElem.parentElement\n\n  const menuRef = useRef<HTMLButtonElement>(null)\n  const targetLineRef = useRef<HTMLDivElement>(null)\n  const debugHighlightRef = useRef<HTMLDivElement>(null)\n  const isDraggingBlockRef = useRef<boolean>(false)\n  const [draggableBlockElem, setDraggableBlockElem] = useState<HTMLElement | null>(null)\n  const [lastTargetBlock, setLastTargetBlock] = useState<{\n    boundingBox?: DOMRect\n    elem: HTMLElement | null\n    isBelow: boolean\n  } | null>(null)\n\n  const { editorConfig } = useEditorConfigContext()\n\n  const blockHandleHorizontalOffset = editorConfig?.admin?.hideGutter ? -44 : -8\n\n  useEffect(() => {\n    /**\n     * Handles positioning of the drag handle\n     */\n    function onDocumentMouseMove(event: MouseEvent) {\n      const target = event.target\n      if (!isHTMLElement(target)) {\n        return\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n      )\n      if (distanceFromScrollerElem === -1) {\n        setDraggableBlockElem(null)\n        return\n      }\n\n      if (isOnHandleElement(target, DRAGGABLE_BLOCK_MENU_CLASSNAME)) {\n        return\n      }\n\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: _draggableBlockElem,\n        foundAtIndex,\n        isFoundNodeEmptyParagraph,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        cache_threshold: 0,\n        editor,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: false,\n        verbose: false,\n      })\n\n      prevIndex = foundAtIndex\n\n      //if (DEBUG && _draggableBlockElem) {\n      //targetBlockElem.style.border = '3px solid red'\n      // highlightElemOriginalPosition(debugHighlightRef, _draggableBlockElem, anchorElem)\n      //}\n\n      if (!_draggableBlockElem && !isFoundNodeEmptyParagraph) {\n        return\n      }\n\n      if (draggableBlockElem !== _draggableBlockElem) {\n        setDraggableBlockElem(_draggableBlockElem)\n      }\n    }\n\n    // Since the draggableBlockElem is outside the actual editor, we need to listen to the document\n    // to be able to detect when the mouse is outside the editor and respect a buffer around\n    // the scrollerElem to avoid the draggableBlockElem disappearing too early.\n    document?.addEventListener('mousemove', onDocumentMouseMove)\n\n    return () => {\n      document?.removeEventListener('mousemove', onDocumentMouseMove)\n    }\n  }, [scrollerElem, anchorElem, editor, draggableBlockElem])\n\n  useEffect(() => {\n    if (menuRef.current) {\n      setHandlePosition(\n        draggableBlockElem,\n        menuRef.current,\n        anchorElem,\n        blockHandleHorizontalOffset,\n      )\n    }\n  }, [anchorElem, draggableBlockElem, blockHandleHorizontalOffset])\n\n  useEffect(() => {\n    function onDragover(event: DragEvent): boolean {\n      if (!isDraggingBlockRef.current) {\n        return false\n      }\n      const [isFileTransfer] = eventFiles(event)\n      if (isFileTransfer) {\n        return false\n      }\n\n      const { pageY, target } = event\n      if (!isHTMLElement(target)) {\n        return false\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n        100,\n        50,\n      )\n\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: targetBlockElem,\n        foundAtIndex,\n        isFoundNodeEmptyParagraph,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        editor,\n        fuzzy: true,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: true,\n        verbose: true,\n      })\n\n      prevIndex = foundAtIndex\n\n      const targetLineElem = targetLineRef.current\n      // targetBlockElem === null shouldn't happen\n      if (targetBlockElem === null || targetLineElem === null) {\n        return false\n      }\n\n      if (draggableBlockElem !== targetBlockElem) {\n        const { isBelow, willStayInSamePosition } = setTargetLine(\n          editorConfig?.admin?.hideGutter ? '0px' : '3rem',\n          blockHandleHorizontalOffset +\n            (editorConfig?.admin?.hideGutter\n              ? (menuRef?.current?.getBoundingClientRect()?.width ?? 0)\n              : -(menuRef?.current?.getBoundingClientRect()?.width ?? 0)),\n          targetLineElem,\n          targetBlockElem,\n          lastTargetBlock!,\n          pageY,\n          anchorElem,\n          event,\n          debugHighlightRef,\n          isFoundNodeEmptyParagraph,\n        )\n\n        // Prevent default event to be able to trigger onDrop events\n        // Calling preventDefault() adds the green plus icon to the cursor,\n        // indicating that the drop is allowed.\n        event.preventDefault()\n\n        if (!willStayInSamePosition) {\n          setLastTargetBlock({\n            boundingBox: targetBlockElem.getBoundingClientRect(),\n            elem: targetBlockElem,\n            isBelow,\n          })\n        }\n      } else if (lastTargetBlock?.elem) {\n        hideTargetLine(targetLineElem, lastTargetBlock.elem)\n        setLastTargetBlock({\n          boundingBox: targetBlockElem.getBoundingClientRect(),\n          elem: targetBlockElem,\n          isBelow: false,\n        })\n      }\n\n      return true\n    }\n\n    function onDrop(event: DragEvent): boolean {\n      if (!isDraggingBlockRef.current) {\n        return false\n      }\n      const [isFileTransfer] = eventFiles(event)\n      if (isFileTransfer) {\n        return false\n      }\n      const { dataTransfer, pageY, target } = event\n      const dragData = dataTransfer?.getData(DRAG_DATA_FORMAT) || ''\n\n      editor.update(() => {\n        const draggedNode = $getNodeByKey(dragData)\n        if (!draggedNode) {\n          return false\n        }\n        if (!isHTMLElement(target)) {\n          return false\n        }\n        const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n          scrollerElem,\n          event.pageX,\n          event.pageY,\n          target,\n          100,\n          50,\n        )\n\n        const { blockElem: targetBlockElem, isFoundNodeEmptyParagraph } = getNodeCloseToPoint({\n          anchorElem,\n          editor,\n          fuzzy: true,\n          horizontalOffset: -distanceFromScrollerElem,\n          point: new Point(event.x, event.y),\n          useEdgeAsDefault: true,\n        })\n\n        if (!targetBlockElem) {\n          return false\n        }\n        const targetNode = $getNearestNodeFromDOMNode(targetBlockElem)\n        if (!targetNode) {\n          return false\n        }\n        if (targetNode === draggedNode) {\n          return true\n        }\n\n        const { height: targetBlockElemHeight, top: targetBlockElemTop } =\n          getBoundingClientRectWithoutTransform(targetBlockElem)\n\n        const mouseY = pageY\n        const isBelow = mouseY >= targetBlockElemTop + targetBlockElemHeight / 2 + window.scrollY\n\n        if (!isFoundNodeEmptyParagraph) {\n          if (isBelow) {\n            // below targetBlockElem\n            targetNode.insertAfter(draggedNode)\n          } else {\n            // above targetBlockElem\n            targetNode.insertBefore(draggedNode)\n          }\n        } else {\n          //\n          targetNode.insertBefore(draggedNode)\n          targetNode.remove()\n        }\n\n        /*\n        if (pageY >= targetBlockElemTop + targetBlockElemHeight / 2) {\n          targetNode.insertAfter(draggedNode)\n        } else {\n          targetNode.insertBefore(draggedNode)\n        }*/\n        if (draggableBlockElem !== null) {\n          setDraggableBlockElem(null)\n        }\n\n        // find all previous elements with lexical-block-highlighter class and remove them\n        const allPrevHighlighters = document.querySelectorAll('.lexical-block-highlighter')\n        allPrevHighlighters.forEach((highlighter) => {\n          highlighter.remove()\n        })\n\n        const newInsertedElem = editor.getElementByKey(draggedNode.getKey())\n        setTimeout(() => {\n          // add new temp html element to newInsertedElem with the same height and width and the class block-selected\n          // to highlight the new inserted element\n          const newInsertedElemRect = newInsertedElem?.getBoundingClientRect()\n          if (!newInsertedElemRect) {\n            return\n          }\n          const highlightElem = document.createElement('div')\n          highlightElem.className = 'lexical-block-highlighter'\n\n          highlightElem.style.backgroundColor = 'var(--theme-elevation-1000'\n          highlightElem.style.transition = 'opacity 0.5s ease-in-out'\n          highlightElem.style.zIndex = '1'\n          highlightElem.style.pointerEvents = 'none'\n          highlightElem.style.boxSizing = 'border-box'\n          highlightElem.style.borderRadius = '4px'\n          highlightElem.style.position = 'absolute'\n          document.body.appendChild(highlightElem)\n\n          highlightElem.style.opacity = '0.1'\n\n          highlightElem.style.height = `${newInsertedElemRect.height + 8}px`\n          highlightElem.style.width = `${newInsertedElemRect.width + 8}px`\n          highlightElem.style.top = `${newInsertedElemRect.top + window.scrollY - 4}px`\n          highlightElem.style.left = `${newInsertedElemRect.left - 4}px`\n\n          setTimeout(() => {\n            highlightElem.style.opacity = '0'\n            setTimeout(() => {\n              highlightElem.remove()\n            }, 500)\n          }, 1000)\n        }, 120)\n      })\n\n      return true\n    }\n\n    // register onDragover event listeners:\n    document.addEventListener('dragover', onDragover)\n    // register onDrop event listeners:\n    document.addEventListener('drop', onDrop)\n\n    return () => {\n      document.removeEventListener('dragover', onDragover)\n      document.removeEventListener('drop', onDrop)\n    }\n  }, [\n    scrollerElem,\n    blockHandleHorizontalOffset,\n    anchorElem,\n    editor,\n    lastTargetBlock,\n    draggableBlockElem,\n    editorConfig?.admin?.hideGutter,\n  ])\n\n  function onDragStart(event: ReactDragEvent<HTMLButtonElement>): void {\n    const dataTransfer = event.dataTransfer\n    if (!dataTransfer || !draggableBlockElem) {\n      return\n    }\n    setDragImage(dataTransfer, draggableBlockElem)\n    let nodeKey = ''\n    editor.update(() => {\n      const node = $getNearestNodeFromDOMNode(draggableBlockElem)\n      if (node) {\n        nodeKey = node.getKey()\n      }\n    })\n    isDraggingBlockRef.current = true\n    dataTransfer.setData(DRAG_DATA_FORMAT, nodeKey)\n  }\n\n  function onDragEnd(): void {\n    isDraggingBlockRef.current = false\n    if (lastTargetBlock?.elem) {\n      hideTargetLine(targetLineRef.current, lastTargetBlock?.elem)\n    }\n  }\n\n  return createPortal(\n    <React.Fragment>\n      <button\n        aria-label=\"Drag to move\"\n        className=\"icon draggable-block-menu\"\n        draggable\n        onDragEnd={onDragEnd}\n        onDragStart={onDragStart}\n        ref={menuRef}\n        type=\"button\"\n      >\n        <div className={isEditable ? 'icon' : ''} />\n      </button>\n      <div className=\"draggable-block-target-line\" ref={targetLineRef} />\n      <div className=\"debug-highlight\" ref={debugHighlightRef} />\n    </React.Fragment>,\n    anchorElem,\n  )\n}\n\nexport function DraggableBlockPlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  return useDraggableBlockMenu(editor, anchorElem, editor._editable)\n}\n"],"mappings":"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","ignoreList":[]}