{"version":3,"file":"getNodeCloseToPoint.js","names":["$getNodeByKey","Point","Rect","getBoundingClientRectWithoutTransform","getCollapsedMargins","getTopLevelNodeKeys","Downward","Upward","Indeterminate","cache","props","result","isPointClose","previous","current","threshold","dx","x","dy","y","getNodeCloseToPoint","anchorElem","cache_threshold","editor","fuzzy","horizontalOffset","point","startIndex","useEdgeAsDefault","anchorElementRect","getBoundingClientRect","topLevelNodeKeys","closestBlockElem","blockElem","blockNode","distance","Infinity","foundAtIndex","isFoundNodeEmptyParagraph","getEditorState","read","firstNode","getElementByKey","lastNode","length","firstNodeRect","lastNodeRect","top","bottom","index","direction","key","elem","domRect","fromDOMRect","marginBottom","marginTop","rect","generateNewRect","left","right","isOnBottomSide","isOnTopSide","distanceFromPoint","getType","getTextContent","returnEmptyParagraphs"],"sources":["../../../../../src/lexical/plugins/handles/utils/getNodeCloseToPoint.ts"],"sourcesContent":["'use client'\nimport type { LexicalEditor, LexicalNode } from 'lexical'\n\nimport { $getNodeByKey } from 'lexical'\n\nimport { Point } from '../../../utils/point.js'\nimport { Rect } from '../../../utils/rect.js'\nimport { getBoundingClientRectWithoutTransform } from '../DraggableBlockPlugin/getBoundingRectWithoutTransform.js'\nimport { getCollapsedMargins } from '../utils/getCollapsedMargins.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\n\n// Directions\nconst Downward = 1\nconst Upward = -1\nconst Indeterminate = 0\n\ntype Props = {\n  anchorElem: HTMLElement\n  cache_threshold?: number\n  editor: LexicalEditor\n  /** fuzzy makes the search not exact. If no exact match found, find the closes node instead of returning null */\n  fuzzy?: boolean\n  horizontalOffset?: number\n  point: Point\n  /**\n   * By default, empty paragraphs are not returned. Set this to true to return empty paragraphs. @default false\n   */\n  returnEmptyParagraphs?: boolean\n  /**\n   * The index to start searching from. It can be a considerable performance optimization to start searching from the index of the\n   * previously found node, as the node is likely to be close to the next node.\n   */\n  startIndex?: number\n  useEdgeAsDefault?: boolean\n  verbose?: boolean\n}\n\ntype Output = {\n  blockElem: HTMLElement | null\n  blockNode: LexicalNode | null\n  foundAtIndex: number\n  isFoundNodeEmptyParagraph: boolean\n}\n\nconst cache = {\n  props: null as null | Props,\n  result: null as null | Output,\n}\n\nfunction isPointClose(previous: Point, current: Point, threshold: number = 20): boolean {\n  const dx = previous.x - current.x\n  const dy = previous.y - current.y\n  return dx * dx + dy * dy <= threshold * threshold\n}\n\nexport function getNodeCloseToPoint(props: Props): Output {\n  const {\n    anchorElem,\n    cache_threshold = 20,\n    editor,\n    fuzzy = false,\n    horizontalOffset = 0,\n    point: { x, y },\n    startIndex = 0,\n    useEdgeAsDefault = false,\n  } = props\n\n  // Use cache\n  if (\n    cache_threshold > 0 &&\n    cache.props &&\n    cache.result &&\n    cache.props.fuzzy === props.fuzzy &&\n    cache.props.horizontalOffset === props.horizontalOffset &&\n    cache.props.useEdgeAsDefault === props.useEdgeAsDefault &&\n    isPointClose(cache.props.point, props.point, cache_threshold)\n  ) {\n    return cache.result\n  }\n\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n  const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n  const closestBlockElem: {\n    blockElem: HTMLElement | null\n    blockNode: LexicalNode | null\n    distance: number\n    foundAtIndex: number\n    isFoundNodeEmptyParagraph: boolean\n  } = {\n    blockElem: null,\n    blockNode: null,\n    distance: Infinity,\n    foundAtIndex: -1,\n    isFoundNodeEmptyParagraph: false,\n  }\n\n  // Return null if matching block element is the first or last node\n  editor.getEditorState().read(() => {\n    if (useEdgeAsDefault) {\n      const firstNode = editor.getElementByKey(topLevelNodeKeys[0]!)\n      const lastNode = editor.getElementByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1]!)\n\n      if (firstNode && lastNode) {\n        const [firstNodeRect, lastNodeRect] = [\n          getBoundingClientRectWithoutTransform(firstNode),\n          getBoundingClientRectWithoutTransform(lastNode),\n        ]\n\n        if (y < firstNodeRect.top) {\n          closestBlockElem.blockElem = firstNode\n          closestBlockElem.distance = firstNodeRect.top - y\n          closestBlockElem.blockNode = $getNodeByKey(topLevelNodeKeys[0]!)\n          closestBlockElem.foundAtIndex = 0\n        } else if (y > lastNodeRect.bottom) {\n          closestBlockElem.distance = y - lastNodeRect.bottom\n          closestBlockElem.blockNode = $getNodeByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1]!)\n          closestBlockElem.blockElem = lastNode\n          closestBlockElem.foundAtIndex = topLevelNodeKeys.length - 1\n        }\n\n        if (closestBlockElem?.blockElem) {\n          return {\n            blockElem: null,\n            isFoundNodeEmptyParagraph: false,\n          } as Output\n        }\n      }\n    }\n\n    // Find matching block element\n    let index = startIndex\n    let direction = Indeterminate\n\n    while (index >= 0 && index < topLevelNodeKeys.length) {\n      const key = topLevelNodeKeys[index]!\n      const elem = editor.getElementByKey(key)\n      if (elem === null) {\n        break\n      }\n      const point = new Point(x + horizontalOffset, y)\n      //const domRect = Rect.fromDOM(elem)\n      // Do not consider transform of blocks when calculating distance\n      const domRect = Rect.fromDOMRect(getBoundingClientRectWithoutTransform(elem))\n\n      const { marginBottom, marginTop } = getCollapsedMargins(elem)\n\n      const rect = domRect.generateNewRect({\n        bottom: domRect.bottom + marginBottom,\n        left: anchorElementRect.left,\n        right: anchorElementRect.right,\n        top: domRect.top - marginTop,\n      })\n\n      const { distance, isOnBottomSide, isOnTopSide } = rect.distanceFromPoint(point)\n\n      if (distance === 0) {\n        closestBlockElem.blockElem = elem\n        closestBlockElem.blockNode = $getNodeByKey(key)\n        closestBlockElem.foundAtIndex = index\n        closestBlockElem.distance = distance\n\n        // Check if blockNode is an empty text node\n        if (\n          closestBlockElem.blockNode &&\n          closestBlockElem.blockNode.getType() === 'paragraph' &&\n          closestBlockElem.blockNode.getTextContent() === ''\n        ) {\n          if (!fuzzy && !props.returnEmptyParagraphs) {\n            closestBlockElem.blockElem = null\n            closestBlockElem.blockNode = null\n          }\n\n          closestBlockElem.isFoundNodeEmptyParagraph = true\n        }\n        break\n      } else if (fuzzy) {\n        if (distance < closestBlockElem.distance) {\n          closestBlockElem.blockElem = elem\n          closestBlockElem.blockNode = $getNodeByKey(key)\n          closestBlockElem.distance = distance\n          closestBlockElem.foundAtIndex = index\n        }\n      }\n\n      if (direction === Indeterminate) {\n        if (isOnTopSide) {\n          direction = Upward\n        } else if (isOnBottomSide) {\n          direction = Downward\n        } else {\n          // stop search block element\n          direction = Infinity\n        }\n      }\n\n      index += direction\n    }\n  })\n\n  // Store in cache before returning\n  cache.props = props\n  cache.result = {\n    blockElem: closestBlockElem.blockElem,\n    blockNode: closestBlockElem.blockNode,\n    foundAtIndex: closestBlockElem.foundAtIndex,\n    isFoundNodeEmptyParagraph: closestBlockElem.isFoundNodeEmptyParagraph,\n  }\n\n  return {\n    blockElem: closestBlockElem.blockElem,\n    blockNode: closestBlockElem.blockNode,\n    foundAtIndex: closestBlockElem.foundAtIndex,\n    isFoundNodeEmptyParagraph: closestBlockElem.isFoundNodeEmptyParagraph,\n  }\n}\n"],"mappings":"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","ignoreList":[]}