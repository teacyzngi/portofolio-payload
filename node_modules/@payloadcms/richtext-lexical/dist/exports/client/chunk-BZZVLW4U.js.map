{
  "version": 3,
  "sources": ["../../../src/lexical/config/client/EditorConfigProvider.tsx"],
  "sourcesContent": ["'use client'\n\nimport type { LexicalEditor } from 'lexical'\nimport type { MarkRequired } from 'ts-essentials'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { useEditDepth } from '@payloadcms/ui'\nimport * as React from 'react'\nimport { createContext, use, useMemo, useRef, useState } from 'react'\n\nimport type { InlineBlockNode } from '../../../features/blocks/client/nodes/InlineBlocksNode.js'\nimport type { LexicalRichTextFieldProps } from '../../../types.js'\nimport type { SanitizedClientEditorConfig } from '../types.js'\n\n// Should always produce a 20 character pseudo-random string\nfunction generateQuickGuid(): string {\n  return Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12)\n}\n\nexport interface EditorConfigContextType {\n  // Editor focus handling\n  blurEditor: (editorContext: EditorConfigContextType) => void\n  childrenEditors: React.RefObject<Map<string, EditorConfigContextType>>\n  createdInlineBlock?: InlineBlockNode\n  editDepth: number\n  editor: LexicalEditor\n  editorConfig: SanitizedClientEditorConfig\n  editorContainerRef: React.RefObject<HTMLDivElement>\n  fieldProps: MarkRequired<LexicalRichTextFieldProps, 'path' | 'schemaPath'>\n  focusedEditor: EditorConfigContextType | null\n  // Editor focus handling\n  focusEditor: (editorContext: EditorConfigContextType) => void\n  parentEditor: EditorConfigContextType\n  registerChild: (uuid: string, editorContext: EditorConfigContextType) => void\n  setCreatedInlineBlock?: React.Dispatch<React.SetStateAction<InlineBlockNode | undefined>>\n  unregisterChild?: (uuid: string) => void\n  uuid: string\n}\n\n// @ts-expect-error: TODO: Fix this\nconst Context: React.Context<EditorConfigContextType> = createContext({\n  editorConfig: null,\n  fieldProps: null,\n  uuid: null,\n})\n\nexport const EditorConfigProvider = ({\n  children,\n  editorConfig,\n  editorContainerRef,\n  fieldProps,\n  parentContext,\n}: {\n  children: React.ReactNode\n  editorConfig: SanitizedClientEditorConfig\n  editorContainerRef: React.RefObject<HTMLDivElement | null>\n\n  fieldProps: LexicalRichTextFieldProps\n  parentContext?: EditorConfigContextType\n}): React.ReactNode => {\n  const [editor] = useLexicalComposerContext()\n  // State to store the UUID\n  const [uuid] = useState(() => generateQuickGuid())\n\n  const childrenEditors = useRef<Map<string, EditorConfigContextType>>(new Map())\n  const [focusedEditor, setFocusedEditor] = useState<EditorConfigContextType | null>(null)\n  const focusHistory = useRef<Set<string>>(new Set())\n  const [createdInlineBlock, setCreatedInlineBlock] = useState<InlineBlockNode>()\n\n  const editDepth = useEditDepth()\n\n  const editorContext = useMemo(\n    () =>\n      ({\n        blurEditor: (editorContext: EditorConfigContextType) => {\n          //setFocusedEditor(null) // Clear focused editor\n          focusHistory.current.clear() // Reset focus history when focus is lost\n        },\n        childrenEditors,\n        createdInlineBlock,\n        editDepth,\n        editor,\n        editorConfig,\n        editorContainerRef,\n        fieldProps,\n        focusedEditor,\n        focusEditor: (editorContext: EditorConfigContextType) => {\n          const editorUUID = editorContext.uuid\n\n          // Avoid recursion by checking if this editor is already focused in this cycle\n          if (focusHistory.current.has(editorUUID)) {\n            return\n          }\n\n          // Add this editor to the history to prevent future recursions in this cycle\n          focusHistory.current.add(editorUUID)\n          setFocusedEditor(editorContext)\n\n          // Propagate focus event to parent and children, ensuring they do not refocus this editor\n          if (parentContext?.uuid) {\n            parentContext.focusEditor(editorContext)\n          }\n          childrenEditors.current.forEach((childEditor) => {\n            childEditor.focusEditor(editorContext)\n          })\n\n          focusHistory.current.clear()\n        },\n        parentEditor: parentContext,\n        registerChild: (childUUID, childEditorContext) => {\n          if (!childrenEditors.current.has(childUUID)) {\n            const newMap = new Map(childrenEditors.current)\n            newMap.set(childUUID, childEditorContext)\n            childrenEditors.current = newMap\n          }\n        },\n        setCreatedInlineBlock,\n        unregisterChild: (childUUID) => {\n          if (childrenEditors.current.has(childUUID)) {\n            const newMap = new Map(childrenEditors.current)\n            newMap.delete(childUUID)\n            childrenEditors.current = newMap\n          }\n        },\n\n        uuid,\n      }) as EditorConfigContextType,\n    [\n      createdInlineBlock,\n      setCreatedInlineBlock,\n      editor,\n      childrenEditors,\n      editorConfig,\n      editorContainerRef,\n      editDepth,\n      fieldProps,\n      focusedEditor,\n      parentContext,\n      uuid,\n    ],\n  )\n\n  return <Context value={editorContext}>{children}</Context>\n}\n\nexport const useEditorConfigContext = (): EditorConfigContextType => {\n  const context = use(Context)\n  if (context === undefined) {\n    throw new Error('useEditorConfigContext must be used within an EditorConfigProvider')\n  }\n  return context\n}\n"],
  "mappings": "wCAKA,OAASA,6BAAAA,MAAiC,2CAC1C,OAASC,gBAAAA,MAAoB,iBAC7B,MAAuB,QACvB,OAASC,iBAAAA,EAAeC,OAAAA,EAAKC,WAAAA,EAASC,UAAAA,EAAQC,YAAAA,MAAgB,QAO9D,SAASC,GAAA,CACP,OAAOC,KAAKC,OAAM,EAAGC,SAAS,EAAA,EAAIC,UAAU,EAAG,EAAA,EAAMH,KAAKC,OAAM,EAAGC,SAAS,EAAA,EAAIC,UAAU,EAAG,EAAA,CAC/F,CAuBA,IAAMC,EAAkDV,EAAc,CACpEW,aAAc,KACdC,WAAY,KACZC,KAAM,IACR,CAAA,EAEaC,EAAuBA,CAAC,CACnCC,SAAAA,EACAJ,aAAAA,EACAK,mBAAAA,EACAJ,WAAAA,EACAK,cAAAA,CAAa,IAQd,CACC,GAAM,CAACC,CAAA,EAAUpB,EAAA,EAEX,CAACe,CAAA,EAAQT,EAAS,IAAMC,EAAA,CAAA,EAExBc,EAAkBhB,EAA6C,IAAIiB,GAAA,EACnE,CAACC,EAAeC,CAAA,EAAoBlB,EAAyC,IAAA,EAC7EmB,EAAepB,EAAoB,IAAIqB,GAAA,EACvC,CAACC,EAAoBC,CAAA,EAAyBtB,EAAA,EAE9CuB,EAAY5B,EAAA,EAEZ6B,EAAgB1B,EACpB,KACG,CACC2B,WAAaD,GAAA,CAEXL,EAAaO,QAAQC,MAAK,CAC5B,EACAZ,gBAAAA,EACAM,mBAAAA,EACAE,UAAAA,EACAT,OAAAA,EACAP,aAAAA,EACAK,mBAAAA,EACAJ,WAAAA,EACAS,cAAAA,EACAW,YAAcJ,GAAA,CACZ,IAAMK,EAAaL,EAAcf,KAG7BU,EAAaO,QAAQI,IAAID,CAAA,IAK7BV,EAAaO,QAAQK,IAAIF,CAAA,EACzBX,EAAiBM,CAAA,EAGbX,GAAeJ,MACjBI,EAAce,YAAYJ,CAAA,EAE5BT,EAAgBW,QAAQM,QAASC,GAAA,CAC/BA,EAAYL,YAAYJ,CAAA,CAC1B,CAAA,EAEAL,EAAaO,QAAQC,MAAK,EAC5B,EACAO,aAAcrB,EACdsB,cAAeA,CAACC,EAAWC,IAAA,CACzB,GAAI,CAACtB,EAAgBW,QAAQI,IAAIM,CAAA,EAAY,CAC3C,IAAME,EAAS,IAAItB,IAAID,EAAgBW,OAAO,EAC9CY,EAAOC,IAAIH,EAAWC,CAAA,EACtBtB,EAAgBW,QAAUY,CAC5B,CACF,EACAhB,sBAAAA,EACAkB,gBAAkBJ,GAAA,CAChB,GAAIrB,EAAgBW,QAAQI,IAAIM,CAAA,EAAY,CAC1C,IAAME,EAAS,IAAItB,IAAID,EAAgBW,OAAO,EAC9CY,EAAOG,OAAOL,CAAA,EACdrB,EAAgBW,QAAUY,CAC5B,CACF,EAEA7B,KAAAA,CACF,GACF,CACEY,EACAC,EACAR,EACAC,EACAR,EACAK,EACAW,EACAf,EACAS,EACAJ,EACAJ,CAAA,CACD,EAGH,OAAOiC,EAACpC,EAAA,CAAQqC,MAAOnB,WAAgBb,GACzC,EAEaiC,EAAyBA,IAAA,CACpC,IAAMC,EAAUhD,EAAIS,CAAA,EACpB,GAAIuC,IAAYC,OACd,MAAM,IAAIC,MAAM,oEAAA,EAElB,OAAOF,CACT",
  "names": ["useLexicalComposerContext", "useEditDepth", "createContext", "use", "useMemo", "useRef", "useState", "generateQuickGuid", "Math", "random", "toString", "substring", "Context", "editorConfig", "fieldProps", "uuid", "EditorConfigProvider", "children", "editorContainerRef", "parentContext", "editor", "childrenEditors", "Map", "focusedEditor", "setFocusedEditor", "focusHistory", "Set", "createdInlineBlock", "setCreatedInlineBlock", "editDepth", "editorContext", "blurEditor", "current", "clear", "focusEditor", "editorUUID", "has", "add", "forEach", "childEditor", "parentEditor", "registerChild", "childUUID", "childEditorContext", "newMap", "set", "unregisterChild", "delete", "_jsx", "value", "useEditorConfigContext", "context", "undefined", "Error"]
}
