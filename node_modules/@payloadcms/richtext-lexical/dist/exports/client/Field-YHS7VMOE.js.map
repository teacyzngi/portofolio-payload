{
  "version": 3,
  "sources": ["../../../src/field/Field.tsx", "../../../src/lexical/LexicalProvider.tsx", "../../../src/lexical/LexicalEditor.tsx", "../../../src/lexical/EditorPlugin.tsx", "../../../src/lexical/plugins/ClipboardPlugin/index.tsx", "../../../src/lexical/plugins/DecoratorPlugin/index.tsx", "../../../src/lexical/plugins/handles/AddBlockHandlePlugin/index.tsx", "../../../src/lexical/plugins/handles/utils/calculateDistanceFromScrollerElem.ts", "../../../src/lexical/plugins/handles/utils/getNodeCloseToPoint.ts", "../../../src/lexical/plugins/handles/DraggableBlockPlugin/getBoundingRectWithoutTransform.ts", "../../../src/lexical/plugins/handles/utils/getCollapsedMargins.ts", "../../../src/lexical/plugins/handles/utils/getTopLevelNodeKeys.ts", "../../../src/lexical/plugins/handles/utils/isOnHandleElement.ts", "../../../src/lexical/plugins/handles/utils/doesLineHeightAffectElement.ts", "../../../src/lexical/plugins/handles/utils/setHandlePosition.ts", "../../../src/lexical/plugins/handles/DraggableBlockPlugin/index.tsx", "../../../src/lexical/plugins/handles/DraggableBlockPlugin/setTargetLine.ts", "../../../src/lexical/plugins/InsertParagraphAtEnd/index.tsx", "../../../src/lexical/plugins/MarkdownShortcut/index.tsx", "../../../src/lexical/plugins/NormalizeSelection/index.tsx", "../../../src/lexical/plugins/SelectAllPlugin/index.tsx", "../../../src/lexical/plugins/SlashMenu/index.tsx", "../../../src/lexical/plugins/SlashMenu/useMenuTriggerMatch.ts", "../../../src/lexical/plugins/TextPlugin/index.tsx", "../../../src/lexical/ui/ContentEditable.tsx"],
  "sourcesContent": ["'use client'\nimport type { EditorState, SerializedEditorState } from 'lexical'\n\nimport {\n  FieldDescription,\n  FieldError,\n  FieldLabel,\n  RenderCustomComponent,\n  useEditDepth,\n  useEffectEvent,\n  useField,\n} from '@payloadcms/ui'\nimport { mergeFieldStyles } from '@payloadcms/ui/shared'\nimport { dequal } from 'dequal/lite'\nimport { type Validate } from 'payload'\nimport React, { useCallback, useEffect, useMemo, useState } from 'react'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nimport type { SanitizedClientEditorConfig } from '../lexical/config/types.js'\n\nimport '../lexical/theme/EditorTheme.scss'\nimport './bundled.css'\nimport './index.scss'\n\nimport type { LexicalRichTextFieldProps } from '../types.js'\n\nimport { LexicalProvider } from '../lexical/LexicalProvider.js'\nimport { useRunDeprioritized } from '../utilities/useRunDeprioritized.js'\n\nconst baseClass = 'rich-text-lexical'\n\nconst RichTextComponent: React.FC<\n  {\n    readonly editorConfig: SanitizedClientEditorConfig // With rendered features n stuff\n  } & LexicalRichTextFieldProps\n> = (props) => {\n  const {\n    editorConfig,\n    field,\n    field: {\n      admin: { className, description, readOnly: readOnlyFromAdmin } = {},\n      label,\n      localized,\n      required,\n    },\n    path: pathFromProps,\n    readOnly: readOnlyFromTopLevelProps,\n    validate, // Users can pass in client side validation if they WANT to, but it's not required anymore\n  } = props\n\n  const readOnlyFromProps = readOnlyFromTopLevelProps || readOnlyFromAdmin\n\n  const editDepth = useEditDepth()\n\n  const memoizedValidate = useCallback<Validate>(\n    (value, validationOptions) => {\n      if (typeof validate === 'function') {\n        // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n        return validate(value, { ...validationOptions, required })\n      }\n      return true\n    },\n    // Important: do not add props to the dependencies array.\n    // This would cause an infinite loop and endless re-rendering.\n    // Removing props from the dependencies array fixed this issue: https://github.com/payloadcms/payload/issues/3709\n    [validate, required],\n  )\n\n  const {\n    customComponents: { AfterInput, BeforeInput, Description, Error, Label } = {},\n    disabled: disabledFromField,\n    initialValue,\n    path,\n    setValue,\n    showError,\n    value,\n  } = useField<SerializedEditorState>({\n    potentiallyStalePath: pathFromProps,\n    validate: memoizedValidate,\n  })\n\n  const disabled = readOnlyFromProps || disabledFromField\n\n  const [isSmallWidthViewport, setIsSmallWidthViewport] = useState<boolean>(false)\n  const [rerenderProviderKey, setRerenderProviderKey] = useState<Date>()\n\n  const prevInitialValueRef = React.useRef<SerializedEditorState | undefined>(initialValue)\n  const prevValueRef = React.useRef<SerializedEditorState | undefined>(value)\n\n  useEffect(() => {\n    const updateViewPortWidth = () => {\n      const isNextSmallWidthViewport = window.matchMedia('(max-width: 768px)').matches\n\n      if (isNextSmallWidthViewport !== isSmallWidthViewport) {\n        setIsSmallWidthViewport(isNextSmallWidthViewport)\n      }\n    }\n    updateViewPortWidth()\n    window.addEventListener('resize', updateViewPortWidth)\n\n    return () => {\n      window.removeEventListener('resize', updateViewPortWidth)\n    }\n  }, [isSmallWidthViewport])\n\n  const classes = [\n    baseClass,\n    'field-type',\n    className,\n    showError && 'error',\n    disabled && `${baseClass}--read-only`,\n    editorConfig?.admin?.hideGutter !== true && !isSmallWidthViewport\n      ? `${baseClass}--show-gutter`\n      : null,\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  const pathWithEditDepth = `${path}.${editDepth}`\n\n  const runDeprioritized = useRunDeprioritized() // defaults to 500 ms timeout\n\n  const handleChange = useCallback(\n    (editorState: EditorState) => {\n      // Capture `editorState` in the closure so we can safely run later.\n      const updateFieldValue = () => {\n        const newState = editorState.toJSON()\n        prevValueRef.current = newState\n        setValue(newState)\n      }\n\n      // Queue the update for the browserâ€™s idle time (or Safari shim)\n      // and let the hook handle debouncing/cancellation.\n      void runDeprioritized(updateFieldValue)\n    },\n    [setValue, runDeprioritized], // `runDeprioritized` is stable (useCallback inside hook)\n  )\n\n  const styles = useMemo(() => mergeFieldStyles(field), [field])\n\n  const handleInitialValueChange = useEffectEvent(\n    (initialValue: SerializedEditorState | undefined) => {\n      // Object deep equality check here, as re-mounting the editor if\n      // the new value is the same as the old one is not necessary.\n      // In postgres, the order of keys in JSON objects is not guaranteed to be preserved,\n      // so we need to do a deep equality check here that does not care about key order => we use dequal.\n      // If we used JSON.stringify, the editor would re-mount every time you save the document, as the order of keys changes => change detected => re-mount.\n      if (\n        prevValueRef.current !== value &&\n        !dequal(JSON.parse(JSON.stringify(prevValueRef.current)), value)\n      ) {\n        prevInitialValueRef.current = initialValue\n        prevValueRef.current = value\n        setRerenderProviderKey(new Date())\n      }\n    },\n  )\n\n  useEffect(() => {\n    // Needs to trigger for object reference changes - otherwise,\n    // reacting to the same initial value change twice will cause\n    // the second change to be ignored, even though the value has changed.\n    // That's because initialValue is not kept up-to-date\n    if (!Object.is(initialValue, prevInitialValueRef.current)) {\n      handleInitialValueChange(initialValue)\n    }\n  }, [initialValue])\n\n  return (\n    <div className={classes} key={pathWithEditDepth} style={styles}>\n      <RenderCustomComponent\n        CustomComponent={Error}\n        Fallback={<FieldError path={path} showError={showError} />}\n      />\n      {Label || <FieldLabel label={label} localized={localized} path={path} required={required} />}\n      <div className={`${baseClass}__wrap`}>\n        <ErrorBoundary fallbackRender={fallbackRender} onReset={() => {}}>\n          {BeforeInput}\n          <LexicalProvider\n            composerKey={pathWithEditDepth}\n            editorConfig={editorConfig}\n            fieldProps={props}\n            isSmallWidthViewport={isSmallWidthViewport}\n            key={JSON.stringify({ path, rerenderProviderKey })} // makes sure lexical is completely re-rendered when initialValue changes, bypassing the lexical-internal value memoization. That way, external changes to the form will update the editor. More infos in PR description (https://github.com/payloadcms/payload/pull/5010)\n            onChange={handleChange}\n            readOnly={disabled}\n            value={value}\n          />\n          {AfterInput}\n        </ErrorBoundary>\n        <RenderCustomComponent\n          CustomComponent={Description}\n          Fallback={<FieldDescription description={description} path={path} />}\n        />\n      </div>\n    </div>\n  )\n}\n\nfunction fallbackRender({ error }: { error: Error }) {\n  // Call resetErrorBoundary() to reset the error boundary and retry the render.\n\n  return (\n    <div className=\"errorBoundary\" role=\"alert\">\n      <p>Something went wrong:</p>\n      <pre style={{ color: 'red' }}>{error.message}</pre>\n    </div>\n  )\n}\n\nexport const RichText: typeof RichTextComponent = RichTextComponent\n", "'use client'\nimport type { InitialConfigType } from '@lexical/react/LexicalComposer.js'\nimport type { EditorState, LexicalEditor, SerializedEditorState } from 'lexical'\n\nimport { LexicalComposer } from '@lexical/react/LexicalComposer.js'\nimport { useEditDepth } from '@payloadcms/ui'\nimport * as React from 'react'\nimport { useMemo } from 'react'\n\nimport type { LexicalRichTextFieldProps } from '../types.js'\nimport type { SanitizedClientEditorConfig } from './config/types.js'\n\nimport {\n  EditorConfigProvider,\n  useEditorConfigContext,\n} from './config/client/EditorConfigProvider.js'\nimport { LexicalEditor as LexicalEditorComponent } from './LexicalEditor.js'\nimport { getEnabledNodes } from './nodes/index.js'\n\nexport type LexicalProviderProps = {\n  composerKey: string\n  editorConfig: SanitizedClientEditorConfig\n  fieldProps: LexicalRichTextFieldProps\n  isSmallWidthViewport: boolean\n  onChange: (editorState: EditorState, editor: LexicalEditor, tags: Set<string>) => void\n  readOnly: boolean\n  value: SerializedEditorState\n}\n\nconst NestProviders = ({\n  children,\n  providers,\n}: {\n  children: React.ReactNode\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  providers: any[]\n}) => {\n  if (!providers?.length) {\n    return children\n  }\n  const Component = providers[0]\n  if (providers.length > 1) {\n    return (\n      <Component>\n        <NestProviders providers={providers.slice(1)}>{children}</NestProviders>\n      </Component>\n    )\n  }\n  return <Component>{children}</Component>\n}\n\nexport const LexicalProvider: React.FC<LexicalProviderProps> = (props) => {\n  const { composerKey, editorConfig, fieldProps, isSmallWidthViewport, onChange, readOnly, value } =\n    props\n\n  const parentContext = useEditorConfigContext()\n\n  const editDepth = useEditDepth()\n\n  const editorContainerRef = React.useRef<HTMLDivElement>(null)\n\n  // useMemo for the initialConfig that depends on readOnly and value\n  const initialConfig = useMemo<InitialConfigType>(() => {\n    if (value && typeof value !== 'object') {\n      throw new Error(\n        'The value passed to the Lexical editor is not an object. This is not supported. Please remove the data from the field and start again. This is the value that was passed in: ' +\n          JSON.stringify(value),\n      )\n    }\n\n    if (value && Array.isArray(value) && !('root' in value)) {\n      throw new Error(\n        'You have tried to pass in data from the old Slate editor to the new Lexical editor. The data structure is different, thus you will have to migrate your data. We offer a one-line migration script which migrates all your rich text fields: https://payloadcms.com/docs/lexical/migration#migration-via-migration-script-recommended',\n      )\n    }\n\n    if (value && 'jsonContent' in value) {\n      throw new Error(\n        'You have tried to pass in data from payload-plugin-lexical. The data structure is different, thus you will have to migrate your data. Migration guide: https://payloadcms.com/docs/lexical/migration#migrating-from-payload-plugin-lexical',\n      )\n    }\n\n    return {\n      editable: readOnly !== true,\n      editorState: value != null ? JSON.stringify(value) : undefined,\n      namespace: editorConfig.lexical.namespace,\n      nodes: getEnabledNodes({ editorConfig }),\n      onError: (error: Error) => {\n        throw error\n      },\n      theme: editorConfig.lexical.theme,\n    }\n    // Important: do not add readOnly and value to the dependencies array. This will cause the entire lexical editor to re-render if the document is saved, which will\n    // cause the editor to lose focus.\n  }, [editorConfig])\n\n  if (!initialConfig) {\n    return <p>Loading...</p>\n  }\n\n  // We need to add initialConfig.editable to the key to force a re-render when the readOnly prop changes.\n  // Without it, there were cases where lexical editors inside drawers turn readOnly initially - a few miliseconds later they turn editable, but the editor does not re-render and stays readOnly.\n  return (\n    <LexicalComposer initialConfig={initialConfig} key={composerKey + initialConfig.editable}>\n      <EditorConfigProvider\n        editorConfig={editorConfig}\n        editorContainerRef={editorContainerRef}\n        fieldProps={fieldProps}\n        /**\n         * Parent editor is not truly the parent editor, if the current editor is part of a drawer and the parent editor is the main editor.\n         */\n        parentContext={parentContext?.editDepth === editDepth ? parentContext : undefined}\n      >\n        <NestProviders providers={editorConfig.features.providers}>\n          <LexicalEditorComponent\n            editorConfig={editorConfig}\n            editorContainerRef={editorContainerRef}\n            isSmallWidthViewport={isSmallWidthViewport}\n            onChange={onChange}\n          />\n        </NestProviders>\n      </EditorConfigProvider>\n    </LexicalComposer>\n  )\n}\n", "'use client'\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { LexicalErrorBoundary } from '@lexical/react/LexicalErrorBoundary.js'\nimport { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin.js'\nimport { OnChangePlugin } from '@lexical/react/LexicalOnChangePlugin.js'\nimport { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin.js'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport { BLUR_COMMAND, COMMAND_PRIORITY_LOW, FOCUS_COMMAND } from 'lexical'\nimport * as React from 'react'\nimport { useEffect, useState } from 'react'\n\nimport type { LexicalProviderProps } from './LexicalProvider.js'\n\nimport { useEditorConfigContext } from './config/client/EditorConfigProvider.js'\nimport './LexicalEditor.scss'\nimport { EditorPlugin } from './EditorPlugin.js'\nimport { ClipboardPlugin } from './plugins/ClipboardPlugin/index.js'\nimport { DecoratorPlugin } from './plugins/DecoratorPlugin/index.js'\nimport { AddBlockHandlePlugin } from './plugins/handles/AddBlockHandlePlugin/index.js'\nimport { DraggableBlockPlugin } from './plugins/handles/DraggableBlockPlugin/index.js'\nimport { InsertParagraphAtEndPlugin } from './plugins/InsertParagraphAtEnd/index.js'\nimport { MarkdownShortcutPlugin } from './plugins/MarkdownShortcut/index.js'\nimport { NormalizeSelectionPlugin } from './plugins/NormalizeSelection/index.js'\nimport { SelectAllPlugin } from './plugins/SelectAllPlugin/index.js'\nimport { SlashMenuPlugin } from './plugins/SlashMenu/index.js'\nimport { TextPlugin } from './plugins/TextPlugin/index.js'\nimport { LexicalContentEditable } from './ui/ContentEditable.js'\n\nexport const LexicalEditor: React.FC<\n  {\n    editorContainerRef: React.RefObject<HTMLDivElement | null>\n    isSmallWidthViewport: boolean\n  } & Pick<LexicalProviderProps, 'editorConfig' | 'onChange'>\n> = (props) => {\n  const { editorConfig, editorContainerRef, isSmallWidthViewport, onChange } = props\n  const editorConfigContext = useEditorConfigContext()\n  const [editor] = useLexicalComposerContext()\n  const isEditable = useLexicalEditable()\n\n  const [floatingAnchorElem, setFloatingAnchorElem] = useState<HTMLDivElement | null>(null)\n  const onRef = (_floatingAnchorElem: HTMLDivElement) => {\n    if (_floatingAnchorElem !== null) {\n      setFloatingAnchorElem(_floatingAnchorElem)\n    }\n  }\n\n  useEffect(() => {\n    if (!editorConfigContext?.uuid) {\n      console.error('Lexical Editor must be used within an EditorConfigProvider')\n      return\n    }\n    if (editorConfigContext?.parentEditor?.uuid) {\n      editorConfigContext.parentEditor?.registerChild(editorConfigContext.uuid, editorConfigContext)\n    }\n\n    const handleFocus = () => {\n      editorConfigContext.focusEditor(editorConfigContext)\n    }\n\n    const handleBlur = () => {\n      editorConfigContext.blurEditor(editorConfigContext)\n    }\n\n    const unregisterFocus = editor.registerCommand<MouseEvent>(\n      FOCUS_COMMAND,\n      () => {\n        handleFocus()\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n\n    const unregisterBlur = editor.registerCommand<MouseEvent>(\n      BLUR_COMMAND,\n      () => {\n        handleBlur()\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n\n    return () => {\n      unregisterFocus()\n      unregisterBlur()\n      editorConfigContext.parentEditor?.unregisterChild?.(editorConfigContext.uuid)\n    }\n  }, [editor, editorConfigContext])\n\n  return (\n    <React.Fragment>\n      {editorConfig.features.plugins?.map((plugin) => {\n        if (plugin.position === 'aboveContainer') {\n          return <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n        }\n      })}\n      <div className=\"editor-container\" ref={editorContainerRef}>\n        {editorConfig.features.plugins?.map((plugin) => {\n          if (plugin.position === 'top') {\n            return (\n              <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n            )\n          }\n        })}\n        <RichTextPlugin\n          contentEditable={\n            <div className=\"editor-scroller\">\n              <div className=\"editor\" ref={onRef}>\n                <LexicalContentEditable editorConfig={editorConfig} />\n              </div>\n            </div>\n          }\n          ErrorBoundary={LexicalErrorBoundary}\n        />\n        <NormalizeSelectionPlugin />\n        {isEditable && <InsertParagraphAtEndPlugin />}\n        <DecoratorPlugin />\n        <ClipboardPlugin />\n        <TextPlugin features={editorConfig.features} />\n        <SelectAllPlugin />\n        {isEditable && (\n          <OnChangePlugin\n            // Selection changes can be ignored here, reducing the\n            // frequency that the FieldComponent and Payload receive updates.\n            // Selection changes are only needed if you are saving selection state\n            ignoreSelectionChange\n            onChange={(editorState, editor, tags) => {\n              // Ignore any onChange event triggered by focus only\n              if (!tags.has('focus') || tags.size > 1) {\n                if (onChange != null) {\n                  onChange(editorState, editor, tags)\n                }\n              }\n            }}\n          />\n        )}\n        {floatingAnchorElem && (\n          <React.Fragment>\n            {!isSmallWidthViewport && isEditable && (\n              <React.Fragment>\n                {editorConfig.admin?.hideDraggableBlockElement ? null : (\n                  <DraggableBlockPlugin anchorElem={floatingAnchorElem} />\n                )}\n                {editorConfig.admin?.hideAddBlockButton ? null : (\n                  <AddBlockHandlePlugin anchorElem={floatingAnchorElem} />\n                )}\n              </React.Fragment>\n            )}\n            {editorConfig.features.plugins?.map((plugin) => {\n              if (\n                plugin.position === 'floatingAnchorElem' &&\n                !(plugin.desktopOnly === true && isSmallWidthViewport)\n              ) {\n                return (\n                  <EditorPlugin\n                    anchorElem={floatingAnchorElem}\n                    clientProps={plugin.clientProps}\n                    key={plugin.key}\n                    plugin={plugin}\n                  />\n                )\n              }\n            })}\n            {isEditable && (\n              <React.Fragment>\n                <SlashMenuPlugin anchorElem={floatingAnchorElem} />\n              </React.Fragment>\n            )}\n          </React.Fragment>\n        )}\n        {isEditable && (\n          <React.Fragment>\n            <HistoryPlugin />\n            {editorConfig?.features?.markdownTransformers?.length > 0 && <MarkdownShortcutPlugin />}\n          </React.Fragment>\n        )}\n        {editorConfig.features.plugins?.map((plugin) => {\n          if (plugin.position === 'normal') {\n            return (\n              <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n            )\n          }\n        })}\n        {editorConfig.features.plugins?.map((plugin) => {\n          if (plugin.position === 'bottom') {\n            return (\n              <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n            )\n          }\n        })}\n      </div>\n      {editorConfig.features.plugins?.map((plugin) => {\n        if (plugin.position === 'belowContainer') {\n          return <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n        }\n      })}\n    </React.Fragment>\n  )\n}\n", "'use client'\nimport React from 'react'\n\nimport type { SanitizedPlugin } from '../features/typesClient.js'\n\nexport const EditorPlugin: React.FC<{\n  anchorElem?: HTMLDivElement\n  clientProps: unknown\n  plugin: SanitizedPlugin\n}> = ({ anchorElem, clientProps, plugin }) => {\n  if (plugin.position === 'floatingAnchorElem' && anchorElem) {\n    return (\n      plugin.Component && <plugin.Component anchorElem={anchorElem} clientProps={clientProps} />\n    )\n  }\n\n  // @ts-expect-error - ts is not able to infer that plugin.Component is of type PluginComponent\n  return plugin.Component && <plugin.Component clientProps={clientProps} />\n}\n", "'use client'\n\nimport { copyToClipboard } from '@lexical/clipboard'\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { objectKlassEquals } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport { COMMAND_PRIORITY_LOW, COPY_COMMAND } from 'lexical'\nimport { useEffect } from 'react'\n\ntype SerializedUnknownLexicalNode = {\n  children?: SerializedUnknownLexicalNode[]\n  type: string\n}\n\nexport function ClipboardPlugin() {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    // Remove duplicated ids from clipboard. We do it here because:\n    // 1. Browsers do not allow setting the clipboardData in paste event for security reasons.\n    // 2. If you cut instead of paste, the id will be kept, which is a good thing.\n    return editor.registerCommand(\n      COPY_COMMAND,\n      (event) => {\n        copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null)\n          .then(() => {\n            if (!(event instanceof ClipboardEvent) || !event.clipboardData) {\n              throw new Error('No clipboard event')\n            }\n            const lexicalStringified = event.clipboardData.getData('application/x-lexical-editor')\n            if (!lexicalStringified) {\n              return true\n            }\n\n            const lexical = JSON.parse(lexicalStringified) as {\n              nodes: SerializedUnknownLexicalNode[]\n            }\n            const changeIds = (node: SerializedUnknownLexicalNode) => {\n              if (\n                'fields' in node &&\n                typeof node.fields === 'object' &&\n                node.fields !== null &&\n                'id' in node.fields\n              ) {\n                node.fields.id = new ObjectID.default().toHexString()\n              } else if ('id' in node) {\n                node.id = new ObjectID.default().toHexString()\n              }\n\n              if (node.children) {\n                for (const child of node.children) {\n                  changeIds(child)\n                }\n              }\n            }\n            for (const node of lexical.nodes) {\n              changeIds(node)\n            }\n            const stringified = JSON.stringify(lexical)\n            event.clipboardData.setData('application/x-lexical-editor', stringified)\n          })\n          .catch((error) => {\n            if (event instanceof ClipboardEvent) {\n              event.clipboardData?.setData('application/x-lexical-editor', '')\n            }\n            throw error\n          })\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n  }, [editor])\n\n  return null\n}\n", "'use client'\n\nimport type { DecoratorNode, ElementNode, LexicalNode } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $findMatchingParent, mergeRegister } from '@lexical/utils'\nimport {\n  $createNodeSelection,\n  $getEditor,\n  $getNearestNodeFromDOMNode,\n  $getSelection,\n  $isDecoratorNode,\n  $isElementNode,\n  $isLineBreakNode,\n  $isNodeSelection,\n  $isRangeSelection,\n  $isRootOrShadowRoot,\n  $isTextNode,\n  $setSelection,\n  CLICK_COMMAND,\n  COMMAND_PRIORITY_LOW,\n  KEY_ARROW_DOWN_COMMAND,\n  KEY_ARROW_UP_COMMAND,\n  KEY_BACKSPACE_COMMAND,\n  KEY_DELETE_COMMAND,\n  SELECTION_CHANGE_COMMAND,\n} from 'lexical'\nimport { useEffect } from 'react'\n\nimport './index.scss'\n\n// TODO: This should ideally be fixed in Lexical. See\n// https://github.com/facebook/lexical/pull/7072\nexport function DecoratorPlugin() {\n  const [editor] = useLexicalComposerContext()\n\n  const $onDelete = (event: KeyboardEvent) => {\n    const selection = $getSelection()\n    if (!$isNodeSelection(selection)) {\n      return false\n    }\n    event.preventDefault()\n    selection.getNodes().forEach((node) => {\n      node.remove()\n    })\n    return true\n  }\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        CLICK_COMMAND,\n        (event) => {\n          document.querySelector('.decorator-selected')?.classList.remove('decorator-selected')\n          const decorator = $getDecoratorByMouseEvent(event)\n          if (!decorator) {\n            return true\n          }\n          const { target } = event\n          const isInteractive =\n            !(target instanceof HTMLElement) ||\n            target.isContentEditable ||\n            target.closest(\n              'button, textarea, input, .react-select, .code-editor, .no-select-decorator, [role=\"button\"]',\n            )\n          if (isInteractive) {\n            $setSelection(null)\n          } else {\n            $selectDecorator(decorator)\n          }\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(KEY_DELETE_COMMAND, $onDelete, COMMAND_PRIORITY_LOW),\n      editor.registerCommand(KEY_BACKSPACE_COMMAND, $onDelete, COMMAND_PRIORITY_LOW),\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        () => {\n          const decorator = $getSelectedDecorator()\n          document.querySelector('.decorator-selected')?.classList.remove('decorator-selected')\n          if (decorator) {\n            decorator.element?.classList.add('decorator-selected')\n            return true\n          }\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        KEY_ARROW_UP_COMMAND,\n        (event) => {\n          // CASE 1: Node selection\n          const selection = $getSelection()\n          if ($isNodeSelection(selection)) {\n            const prevSibling = selection.getNodes()[0]?.getPreviousSibling()\n            if ($isDecoratorNode(prevSibling)) {\n              const element = $getEditor().getElementByKey(prevSibling.getKey())\n              if (element) {\n                $selectDecorator({ element, node: prevSibling })\n                event.preventDefault()\n                return true\n              }\n              return false\n            }\n            if (!$isElementNode(prevSibling)) {\n              return false\n            }\n            const lastDescendant = prevSibling.getLastDescendant() ?? prevSibling\n            if (!lastDescendant) {\n              return false\n            }\n            const block = $findMatchingParent(lastDescendant, INTERNAL_$isBlock)\n            block?.selectStart()\n            event.preventDefault()\n            return true\n          }\n          if (!$isRangeSelection(selection)) {\n            return false\n          }\n\n          // CASE 2: Range selection\n          // Get first selected block\n          const firstPoint = selection.isBackward() ? selection.anchor : selection.focus\n          const firstNode = firstPoint.getNode()\n          const firstSelectedBlock = $findMatchingParent(firstNode, (node) => {\n            return findFirstSiblingBlock(node) !== null\n          })\n          const prevBlock = firstSelectedBlock?.getPreviousSibling()\n          if (!firstSelectedBlock || prevBlock !== findFirstSiblingBlock(firstSelectedBlock)) {\n            return false\n          }\n\n          if ($isDecoratorNode(prevBlock)) {\n            const prevBlockElement = $getEditor().getElementByKey(prevBlock.getKey())\n            if (prevBlockElement) {\n              $selectDecorator({ element: prevBlockElement, node: prevBlock })\n              event.preventDefault()\n              return true\n            }\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        KEY_ARROW_DOWN_COMMAND,\n        (event) => {\n          // CASE 1: Node selection\n          const selection = $getSelection()\n          if ($isNodeSelection(selection)) {\n            event.preventDefault()\n            const nextSibling = selection.getNodes()[0]?.getNextSibling()\n            if ($isDecoratorNode(nextSibling)) {\n              const element = $getEditor().getElementByKey(nextSibling.getKey())\n              if (element) {\n                $selectDecorator({ element, node: nextSibling })\n              }\n              return true\n            }\n            if (!$isElementNode(nextSibling)) {\n              return true\n            }\n            const firstDescendant = nextSibling.getFirstDescendant() ?? nextSibling\n            if (!firstDescendant) {\n              return true\n            }\n            const block = $findMatchingParent(firstDescendant, INTERNAL_$isBlock)\n            block?.selectEnd()\n            event.preventDefault()\n            return true\n          }\n          if (!$isRangeSelection(selection)) {\n            return false\n          }\n\n          // CASE 2: Range selection\n          // Get last selected block\n          const lastPoint = selection.isBackward() ? selection.anchor : selection.focus\n          const lastNode = lastPoint.getNode()\n          const lastSelectedBlock = $findMatchingParent(lastNode, (node) => {\n            return findLaterSiblingBlock(node) !== null\n          })\n          const nextBlock = lastSelectedBlock?.getNextSibling()\n          if (!lastSelectedBlock || nextBlock !== findLaterSiblingBlock(lastSelectedBlock)) {\n            return false\n          }\n\n          if ($isDecoratorNode(nextBlock)) {\n            const nextBlockElement = $getEditor().getElementByKey(nextBlock.getKey())\n            if (nextBlockElement) {\n              $selectDecorator({ element: nextBlockElement, node: nextBlock })\n              event.preventDefault()\n              return true\n            }\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor])\n\n  return null\n}\n\nfunction $getDecoratorByMouseEvent(\n  event: MouseEvent,\n): { element: HTMLElement; node: DecoratorNode<unknown> } | undefined {\n  if (!(event.target instanceof HTMLElement)) {\n    return undefined\n  }\n  const element = event.target.closest('[data-lexical-decorator=\"true\"]')\n  if (!(element instanceof HTMLElement)) {\n    return undefined\n  }\n  const node = $getNearestNodeFromDOMNode(element)\n  return $isDecoratorNode(node) ? { element, node } : undefined\n}\n\nfunction $getSelectedDecorator() {\n  const selection = $getSelection()\n  if (!$isNodeSelection(selection)) {\n    return undefined\n  }\n  const nodes = selection.getNodes()\n  if (nodes.length !== 1) {\n    return undefined\n  }\n  const node = nodes[0]\n  return $isDecoratorNode(node)\n    ? {\n        decorator: node,\n        element: $getEditor().getElementByKey(node.getKey()),\n      }\n    : undefined\n}\n\nfunction $selectDecorator({\n  element,\n  node,\n}: {\n  element: HTMLElement\n  node: DecoratorNode<unknown>\n}) {\n  document.querySelector('.decorator-selected')?.classList.remove('decorator-selected')\n  const selection = $createNodeSelection()\n  selection.add(node.getKey())\n  $setSelection(selection)\n  element.scrollIntoView({ behavior: 'smooth', block: 'nearest' })\n  element.classList.add('decorator-selected')\n}\n\n/**\n * Copied from https://github.com/facebook/lexical/blob/main/packages/lexical/src/LexicalUtils.ts\n *\n * This function returns true for a DecoratorNode that is not inline OR\n * an ElementNode that is:\n * - not a root or shadow root\n * - not inline\n * - can't be empty\n * - has no children or an inline first child\n */\nexport function INTERNAL_$isBlock(node: LexicalNode): node is DecoratorNode<unknown> | ElementNode {\n  if ($isDecoratorNode(node) && !node.isInline()) {\n    return true\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false\n  }\n\n  const firstChild = node.getFirstChild()\n  const isLeafElement =\n    firstChild === null ||\n    $isLineBreakNode(firstChild) ||\n    $isTextNode(firstChild) ||\n    firstChild.isInline()\n\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement\n}\n\nfunction findLaterSiblingBlock(node: LexicalNode): LexicalNode | null {\n  let current = node.getNextSibling()\n  while (current !== null) {\n    if (INTERNAL_$isBlock(current)) {\n      return current\n    }\n    current = current.getNextSibling()\n  }\n  return null\n}\n\nfunction findFirstSiblingBlock(node: LexicalNode): LexicalNode | null {\n  let current = node.getPreviousSibling()\n  while (current !== null) {\n    if (INTERNAL_$isBlock(current)) {\n      return current\n    }\n    current = current.getPreviousSibling()\n  }\n  return null\n}\n", "'use client'\nimport type { LexicalEditor, LexicalNode, ParagraphNode } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { $createParagraphNode, isHTMLElement } from 'lexical'\nimport * as React from 'react'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useEditorConfigContext } from '../../../config/client/EditorConfigProvider.js'\nimport { Point } from '../../../utils/point.js'\nimport { ENABLE_SLASH_MENU_COMMAND } from '../../SlashMenu/LexicalTypeaheadMenuPlugin/index.js'\nimport { calculateDistanceFromScrollerElem } from '../utils/calculateDistanceFromScrollerElem.js'\nimport { getNodeCloseToPoint } from '../utils/getNodeCloseToPoint.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\nimport { isOnHandleElement } from '../utils/isOnHandleElement.js'\nimport { setHandlePosition } from '../utils/setHandlePosition.js'\nimport './index.scss'\n\nconst ADD_BLOCK_MENU_CLASSNAME = 'add-block-menu'\n\nlet prevIndex = Infinity\n\nfunction getCurrentIndex(keysLength: number): number {\n  if (keysLength === 0) {\n    return Infinity\n  }\n  if (prevIndex >= 0 && prevIndex < keysLength) {\n    return prevIndex\n  }\n\n  return Math.floor(keysLength / 2)\n}\n\nfunction useAddBlockHandle(\n  editor: LexicalEditor,\n  anchorElem: HTMLElement,\n  isEditable: boolean,\n): React.ReactElement {\n  const scrollerElem = anchorElem.parentElement\n\n  const { editorConfig } = useEditorConfigContext()\n  const blockHandleHorizontalOffset = editorConfig?.admin?.hideGutter ? -24 : 12\n\n  const menuRef = useRef<HTMLButtonElement>(null)\n  const [hoveredElement, setHoveredElement] = useState<{\n    elem: HTMLElement\n    node: LexicalNode\n  } | null>(null)\n\n  useEffect(() => {\n    function onDocumentMouseMove(event: MouseEvent) {\n      const target = event.target\n      if (!isHTMLElement(target)) {\n        return\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n      )\n\n      if (distanceFromScrollerElem === -1) {\n        setHoveredElement(null)\n        return\n      }\n\n      if (isOnHandleElement(target, ADD_BLOCK_MENU_CLASSNAME)) {\n        return\n      }\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: _emptyBlockElem,\n        blockNode,\n        foundAtIndex,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        cache_threshold: 0,\n        editor,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        returnEmptyParagraphs: true,\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: false,\n      })\n\n      prevIndex = foundAtIndex\n\n      if (!_emptyBlockElem) {\n        return\n      }\n      if (\n        blockNode &&\n        (hoveredElement?.node !== blockNode || hoveredElement?.elem !== _emptyBlockElem)\n      ) {\n        setHoveredElement({\n          elem: _emptyBlockElem,\n          node: blockNode,\n        })\n      }\n    }\n\n    // Since the draggableBlockElem is outside the actual editor, we need to listen to the document\n    // to be able to detect when the mouse is outside the editor and respect a buffer around\n    // the scrollerElem to avoid the draggableBlockElem disappearing too early.\n    document?.addEventListener('mousemove', onDocumentMouseMove)\n\n    return () => {\n      document?.removeEventListener('mousemove', onDocumentMouseMove)\n    }\n  }, [scrollerElem, anchorElem, editor, hoveredElement])\n\n  useEffect(() => {\n    if (menuRef.current && hoveredElement?.node) {\n      setHandlePosition(\n        hoveredElement?.elem,\n        menuRef.current,\n        anchorElem,\n        blockHandleHorizontalOffset,\n      )\n    }\n  }, [anchorElem, hoveredElement, blockHandleHorizontalOffset])\n\n  const handleAddClick = useCallback(\n    (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n      let hoveredElementToUse = hoveredElement\n      if (!hoveredElementToUse?.node) {\n        return\n      }\n\n      // 1. Update hoveredElement.node to a new paragraph node if the hoveredElement.node is not a paragraph node\n      editor.update(() => {\n        // Check if blockNode is an empty text node\n        let isEmptyParagraph = true\n        if (\n          hoveredElementToUse?.node.getType() !== 'paragraph' ||\n          hoveredElementToUse.node.getTextContent() !== ''\n        ) {\n          isEmptyParagraph = false\n        }\n\n        if (!isEmptyParagraph) {\n          const newParagraph = $createParagraphNode()\n          hoveredElementToUse?.node.insertAfter(newParagraph)\n\n          setTimeout(() => {\n            hoveredElementToUse = {\n              elem: editor.getElementByKey(newParagraph.getKey())!,\n              node: newParagraph,\n            }\n            setHoveredElement(hoveredElementToUse)\n          }, 0)\n        }\n      })\n\n      // 2. Focus on the new paragraph node\n      setTimeout(() => {\n        editor.update(() => {\n          editor.focus()\n\n          if (\n            hoveredElementToUse?.node &&\n            'select' in hoveredElementToUse.node &&\n            typeof hoveredElementToUse.node.select === 'function'\n          ) {\n            hoveredElementToUse.node.select()\n          }\n        })\n      }, 1)\n\n      // Make sure this is called AFTER the focusing has been processed by the browser\n      // Otherwise, this won't work\n      setTimeout(() => {\n        editor.dispatchCommand(ENABLE_SLASH_MENU_COMMAND, {\n          node: hoveredElementToUse?.node as ParagraphNode,\n        })\n      }, 2)\n\n      event.stopPropagation()\n      event.preventDefault()\n    },\n    [editor, hoveredElement],\n  )\n\n  return createPortal(\n    <React.Fragment>\n      <button\n        aria-label=\"Add block\"\n        className=\"icon add-block-menu\"\n        onClick={(event) => {\n          handleAddClick(event)\n        }}\n        ref={menuRef}\n        type=\"button\"\n      >\n        <div className={isEditable ? 'icon' : ''} />\n      </button>\n    </React.Fragment>,\n    anchorElem,\n  )\n}\n\nexport function AddBlockHandlePlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  return useAddBlockHandle(editor, anchorElem, editor._editable)\n}\n", "'use client'\n/**\n * Calculate distance between scrollerElem and target if target is not in scrollerElem\n */\nexport const calculateDistanceFromScrollerElem = (\n  scrollerElem: HTMLElement | null,\n  pageX: number,\n  pageY: number,\n  target: HTMLElement,\n  horizontalBuffer: number = 50,\n  verticalBuffer: number = 25,\n): number => {\n  let distanceFromScrollerElem = 0\n  if (scrollerElem && !scrollerElem.contains(target)) {\n    const { bottom, left, right, top } = scrollerElem.getBoundingClientRect()\n\n    const adjustedTop = top + window.scrollY\n    const adjustedBottom = bottom + window.scrollY\n\n    if (\n      pageY < adjustedTop - verticalBuffer ||\n      pageY > adjustedBottom + verticalBuffer ||\n      pageX < left - horizontalBuffer ||\n      pageX > right + horizontalBuffer\n    ) {\n      return -1\n    }\n\n    // This is used to allow the _draggableBlockElem to be found when the mouse is in the\n    // buffer zone around the scrollerElem.\n    if (pageX < left || pageX > right) {\n      distanceFromScrollerElem = pageX < left ? pageX - left : pageX - right\n    }\n  }\n  return distanceFromScrollerElem\n}\n", "'use client'\nimport type { LexicalEditor, LexicalNode } from 'lexical'\n\nimport { $getNodeByKey } from 'lexical'\n\nimport { Point } from '../../../utils/point.js'\nimport { Rect } from '../../../utils/rect.js'\nimport { getBoundingClientRectWithoutTransform } from '../DraggableBlockPlugin/getBoundingRectWithoutTransform.js'\nimport { getCollapsedMargins } from '../utils/getCollapsedMargins.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\n\n// Directions\nconst Downward = 1\nconst Upward = -1\nconst Indeterminate = 0\n\ntype Props = {\n  anchorElem: HTMLElement\n  cache_threshold?: number\n  editor: LexicalEditor\n  /** fuzzy makes the search not exact. If no exact match found, find the closes node instead of returning null */\n  fuzzy?: boolean\n  horizontalOffset?: number\n  point: Point\n  /**\n   * By default, empty paragraphs are not returned. Set this to true to return empty paragraphs. @default false\n   */\n  returnEmptyParagraphs?: boolean\n  /**\n   * The index to start searching from. It can be a considerable performance optimization to start searching from the index of the\n   * previously found node, as the node is likely to be close to the next node.\n   */\n  startIndex?: number\n  useEdgeAsDefault?: boolean\n  verbose?: boolean\n}\n\ntype Output = {\n  blockElem: HTMLElement | null\n  blockNode: LexicalNode | null\n  foundAtIndex: number\n  isFoundNodeEmptyParagraph: boolean\n}\n\nconst cache = {\n  props: null as null | Props,\n  result: null as null | Output,\n}\n\nfunction isPointClose(previous: Point, current: Point, threshold: number = 20): boolean {\n  const dx = previous.x - current.x\n  const dy = previous.y - current.y\n  return dx * dx + dy * dy <= threshold * threshold\n}\n\nexport function getNodeCloseToPoint(props: Props): Output {\n  const {\n    anchorElem,\n    cache_threshold = 20,\n    editor,\n    fuzzy = false,\n    horizontalOffset = 0,\n    point: { x, y },\n    startIndex = 0,\n    useEdgeAsDefault = false,\n  } = props\n\n  // Use cache\n  if (\n    cache_threshold > 0 &&\n    cache.props &&\n    cache.result &&\n    cache.props.fuzzy === props.fuzzy &&\n    cache.props.horizontalOffset === props.horizontalOffset &&\n    cache.props.useEdgeAsDefault === props.useEdgeAsDefault &&\n    isPointClose(cache.props.point, props.point, cache_threshold)\n  ) {\n    return cache.result\n  }\n\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n  const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n  const closestBlockElem: {\n    blockElem: HTMLElement | null\n    blockNode: LexicalNode | null\n    distance: number\n    foundAtIndex: number\n    isFoundNodeEmptyParagraph: boolean\n  } = {\n    blockElem: null,\n    blockNode: null,\n    distance: Infinity,\n    foundAtIndex: -1,\n    isFoundNodeEmptyParagraph: false,\n  }\n\n  // Return null if matching block element is the first or last node\n  editor.getEditorState().read(() => {\n    if (useEdgeAsDefault) {\n      const firstNode = editor.getElementByKey(topLevelNodeKeys[0]!)\n      const lastNode = editor.getElementByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1]!)\n\n      if (firstNode && lastNode) {\n        const [firstNodeRect, lastNodeRect] = [\n          getBoundingClientRectWithoutTransform(firstNode),\n          getBoundingClientRectWithoutTransform(lastNode),\n        ]\n\n        if (y < firstNodeRect.top) {\n          closestBlockElem.blockElem = firstNode\n          closestBlockElem.distance = firstNodeRect.top - y\n          closestBlockElem.blockNode = $getNodeByKey(topLevelNodeKeys[0]!)\n          closestBlockElem.foundAtIndex = 0\n        } else if (y > lastNodeRect.bottom) {\n          closestBlockElem.distance = y - lastNodeRect.bottom\n          closestBlockElem.blockNode = $getNodeByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1]!)\n          closestBlockElem.blockElem = lastNode\n          closestBlockElem.foundAtIndex = topLevelNodeKeys.length - 1\n        }\n\n        if (closestBlockElem?.blockElem) {\n          return {\n            blockElem: null,\n            isFoundNodeEmptyParagraph: false,\n          } as Output\n        }\n      }\n    }\n\n    // Find matching block element\n    let index = startIndex\n    let direction = Indeterminate\n\n    while (index >= 0 && index < topLevelNodeKeys.length) {\n      const key = topLevelNodeKeys[index]!\n      const elem = editor.getElementByKey(key)\n      if (elem === null) {\n        break\n      }\n      const point = new Point(x + horizontalOffset, y)\n      //const domRect = Rect.fromDOM(elem)\n      // Do not consider transform of blocks when calculating distance\n      const domRect = Rect.fromDOMRect(getBoundingClientRectWithoutTransform(elem))\n\n      const { marginBottom, marginTop } = getCollapsedMargins(elem)\n\n      const rect = domRect.generateNewRect({\n        bottom: domRect.bottom + marginBottom,\n        left: anchorElementRect.left,\n        right: anchorElementRect.right,\n        top: domRect.top - marginTop,\n      })\n\n      const { distance, isOnBottomSide, isOnTopSide } = rect.distanceFromPoint(point)\n\n      if (distance === 0) {\n        closestBlockElem.blockElem = elem\n        closestBlockElem.blockNode = $getNodeByKey(key)\n        closestBlockElem.foundAtIndex = index\n        closestBlockElem.distance = distance\n\n        // Check if blockNode is an empty text node\n        if (\n          closestBlockElem.blockNode &&\n          closestBlockElem.blockNode.getType() === 'paragraph' &&\n          closestBlockElem.blockNode.getTextContent() === ''\n        ) {\n          if (!fuzzy && !props.returnEmptyParagraphs) {\n            closestBlockElem.blockElem = null\n            closestBlockElem.blockNode = null\n          }\n\n          closestBlockElem.isFoundNodeEmptyParagraph = true\n        }\n        break\n      } else if (fuzzy) {\n        if (distance < closestBlockElem.distance) {\n          closestBlockElem.blockElem = elem\n          closestBlockElem.blockNode = $getNodeByKey(key)\n          closestBlockElem.distance = distance\n          closestBlockElem.foundAtIndex = index\n        }\n      }\n\n      if (direction === Indeterminate) {\n        if (isOnTopSide) {\n          direction = Upward\n        } else if (isOnBottomSide) {\n          direction = Downward\n        } else {\n          // stop search block element\n          direction = Infinity\n        }\n      }\n\n      index += direction\n    }\n  })\n\n  // Store in cache before returning\n  cache.props = props\n  cache.result = {\n    blockElem: closestBlockElem.blockElem,\n    blockNode: closestBlockElem.blockNode,\n    foundAtIndex: closestBlockElem.foundAtIndex,\n    isFoundNodeEmptyParagraph: closestBlockElem.isFoundNodeEmptyParagraph,\n  }\n\n  return {\n    blockElem: closestBlockElem.blockElem,\n    blockNode: closestBlockElem.blockNode,\n    foundAtIndex: closestBlockElem.foundAtIndex,\n    isFoundNodeEmptyParagraph: closestBlockElem.isFoundNodeEmptyParagraph,\n  }\n}\n", "'use client'\nexport function getBoundingClientRectWithoutTransform(elem: HTMLElement): DOMRect {\n  const rect = elem.getBoundingClientRect()\n\n  // Extract the translation value from the transform style\n  const transformValue = getComputedStyle(elem).getPropertyValue('transform')\n  if (!transformValue || transformValue === 'none') {\n    return rect\n  }\n\n  const lastNumberOfTransformValue = transformValue.split(',').pop()\n  rect.y = rect.y - Number(lastNumberOfTransformValue?.replace(')', ''))\n\n  // Return the original bounding rect if no translation is applied\n  return rect\n}\n", "'use client'\nexport function getCollapsedMargins(elem: HTMLElement): {\n  marginBottom: number\n  marginTop: number\n} {\n  const getMargin = (element: Element | null, margin: 'marginBottom' | 'marginTop'): number =>\n    element ? parseFloat(window.getComputedStyle(element)[margin]) : 0\n\n  const { marginBottom, marginTop } = window.getComputedStyle(elem)\n  const prevElemSiblingMarginBottom = getMargin(elem.previousElementSibling, 'marginBottom')\n  const nextElemSiblingMarginTop = getMargin(elem.nextElementSibling, 'marginTop')\n  const collapsedTopMargin = Math.max(parseFloat(marginTop), prevElemSiblingMarginBottom)\n  const collapsedBottomMargin = Math.max(parseFloat(marginBottom), nextElemSiblingMarginTop)\n\n  return { marginBottom: collapsedBottomMargin, marginTop: collapsedTopMargin }\n}\n", "'use client'\nimport type { LexicalEditor } from 'lexical'\n\nimport { $getRoot } from 'lexical'\n\nexport function getTopLevelNodeKeys(editor: LexicalEditor): string[] {\n  return editor.getEditorState().read(() => $getRoot().getChildrenKeys())\n}\n", "'use client'\nexport function isOnHandleElement(element: HTMLElement, handleElementClassName: string): boolean {\n  return !!element.closest(`.${handleElementClassName}`)\n}\n", "'use client'\nconst replacedElements = [\n  'IMG',\n  'INPUT',\n  'TEXTAREA',\n  'SELECT',\n  'BUTTON',\n  'VIDEO',\n  'OBJECT',\n  'EMBED',\n  'IFRAME',\n  'HR',\n]\n\n/**\n * From ChatGPT, only that verified it works for HR elements.\n *\n * HTML Elements can have CSS lineHeight applied to them, but it doesn't always affect the visual layout.\n * This function checks if the line-height property has an effect on the element's layout.\n * @param htmlElem\n */\nexport function doesLineHeightAffectElement(htmlElem: HTMLElement) {\n  if (!htmlElem) {\n    return false\n  }\n\n  // Check for replaced elements, elements that typically don't support line-height adjustments,\n  // and elements without visible content\n\n  if (\n    replacedElements.includes(htmlElem.tagName) ||\n    htmlElem.offsetHeight === 0 ||\n    htmlElem.offsetWidth === 0\n  ) {\n    return false\n  }\n\n  // Check for specific CSS properties that negate line-height's visual effects\n  const style = window.getComputedStyle(htmlElem)\n  if (\n    style.display === 'table-cell' ||\n    style.position === 'absolute' ||\n    style.visibility === 'hidden' ||\n    style.opacity === '0'\n  ) {\n    return false\n  }\n\n  // This is a basic check, and there can be more complex scenarios where line-height doesn't have an effect.\n  return true\n}\n", "'use client'\nimport { doesLineHeightAffectElement } from './doesLineHeightAffectElement.js'\n\nexport function setHandlePosition(\n  targetElem: HTMLElement | null,\n  handleElem: HTMLElement,\n  anchorElem: HTMLElement,\n  leftOffset: number = 0, // SPACE\n) {\n  if (!targetElem) {\n    handleElem.style.opacity = '0'\n    handleElem.style.transform = 'translate(-10000px, -10000px)'\n    return\n  }\n\n  const targetRect = targetElem.getBoundingClientRect()\n  const targetStyle = window.getComputedStyle(targetElem)\n  const floatingElemRect = handleElem.getBoundingClientRect()\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n\n  let top: number\n\n  const isBlockStyle = ['lexical-block', 'lexical-upload', 'lexical-relationship'].some((classes) =>\n    targetElem.firstElementChild?.classList.contains(classes),\n  )\n\n  if (!isBlockStyle) {\n    // No need to let line height affect the re-positioning of the floating element if line height has no\n    // visual effect on the element. Otherwise, the floating element will be positioned incorrectly.\n    const actualLineHeight = doesLineHeightAffectElement(targetElem)\n      ? parseInt(targetStyle.lineHeight, 10)\n      : 0\n\n    top = targetRect.top + (actualLineHeight - floatingElemRect.height) / 2 - anchorElementRect.top\n  } else {\n    top = targetRect.top + 8 - anchorElementRect.top\n  }\n\n  const left = leftOffset\n\n  handleElem.style.opacity = '1'\n  handleElem.style.transform = `translate(${left}px, ${top}px)`\n}\n", "'use client'\nimport type { LexicalEditor } from 'lexical'\nimport type { DragEvent as ReactDragEvent } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { eventFiles } from '@lexical/rich-text'\nimport { $getNearestNodeFromDOMNode, $getNodeByKey, isHTMLElement } from 'lexical'\nimport * as React from 'react'\nimport { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useEditorConfigContext } from '../../../config/client/EditorConfigProvider.js'\nimport { Point } from '../../../utils/point.js'\nimport { calculateDistanceFromScrollerElem } from '../utils/calculateDistanceFromScrollerElem.js'\nimport { getNodeCloseToPoint } from '../utils/getNodeCloseToPoint.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\nimport { isOnHandleElement } from '../utils/isOnHandleElement.js'\nimport { setHandlePosition } from '../utils/setHandlePosition.js'\nimport { getBoundingClientRectWithoutTransform } from './getBoundingRectWithoutTransform.js'\nimport './index.scss'\nimport { setTargetLine } from './setTargetLine.js'\n\nconst DRAGGABLE_BLOCK_MENU_CLASSNAME = 'draggable-block-menu'\nconst DRAG_DATA_FORMAT = 'application/x-lexical-drag-block'\n\nlet prevIndex = Infinity\n\nfunction getCurrentIndex(keysLength: number): number {\n  if (keysLength === 0) {\n    return Infinity\n  }\n  if (prevIndex >= 0 && prevIndex < keysLength) {\n    return prevIndex\n  }\n\n  return Math.floor(keysLength / 2)\n}\n\nfunction setDragImage(dataTransfer: DataTransfer, draggableBlockElem: HTMLElement) {\n  const { transform } = draggableBlockElem.style\n\n  // Remove dragImage borders\n  dataTransfer.setDragImage(draggableBlockElem, 0, 0)\n\n  setTimeout(() => {\n    draggableBlockElem.style.transform = transform\n  })\n}\n\nfunction hideTargetLine(\n  targetLineElem: HTMLElement | null,\n  lastTargetBlockElem: HTMLElement | null,\n) {\n  if (targetLineElem) {\n    targetLineElem.style.opacity = '0'\n  }\n  if (lastTargetBlockElem) {\n    lastTargetBlockElem.style.opacity = ''\n    // Delete marginBottom and marginTop values we set\n    lastTargetBlockElem.style.marginBottom = ''\n    lastTargetBlockElem.style.marginTop = ''\n    //lastTargetBlock.style.border = 'none'\n  }\n}\n\nfunction useDraggableBlockMenu(\n  editor: LexicalEditor,\n  anchorElem: HTMLElement,\n  isEditable: boolean,\n): React.ReactElement {\n  const scrollerElem = anchorElem.parentElement\n\n  const menuRef = useRef<HTMLButtonElement>(null)\n  const targetLineRef = useRef<HTMLDivElement>(null)\n  const debugHighlightRef = useRef<HTMLDivElement>(null)\n  const isDraggingBlockRef = useRef<boolean>(false)\n  const [draggableBlockElem, setDraggableBlockElem] = useState<HTMLElement | null>(null)\n  const [lastTargetBlock, setLastTargetBlock] = useState<{\n    boundingBox?: DOMRect\n    elem: HTMLElement | null\n    isBelow: boolean\n  } | null>(null)\n\n  const { editorConfig } = useEditorConfigContext()\n\n  const blockHandleHorizontalOffset = editorConfig?.admin?.hideGutter ? -44 : -8\n\n  useEffect(() => {\n    /**\n     * Handles positioning of the drag handle\n     */\n    function onDocumentMouseMove(event: MouseEvent) {\n      const target = event.target\n      if (!isHTMLElement(target)) {\n        return\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n      )\n      if (distanceFromScrollerElem === -1) {\n        setDraggableBlockElem(null)\n        return\n      }\n\n      if (isOnHandleElement(target, DRAGGABLE_BLOCK_MENU_CLASSNAME)) {\n        return\n      }\n\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: _draggableBlockElem,\n        foundAtIndex,\n        isFoundNodeEmptyParagraph,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        cache_threshold: 0,\n        editor,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: false,\n        verbose: false,\n      })\n\n      prevIndex = foundAtIndex\n\n      //if (DEBUG && _draggableBlockElem) {\n      //targetBlockElem.style.border = '3px solid red'\n      // highlightElemOriginalPosition(debugHighlightRef, _draggableBlockElem, anchorElem)\n      //}\n\n      if (!_draggableBlockElem && !isFoundNodeEmptyParagraph) {\n        return\n      }\n\n      if (draggableBlockElem !== _draggableBlockElem) {\n        setDraggableBlockElem(_draggableBlockElem)\n      }\n    }\n\n    // Since the draggableBlockElem is outside the actual editor, we need to listen to the document\n    // to be able to detect when the mouse is outside the editor and respect a buffer around\n    // the scrollerElem to avoid the draggableBlockElem disappearing too early.\n    document?.addEventListener('mousemove', onDocumentMouseMove)\n\n    return () => {\n      document?.removeEventListener('mousemove', onDocumentMouseMove)\n    }\n  }, [scrollerElem, anchorElem, editor, draggableBlockElem])\n\n  useEffect(() => {\n    if (menuRef.current) {\n      setHandlePosition(\n        draggableBlockElem,\n        menuRef.current,\n        anchorElem,\n        blockHandleHorizontalOffset,\n      )\n    }\n  }, [anchorElem, draggableBlockElem, blockHandleHorizontalOffset])\n\n  useEffect(() => {\n    function onDragover(event: DragEvent): boolean {\n      if (!isDraggingBlockRef.current) {\n        return false\n      }\n      const [isFileTransfer] = eventFiles(event)\n      if (isFileTransfer) {\n        return false\n      }\n\n      const { pageY, target } = event\n      if (!isHTMLElement(target)) {\n        return false\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n        100,\n        50,\n      )\n\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: targetBlockElem,\n        foundAtIndex,\n        isFoundNodeEmptyParagraph,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        editor,\n        fuzzy: true,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: true,\n        verbose: true,\n      })\n\n      prevIndex = foundAtIndex\n\n      const targetLineElem = targetLineRef.current\n      // targetBlockElem === null shouldn't happen\n      if (targetBlockElem === null || targetLineElem === null) {\n        return false\n      }\n\n      if (draggableBlockElem !== targetBlockElem) {\n        const { isBelow, willStayInSamePosition } = setTargetLine(\n          editorConfig?.admin?.hideGutter ? '0px' : '3rem',\n          blockHandleHorizontalOffset +\n            (editorConfig?.admin?.hideGutter\n              ? (menuRef?.current?.getBoundingClientRect()?.width ?? 0)\n              : -(menuRef?.current?.getBoundingClientRect()?.width ?? 0)),\n          targetLineElem,\n          targetBlockElem,\n          lastTargetBlock!,\n          pageY,\n          anchorElem,\n          event,\n          debugHighlightRef,\n          isFoundNodeEmptyParagraph,\n        )\n\n        // Prevent default event to be able to trigger onDrop events\n        // Calling preventDefault() adds the green plus icon to the cursor,\n        // indicating that the drop is allowed.\n        event.preventDefault()\n\n        if (!willStayInSamePosition) {\n          setLastTargetBlock({\n            boundingBox: targetBlockElem.getBoundingClientRect(),\n            elem: targetBlockElem,\n            isBelow,\n          })\n        }\n      } else if (lastTargetBlock?.elem) {\n        hideTargetLine(targetLineElem, lastTargetBlock.elem)\n        setLastTargetBlock({\n          boundingBox: targetBlockElem.getBoundingClientRect(),\n          elem: targetBlockElem,\n          isBelow: false,\n        })\n      }\n\n      return true\n    }\n\n    function onDrop(event: DragEvent): boolean {\n      if (!isDraggingBlockRef.current) {\n        return false\n      }\n      const [isFileTransfer] = eventFiles(event)\n      if (isFileTransfer) {\n        return false\n      }\n      const { dataTransfer, pageY, target } = event\n      const dragData = dataTransfer?.getData(DRAG_DATA_FORMAT) || ''\n\n      editor.update(() => {\n        const draggedNode = $getNodeByKey(dragData)\n        if (!draggedNode) {\n          return false\n        }\n        if (!isHTMLElement(target)) {\n          return false\n        }\n        const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n          scrollerElem,\n          event.pageX,\n          event.pageY,\n          target,\n          100,\n          50,\n        )\n\n        const { blockElem: targetBlockElem, isFoundNodeEmptyParagraph } = getNodeCloseToPoint({\n          anchorElem,\n          editor,\n          fuzzy: true,\n          horizontalOffset: -distanceFromScrollerElem,\n          point: new Point(event.x, event.y),\n          useEdgeAsDefault: true,\n        })\n\n        if (!targetBlockElem) {\n          return false\n        }\n        const targetNode = $getNearestNodeFromDOMNode(targetBlockElem)\n        if (!targetNode) {\n          return false\n        }\n        if (targetNode === draggedNode) {\n          return true\n        }\n\n        const { height: targetBlockElemHeight, top: targetBlockElemTop } =\n          getBoundingClientRectWithoutTransform(targetBlockElem)\n\n        const mouseY = pageY\n        const isBelow = mouseY >= targetBlockElemTop + targetBlockElemHeight / 2 + window.scrollY\n\n        if (!isFoundNodeEmptyParagraph) {\n          if (isBelow) {\n            // below targetBlockElem\n            targetNode.insertAfter(draggedNode)\n          } else {\n            // above targetBlockElem\n            targetNode.insertBefore(draggedNode)\n          }\n        } else {\n          //\n          targetNode.insertBefore(draggedNode)\n          targetNode.remove()\n        }\n\n        /*\n        if (pageY >= targetBlockElemTop + targetBlockElemHeight / 2) {\n          targetNode.insertAfter(draggedNode)\n        } else {\n          targetNode.insertBefore(draggedNode)\n        }*/\n        if (draggableBlockElem !== null) {\n          setDraggableBlockElem(null)\n        }\n\n        // find all previous elements with lexical-block-highlighter class and remove them\n        const allPrevHighlighters = document.querySelectorAll('.lexical-block-highlighter')\n        allPrevHighlighters.forEach((highlighter) => {\n          highlighter.remove()\n        })\n\n        const newInsertedElem = editor.getElementByKey(draggedNode.getKey())\n        setTimeout(() => {\n          // add new temp html element to newInsertedElem with the same height and width and the class block-selected\n          // to highlight the new inserted element\n          const newInsertedElemRect = newInsertedElem?.getBoundingClientRect()\n          if (!newInsertedElemRect) {\n            return\n          }\n          const highlightElem = document.createElement('div')\n          highlightElem.className = 'lexical-block-highlighter'\n\n          highlightElem.style.backgroundColor = 'var(--theme-elevation-1000'\n          highlightElem.style.transition = 'opacity 0.5s ease-in-out'\n          highlightElem.style.zIndex = '1'\n          highlightElem.style.pointerEvents = 'none'\n          highlightElem.style.boxSizing = 'border-box'\n          highlightElem.style.borderRadius = '4px'\n          highlightElem.style.position = 'absolute'\n          document.body.appendChild(highlightElem)\n\n          highlightElem.style.opacity = '0.1'\n\n          highlightElem.style.height = `${newInsertedElemRect.height + 8}px`\n          highlightElem.style.width = `${newInsertedElemRect.width + 8}px`\n          highlightElem.style.top = `${newInsertedElemRect.top + window.scrollY - 4}px`\n          highlightElem.style.left = `${newInsertedElemRect.left - 4}px`\n\n          setTimeout(() => {\n            highlightElem.style.opacity = '0'\n            setTimeout(() => {\n              highlightElem.remove()\n            }, 500)\n          }, 1000)\n        }, 120)\n      })\n\n      return true\n    }\n\n    // register onDragover event listeners:\n    document.addEventListener('dragover', onDragover)\n    // register onDrop event listeners:\n    document.addEventListener('drop', onDrop)\n\n    return () => {\n      document.removeEventListener('dragover', onDragover)\n      document.removeEventListener('drop', onDrop)\n    }\n  }, [\n    scrollerElem,\n    blockHandleHorizontalOffset,\n    anchorElem,\n    editor,\n    lastTargetBlock,\n    draggableBlockElem,\n    editorConfig?.admin?.hideGutter,\n  ])\n\n  function onDragStart(event: ReactDragEvent<HTMLButtonElement>): void {\n    const dataTransfer = event.dataTransfer\n    if (!dataTransfer || !draggableBlockElem) {\n      return\n    }\n    setDragImage(dataTransfer, draggableBlockElem)\n    let nodeKey = ''\n    editor.update(() => {\n      const node = $getNearestNodeFromDOMNode(draggableBlockElem)\n      if (node) {\n        nodeKey = node.getKey()\n      }\n    })\n    isDraggingBlockRef.current = true\n    dataTransfer.setData(DRAG_DATA_FORMAT, nodeKey)\n  }\n\n  function onDragEnd(): void {\n    isDraggingBlockRef.current = false\n    if (lastTargetBlock?.elem) {\n      hideTargetLine(targetLineRef.current, lastTargetBlock?.elem)\n    }\n  }\n\n  return createPortal(\n    <React.Fragment>\n      <button\n        aria-label=\"Drag to move\"\n        className=\"icon draggable-block-menu\"\n        draggable\n        onDragEnd={onDragEnd}\n        onDragStart={onDragStart}\n        ref={menuRef}\n        type=\"button\"\n      >\n        <div className={isEditable ? 'icon' : ''} />\n      </button>\n      <div className=\"draggable-block-target-line\" ref={targetLineRef} />\n      <div className=\"debug-highlight\" ref={debugHighlightRef} />\n    </React.Fragment>,\n    anchorElem,\n  )\n}\n\nexport function DraggableBlockPlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  return useDraggableBlockMenu(editor, anchorElem, editor._editable)\n}\n", "'use client'\nimport { getCollapsedMargins } from '../utils/getCollapsedMargins.js'\nconst TARGET_LINE_HALF_HEIGHT = 0\nconst TEXT_BOX_HORIZONTAL_PADDING = -24\nconst DEBUG = false\n\nlet animationTimer = 0\n\nexport function setTargetLine(\n  offsetWidth: string,\n  offsetLeft: number,\n  targetLineElem: HTMLElement,\n  targetBlockElem: HTMLElement,\n  lastTargetBlock: {\n    boundingBox?: DOMRect\n    elem: HTMLElement | null\n    isBelow: boolean\n  },\n  mouseY: number,\n  anchorElem: HTMLElement,\n  event: DragEvent,\n  debugHighlightRef: React.RefObject<HTMLDivElement | null>,\n  isFoundNodeEmptyParagraph: boolean = false,\n) {\n  const { height: targetBlockElemHeight, top: targetBlockElemTop } =\n    targetBlockElem.getBoundingClientRect() // used to be getBoundingClientRectWithoutTransform. Not sure what's better, but the normal getBoundingClientRect seems to work fine\n  const { top: anchorTop, width: anchorWidth } = anchorElem.getBoundingClientRect()\n\n  const { marginBottom, marginTop } = getCollapsedMargins(targetBlockElem)\n  let lineTop = targetBlockElemTop\n\n  const isBelow = mouseY >= targetBlockElemTop + targetBlockElemHeight / 2 + window.scrollY\n\n  let willStayInSamePosition = false\n\n  /**\n   * Do not run any transform or changes if the actual new line position would be the same (even if it's now inserted BEFORE rather than AFTER - position would still be the same)\n   * This prevents unnecessary flickering.\n   *\n   * We still need to let it run even if the position (IGNORING the transform) would not change, as the transform animation is not finished yet. This is what animationTimer does. Otherwise, the positioning will be inaccurate\n   */\n  if (lastTargetBlock?.elem) {\n    if (targetBlockElem !== lastTargetBlock?.elem) {\n      if (\n        isBelow &&\n        lastTargetBlock?.elem &&\n        lastTargetBlock?.elem === targetBlockElem.nextElementSibling\n      ) {\n        animationTimer++\n\n        if (animationTimer < 200) {\n          willStayInSamePosition = true\n        }\n      } else if (\n        !isBelow &&\n        lastTargetBlock?.elem &&\n        lastTargetBlock?.elem === targetBlockElem.previousElementSibling\n      ) {\n        animationTimer++\n        if (animationTimer < 200) {\n          willStayInSamePosition = true\n        }\n      }\n    } else {\n      animationTimer++\n\n      const lastBoundingBoxPosition = lastTargetBlock?.boundingBox?.y\n      const currentBoundingBoxPosition = targetBlockElem.getBoundingClientRect().y\n\n      if (\n        (isBelow === lastTargetBlock?.isBelow &&\n          lastBoundingBoxPosition === currentBoundingBoxPosition) ||\n        animationTimer < 200\n      ) {\n        willStayInSamePosition = false\n      }\n    }\n  }\n  if (willStayInSamePosition) {\n    return {\n      isBelow,\n      willStayInSamePosition,\n    }\n  }\n\n  /**\n   * Paragraphs need no isBelow/above handling,\n   */\n  if (!isFoundNodeEmptyParagraph) {\n    //if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      // below targetBlockElem\n      lineTop += targetBlockElemHeight + marginBottom / 2\n    } else {\n      // above targetBlockElem\n      lineTop -= marginTop / 2\n    }\n  } else {\n    lineTop += targetBlockElemHeight / 2\n  }\n\n  let targetElemTranslate2 = 0\n\n  if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      targetElemTranslate2 = -TARGET_LINE_HALF_HEIGHT\n    } else {\n      targetElemTranslate2 = TARGET_LINE_HALF_HEIGHT\n    }\n  }\n\n  const top = lineTop - anchorTop + targetElemTranslate2\n\n  const left = TEXT_BOX_HORIZONTAL_PADDING - offsetLeft\n\n  targetLineElem.style.width = `calc(${anchorWidth}px - ${offsetWidth})`\n  targetLineElem.style.opacity = '.8'\n\n  // if (DEBUG) {\n  //   //targetBlockElem.style.border = '3px solid red'\n  //   highlightElemOriginalPosition(debugHighlightRef, targetBlockElem, anchorElem)\n  // }\n\n  targetLineElem.style.transform = `translate(${left}px, calc(${top}px - ${'2px'}))`\n\n  /**\n   * Properly reset previous targetBlockElem styles\n   */\n  if (lastTargetBlock?.elem) {\n    lastTargetBlock.elem.style.opacity = ''\n\n    if (lastTargetBlock?.elem === targetBlockElem) {\n      if (isBelow) {\n        lastTargetBlock.elem.style.marginTop = ''\n      } else {\n        lastTargetBlock.elem.style.marginBottom = ''\n      }\n    } else {\n      lastTargetBlock.elem.style.marginBottom = ''\n      lastTargetBlock.elem.style.marginTop = ''\n    }\n  }\n\n  animationTimer = 0\n  return {\n    isBelow,\n    willStayInSamePosition,\n  }\n}\n", "/* eslint-disable jsx-a11y/click-events-have-key-events */\n'use client'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $createParagraphNode, $getRoot } from 'lexical'\nimport React from 'react'\n\nimport './index.scss'\nimport { useEditorConfigContext } from '../../config/client/EditorConfigProvider.js'\nconst baseClass = 'insert-paragraph-at-end'\n\nexport const InsertParagraphAtEndPlugin: React.FC = () => {\n  const [editor] = useLexicalComposerContext()\n  const { editorConfig } = useEditorConfigContext()\n\n  if (editorConfig?.admin?.hideInsertParagraphAtEnd) {\n    return null\n  }\n\n  const onClick = () => {\n    editor.update(() => {\n      const paragraphNode = $createParagraphNode()\n      $getRoot().append(paragraphNode)\n      paragraphNode.select()\n    })\n  }\n\n  return (\n    // TODO: convert to button\n    <div\n      aria-label=\"Insert Paragraph\"\n      className={baseClass}\n      onClick={onClick}\n      role=\"button\"\n      tabIndex={0}\n    >\n      <div className={`${baseClass}-inside`}>\n        <span>+</span>\n      </div>\n    </div>\n  )\n}\n", "'use client'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport * as React from 'react'\n\nimport { registerMarkdownShortcuts } from '../../../packages/@lexical/markdown/MarkdownShortcuts.js'\nimport { useEditorConfigContext } from '../../config/client/EditorConfigProvider.js'\n\nexport const MarkdownShortcutPlugin: React.FC = () => {\n  const { editorConfig } = useEditorConfigContext()\n  const [editor] = useLexicalComposerContext()\n\n  React.useEffect(() => {\n    return registerMarkdownShortcuts(editor, editorConfig.features.markdownTransformers ?? [])\n  }, [editor, editorConfig.features.markdownTransformers])\n\n  return null\n}\n", "import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $getSelection, $isRangeSelection, RootNode } from 'lexical'\nimport { useEffect } from 'react'\n\n/**\n * By default, Lexical throws an error if the selection ends in deleted nodes.\n * This is very aggressive considering there are reasons why this can happen\n * outside of Payload's control (custom features or conflicting features, for example).\n * In the case of selections on nonexistent nodes, this plugin moves the selection to\n * the end of the editor and displays a warning instead of an error.\n */\nexport function NormalizeSelectionPlugin() {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerNodeTransform(RootNode, (root) => {\n      const selection = $getSelection()\n      if ($isRangeSelection(selection)) {\n        const anchorNode = selection.anchor.getNode()\n        const focusNode = selection.focus.getNode()\n        if (!anchorNode.isAttached() || !focusNode.isAttached()) {\n          root.selectEnd()\n          // eslint-disable-next-line no-console\n          console.warn(\n            'updateEditor: selection has been moved to the end of the editor because the previously selected nodes have been removed and ' +\n              \"selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.\",\n          )\n        }\n      }\n      return false\n    })\n  }, [editor])\n\n  return null\n}\n", "import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $getSelection, COMMAND_PRIORITY_LOW, SELECT_ALL_COMMAND } from 'lexical'\nimport { useEffect } from 'react'\n\n/**\n * Allows to select inputs with `ctrl+a` or `cmd+a`.\n * Required because Lexical preventDefault the event.\n * see: https://github.com/payloadcms/payload/issues/6871\n */\nexport function SelectAllPlugin() {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerCommand(\n      SELECT_ALL_COMMAND,\n      () => {\n        const selection = $getSelection()\n        if (selection) {\n          return false\n        }\n        const activeElement = document.activeElement\n        if (activeElement instanceof HTMLInputElement) {\n          activeElement.select()\n        }\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n  }, [editor])\n\n  return null\n}\n", "'use client'\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { useTranslation } from '@payloadcms/ui'\nimport { useCallback, useMemo, useState } from 'react'\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\n\nimport type {\n  SlashMenuGroup,\n  SlashMenuGroupInternal,\n  SlashMenuItemInternal,\n  SlashMenuItem as SlashMenuItemType,\n} from './LexicalTypeaheadMenuPlugin/types.js'\n\nimport { useEditorConfigContext } from '../../config/client/EditorConfigProvider.js'\nimport './index.scss'\nimport { LexicalTypeaheadMenuPlugin } from './LexicalTypeaheadMenuPlugin/index.js'\nimport { useMenuTriggerMatch } from './useMenuTriggerMatch.js'\n\nconst baseClass = 'slash-menu-popup'\n\nfunction SlashMenuItem({\n  isSelected,\n  item,\n  onClick,\n  onMouseEnter,\n  ref,\n}: {\n  index: number\n  isSelected: boolean\n  item: SlashMenuItemInternal\n  onClick: () => void\n  onMouseEnter: () => void\n  ref?: React.Ref<HTMLButtonElement>\n}) {\n  const {\n    fieldProps: { featureClientSchemaMap, schemaPath },\n  } = useEditorConfigContext()\n\n  const { i18n } = useTranslation<{}, string>()\n\n  let className = `${baseClass}__item ${baseClass}__item-${item.key}`\n  if (isSelected) {\n    className += ` ${baseClass}__item--selected`\n  }\n\n  let title = item.key\n  if (item.label) {\n    title =\n      typeof item.label === 'function'\n        ? item.label({ featureClientSchemaMap, i18n, schemaPath })\n        : item.label\n  }\n  // Crop title to max. 25 characters\n  if (title.length > 25) {\n    title = title.substring(0, 25) + '...'\n  }\n\n  return (\n    <button\n      aria-selected={isSelected}\n      className={className}\n      id={baseClass + '__item-' + item.key}\n      key={item.key}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      ref={ref}\n      role=\"option\"\n      tabIndex={-1}\n      type=\"button\"\n    >\n      {item?.Icon && <item.Icon />}\n\n      <span className={`${baseClass}__item-text`}>{title}</span>\n    </button>\n  )\n}\n\nexport function SlashMenuPlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  const [queryString, setQueryString] = useState<null | string>(null)\n  const { editorConfig } = useEditorConfigContext()\n  const { i18n } = useTranslation<{}, string>()\n  const {\n    fieldProps: { featureClientSchemaMap, schemaPath },\n  } = useEditorConfigContext()\n\n  const checkForTriggerMatch = useMenuTriggerMatch('/', {\n    minLength: 0,\n  })\n\n  const getDynamicItems = useCallback(() => {\n    let groupWithItems: Array<SlashMenuGroup> = []\n\n    for (const dynamicItem of editorConfig.features.slashMenu.dynamicGroups) {\n      if (queryString) {\n        const dynamicGroupWithItems = dynamicItem({\n          editor,\n          queryString,\n        })\n        groupWithItems = groupWithItems.concat(dynamicGroupWithItems)\n      }\n    }\n\n    return groupWithItems\n  }, [editor, queryString, editorConfig?.features])\n\n  const groups: SlashMenuGroup[] = useMemo(() => {\n    let groupsWithItems: SlashMenuGroup[] = []\n    for (const groupWithItem of editorConfig?.features.slashMenu.groups ?? []) {\n      groupsWithItems.push(groupWithItem)\n    }\n\n    if (queryString) {\n      // Filter current groups first\n      // @ts-expect-error - TODO: fix this\n      groupsWithItems = groupsWithItems.map((group) => {\n        const filteredItems = group.items.filter((item) => {\n          let itemTitle = item.key\n          if (item.label) {\n            itemTitle =\n              typeof item.label === 'function'\n                ? item.label({ featureClientSchemaMap, i18n, schemaPath })\n                : item.label\n          }\n\n          if (new RegExp(queryString, 'gi').exec(itemTitle)) {\n            return true\n          }\n          if (item.keywords != null) {\n            return item.keywords.some((keyword) => new RegExp(queryString, 'gi').exec(keyword))\n          }\n          return false\n        })\n        if (filteredItems.length) {\n          return {\n            ...group,\n            items: filteredItems,\n          }\n        }\n        return null\n      })\n\n      groupsWithItems = groupsWithItems.filter((group) => group != null)\n\n      // Now add dynamic groups\n      const dynamicItemGroups = getDynamicItems()\n\n      // merge dynamic items into groups\n      for (const dynamicGroup of dynamicItemGroups) {\n        // 1. find the group with the same name or create new one\n        let group = groupsWithItems.find((group) => group.key === dynamicGroup.key)\n        if (!group) {\n          group = {\n            ...dynamicGroup,\n            items: [],\n          }\n        } else {\n          groupsWithItems = groupsWithItems.filter((group) => group.key !== dynamicGroup.key)\n        }\n\n        // 2. Add items to group items array and add to sanitized.slashMenu.groupsWithItems\n        if (group?.items?.length) {\n          group.items = group.items.concat(group.items)\n        }\n        groupsWithItems.push(group)\n      }\n    }\n\n    return groupsWithItems\n  }, [\n    queryString,\n    editorConfig?.features.slashMenu.groups,\n    getDynamicItems,\n    featureClientSchemaMap,\n    i18n,\n    schemaPath,\n  ])\n\n  return (\n    <LexicalTypeaheadMenuPlugin\n      anchorElem={anchorElem}\n      groups={groups as SlashMenuGroupInternal[]}\n      menuRenderFn={(\n        anchorElementRef,\n        { selectedItemKey, selectItemAndCleanUp, setSelectedItemKey },\n      ) =>\n        anchorElementRef.current && groups.length\n          ? ReactDOM.createPortal(\n              <div className={baseClass}>\n                {groups.map((group) => {\n                  let groupTitle = group.key\n                  if (group.label && featureClientSchemaMap) {\n                    groupTitle =\n                      typeof group.label === 'function'\n                        ? group.label({ featureClientSchemaMap, i18n, schemaPath })\n                        : group.label\n                  }\n\n                  return (\n                    <div\n                      className={`${baseClass}__group ${baseClass}__group-${group.key}`}\n                      key={group.key}\n                    >\n                      <div className={`${baseClass}__group-title`}>{groupTitle}</div>\n                      {group.items.map((item, oi: number) => (\n                        <SlashMenuItem\n                          index={oi}\n                          isSelected={selectedItemKey === item.key}\n                          item={item as SlashMenuItemInternal}\n                          key={item.key}\n                          onClick={() => {\n                            setSelectedItemKey(item.key)\n                            selectItemAndCleanUp(item)\n                          }}\n                          onMouseEnter={() => {\n                            setSelectedItemKey(item.key)\n                          }}\n                          ref={(el) => {\n                            ;(item as SlashMenuItemInternal).ref = { current: el }\n                          }}\n                        />\n                      ))}\n                    </div>\n                  )\n                })}\n              </div>,\n              anchorElementRef.current,\n            )\n          : null\n      }\n      onQueryChange={setQueryString}\n      triggerFn={checkForTriggerMatch}\n    />\n  )\n}\n", "'use client'\nimport type { LexicalEditor } from 'lexical'\n\nimport { useCallback } from 'react'\n\nimport { PUNCTUATION } from './LexicalTypeaheadMenuPlugin/index.js'\n\nexport type TriggerFn = ({\n  editor,\n  query,\n}: {\n  editor: LexicalEditor\n  /** The query string is the POTENTIAL trigger AND the text after the trigger text. */\n  query: string\n}) => MenuTextMatch | null\n\nexport type MenuTextMatch = {\n  leadOffset: number\n  matchingString: string\n  replaceableString: string\n}\n\n/**\n * Returns a function which checks if the trigger (e.g. '/') is present in the query and, if so, returns the matching string (text after the trigger)\n */\nexport function useMenuTriggerMatch(\n  /**\n   * Text which triggers the menu. Everything after this text will be used as the query.\n   */\n  trigger: string,\n  { maxLength = 75, minLength = 1 }: { maxLength?: number; minLength?: number },\n): TriggerFn {\n  return useCallback(\n    ({ query }) => {\n      const validChars = '[^' + trigger + PUNCTUATION + '\\\\s]'\n      const TypeaheadTriggerRegex = new RegExp(\n        '(^|\\\\s|\\\\()(' +\n          '[' +\n          trigger +\n          ']' +\n          '((?:' +\n          validChars +\n          '){0,' +\n          maxLength +\n          '})' +\n          ')$',\n      )\n      const match = TypeaheadTriggerRegex.exec(query)\n      if (match !== null) {\n        const maybeLeadingWhitespace = match[1]!\n\n        /**\n         * matchingString is only the text AFTER the trigger text. (So everything after the /)\n         */\n        const matchingString = match[3]!\n\n        if (matchingString.length >= minLength) {\n          return {\n            leadOffset: match.index + maybeLeadingWhitespace.length,\n            matchingString,\n            replaceableString: match[2]!, // replaceableString is the trigger text + the matching string\n          }\n        }\n      }\n      return null\n    },\n    [maxLength, minLength, trigger],\n  )\n}\n", "'use client'\nimport type { TextFormatType } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { TEXT_TYPE_TO_FORMAT, TextNode } from 'lexical'\nimport { useEffect } from 'react'\n\nimport type { SanitizedClientFeatures } from '../../../features/typesClient.js'\n\nexport function TextPlugin({ features }: { features: SanitizedClientFeatures }) {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    const disabledFormats = getDisabledFormats(features.enabledFormats)\n    if (disabledFormats.length === 0) {\n      return\n    }\n    // Ideally override the TextNode with our own TextNode (changing its setFormat or toggleFormat methods),\n    // would be more performant. If we find a noticeable perf regression we can switch to that option.\n    // Overriding the FORMAT_TEXT_COMMAND and PASTE_COMMAND commands is not an option I considered because\n    // there might be other forms of mutation that we might not be considering. For example:\n    // browser extensions or Payload/Lexical plugins that have their own commands.\n    return editor.registerNodeTransform(TextNode, (textNode) => {\n      disabledFormats.forEach((disabledFormat) => {\n        if (textNode.hasFormat(disabledFormat)) {\n          textNode.toggleFormat(disabledFormat)\n        }\n      })\n    })\n  }, [editor, features])\n\n  return null\n}\n\nfunction getDisabledFormats(enabledFormats: TextFormatType[]): TextFormatType[] {\n  const allFormats = Object.keys(TEXT_TYPE_TO_FORMAT) as TextFormatType[]\n  const enabledSet = new Set(enabledFormats)\n\n  return allFormats.filter((format) => !enabledSet.has(format))\n}\n", "'use client'\nimport type { JSX } from 'react'\n\nimport { ContentEditable } from '@lexical/react/LexicalContentEditable.js'\nimport { useTranslation } from '@payloadcms/ui'\nimport * as React from 'react'\n\nimport './ContentEditable.scss'\nimport type { SanitizedClientEditorConfig } from '../config/types.js'\n\nexport function LexicalContentEditable({\n  className,\n  editorConfig,\n}: {\n  className?: string\n  editorConfig: SanitizedClientEditorConfig\n}): JSX.Element {\n  const { t } = useTranslation<{}, string>()\n\n  return (\n    <ContentEditable\n      aria-placeholder={t('lexical:general:placeholder')}\n      className={className ?? 'ContentEditable__root'}\n      placeholder={\n        <p className=\"editor-placeholder\">\n          {editorConfig?.admin?.placeholder ?? t('lexical:general:placeholder')}\n        </p>\n      }\n    />\n  )\n}\n"],
  "mappings": "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",
  "names": ["FieldDescription", "FieldError", "FieldLabel", "RenderCustomComponent", "useEditDepth", "useEffectEvent", "useField", "mergeFieldStyles", "dequal", "React", "useCallback", "useEffect", "useMemo", "useState", "ErrorBoundary", "LexicalComposer", "useEditDepth", "React", "useMemo", "c", "_c", "useLexicalComposerContext", "LexicalErrorBoundary", "HistoryPlugin", "OnChangePlugin", "RichTextPlugin", "useLexicalEditable", "BLUR_COMMAND", "COMMAND_PRIORITY_LOW", "FOCUS_COMMAND", "React", "useEffect", "useState", "EditorPlugin", "anchorElem", "clientProps", "plugin", "position", "Component", "_jsx", "c", "_c", "copyToClipboard", "useLexicalComposerContext", "objectKlassEquals", "ObjectID", "COMMAND_PRIORITY_LOW", "COPY_COMMAND", "useEffect", "ClipboardPlugin", "$", "editor", "t0", "t1", "registerCommand", "event", "ClipboardEvent", "then", "clipboardData", "Error", "lexicalStringified", "getData", "lexical", "JSON", "parse", "changeIds", "node", "fields", "id", "default", "toHexString", "children", "child", "node_0", "nodes", "stringified", "stringify", "setData", "catch", "error", "c", "_c", "useLexicalComposerContext", "$findMatchingParent", "mergeRegister", "$createNodeSelection", "$getEditor", "$getNearestNodeFromDOMNode", "$getSelection", "$isDecoratorNode", "$isElementNode", "$isLineBreakNode", "$isNodeSelection", "$isRangeSelection", "$isRootOrShadowRoot", "$isTextNode", "$setSelection", "CLICK_COMMAND", "COMMAND_PRIORITY_LOW", "KEY_ARROW_DOWN_COMMAND", "KEY_ARROW_UP_COMMAND", "KEY_BACKSPACE_COMMAND", "KEY_DELETE_COMMAND", "SELECTION_CHANGE_COMMAND", "useEffect", "DecoratorPlugin", "$", "editor", "$onDelete", "_temp2", "t0", "t1", "registerCommand", "_temp3", "_temp4", "_temp6", "_temp8", "event_2", "selection_1", "selection", "event", "preventDefault", "nextSibling", "getNodes", "getNextSibling", "element_0", "getElementByKey", "getKey", "element", "$selectDecorator", "node", "firstDescendant", "getFirstDescendant", "INTERNAL_$isBlock", "selectEnd", "lastNode", "isBackward", "anchor", "focus", "getNode", "lastSelectedBlock", "_temp7", "nextBlock", "findLaterSiblingBlock", "nextBlockElement", "node_1", "event_1", "selection_0", "prevSibling", "getPreviousSibling", "lastDescendant", "getLastDescendant", "selectStart", "firstNode", "firstSelectedBlock", "_temp5", "prevBlock", "findFirstSiblingBlock", "prevBlockElement", "node_0", "decorator_0", "$getSelectedDecorator", "document", "querySelector", "classList", "remove", "decorator", "add", "event_0", "$getDecoratorByMouseEvent", "target", "HTMLElement", "isContentEditable", "closest", "forEach", "_temp", "undefined", "nodes", "length", "scrollIntoView", "behavior", "block", "isInline", "firstChild", "getFirstChild", "isLeafElement", "canBeEmpty", "current", "useLexicalComposerContext", "$createParagraphNode", "isHTMLElement", "React", "useCallback", "useEffect", "useRef", "useState", "createPortal", "calculateDistanceFromScrollerElem", "scrollerElem", "pageX", "pageY", "target", "horizontalBuffer", "verticalBuffer", "distanceFromScrollerElem", "contains", "bottom", "left", "right", "top", "getBoundingClientRect", "adjustedTop", "window", "scrollY", "adjustedBottom", "$getNodeByKey", "getBoundingClientRectWithoutTransform", "elem", "rect", "getBoundingClientRect", "transformValue", "getComputedStyle", "getPropertyValue", "lastNumberOfTransformValue", "split", "pop", "y", "Number", "replace", "getCollapsedMargins", "elem", "getMargin", "element", "margin", "parseFloat", "window", "getComputedStyle", "marginBottom", "marginTop", "prevElemSiblingMarginBottom", "previousElementSibling", "nextElemSiblingMarginTop", "nextElementSibling", "collapsedTopMargin", "Math", "max", "$getRoot", "getTopLevelNodeKeys", "editor", "getEditorState", "read", "getChildrenKeys", "Downward", "Upward", "Indeterminate", "cache", "props", "result", "isPointClose", "previous", "current", "threshold", "dx", "x", "dy", "y", "getNodeCloseToPoint", "anchorElem", "cache_threshold", "editor", "fuzzy", "horizontalOffset", "point", "startIndex", "useEdgeAsDefault", "anchorElementRect", "getBoundingClientRect", "topLevelNodeKeys", "getTopLevelNodeKeys", "closestBlockElem", "blockElem", "blockNode", "distance", "Infinity", "foundAtIndex", "isFoundNodeEmptyParagraph", "getEditorState", "read", "firstNode", "getElementByKey", "lastNode", "length", "firstNodeRect", "lastNodeRect", "getBoundingClientRectWithoutTransform", "top", "$getNodeByKey", "bottom", "index", "direction", "key", "elem", "Point", "domRect", "Rect", "fromDOMRect", "marginBottom", "marginTop", "getCollapsedMargins", "rect", "generateNewRect", "left", "right", "isOnBottomSide", "isOnTopSide", "distanceFromPoint", "getType", "getTextContent", "returnEmptyParagraphs", "isOnHandleElement", "element", "handleElementClassName", "closest", "replacedElements", "doesLineHeightAffectElement", "htmlElem", "includes", "tagName", "offsetHeight", "offsetWidth", "style", "window", "getComputedStyle", "display", "position", "visibility", "opacity", "setHandlePosition", "targetElem", "handleElem", "anchorElem", "leftOffset", "style", "opacity", "transform", "targetRect", "getBoundingClientRect", "targetStyle", "window", "getComputedStyle", "floatingElemRect", "anchorElementRect", "top", "some", "classes", "firstElementChild", "classList", "contains", "actualLineHeight", "doesLineHeightAffectElement", "parseInt", "lineHeight", "height", "left", "ADD_BLOCK_MENU_CLASSNAME", "prevIndex", "Infinity", "getCurrentIndex", "keysLength", "Math", "floor", "useAddBlockHandle", "editor", "anchorElem", "isEditable", "scrollerElem", "parentElement", "editorConfig", "useEditorConfigContext", "blockHandleHorizontalOffset", "admin", "hideGutter", "menuRef", "useRef", "hoveredElement", "setHoveredElement", "useState", "useEffect", "onDocumentMouseMove", "event", "target", "isHTMLElement", "distanceFromScrollerElem", "calculateDistanceFromScrollerElem", "pageX", "pageY", "isOnHandleElement", "topLevelNodeKeys", "getTopLevelNodeKeys", "blockElem", "_emptyBlockElem", "blockNode", "foundAtIndex", "getNodeCloseToPoint", "cache_threshold", "horizontalOffset", "point", "Point", "x", "y", "returnEmptyParagraphs", "startIndex", "length", "useEdgeAsDefault", "node", "elem", "document", "addEventListener", "removeEventListener", "current", "setHandlePosition", "handleAddClick", "useCallback", "hoveredElementToUse", "update", "isEmptyParagraph", "getType", "getTextContent", "newParagraph", "$createParagraphNode", "insertAfter", "setTimeout", "getElementByKey", "getKey", "focus", "select", "dispatchCommand", "ENABLE_SLASH_MENU_COMMAND", "stopPropagation", "preventDefault", "createPortal", "_jsx", "Fragment", "className", "onClick", "ref", "type", "AddBlockHandlePlugin", "t0", "t1", "undefined", "body", "useLexicalComposerContext", "_editable", "useLexicalComposerContext", "eventFiles", "$getNearestNodeFromDOMNode", "$getNodeByKey", "isHTMLElement", "React", "useEffect", "useRef", "useState", "createPortal", "TARGET_LINE_HALF_HEIGHT", "TEXT_BOX_HORIZONTAL_PADDING", "animationTimer", "setTargetLine", "offsetWidth", "offsetLeft", "targetLineElem", "targetBlockElem", "lastTargetBlock", "mouseY", "anchorElem", "event", "debugHighlightRef", "isFoundNodeEmptyParagraph", "height", "targetBlockElemHeight", "top", "targetBlockElemTop", "getBoundingClientRect", "anchorTop", "width", "anchorWidth", "marginBottom", "marginTop", "getCollapsedMargins", "lineTop", "isBelow", "window", "scrollY", "willStayInSamePosition", "elem", "nextElementSibling", "previousElementSibling", "lastBoundingBoxPosition", "boundingBox", "y", "currentBoundingBoxPosition", "targetElemTranslate2", "TARGET_LINE_HALF_HEIGHT", "left", "TEXT_BOX_HORIZONTAL_PADDING", "style", "opacity", "transform", "DRAGGABLE_BLOCK_MENU_CLASSNAME", "DRAG_DATA_FORMAT", "prevIndex", "Infinity", "getCurrentIndex", "keysLength", "Math", "floor", "setDragImage", "dataTransfer", "draggableBlockElem", "transform", "style", "setTimeout", "hideTargetLine", "targetLineElem", "lastTargetBlockElem", "opacity", "marginBottom", "marginTop", "useDraggableBlockMenu", "editor", "anchorElem", "isEditable", "scrollerElem", "parentElement", "menuRef", "useRef", "targetLineRef", "debugHighlightRef", "isDraggingBlockRef", "setDraggableBlockElem", "useState", "lastTargetBlock", "setLastTargetBlock", "editorConfig", "useEditorConfigContext", "blockHandleHorizontalOffset", "admin", "hideGutter", "useEffect", "onDocumentMouseMove", "event", "target", "isHTMLElement", "distanceFromScrollerElem", "calculateDistanceFromScrollerElem", "pageX", "pageY", "isOnHandleElement", "topLevelNodeKeys", "getTopLevelNodeKeys", "blockElem", "_draggableBlockElem", "foundAtIndex", "isFoundNodeEmptyParagraph", "getNodeCloseToPoint", "cache_threshold", "horizontalOffset", "point", "Point", "x", "y", "startIndex", "length", "useEdgeAsDefault", "verbose", "document", "addEventListener", "removeEventListener", "current", "setHandlePosition", "onDragover", "isFileTransfer", "eventFiles", "targetBlockElem", "fuzzy", "isBelow", "willStayInSamePosition", "setTargetLine", "getBoundingClientRect", "width", "preventDefault", "boundingBox", "elem", "onDrop", "dragData", "getData", "update", "draggedNode", "$getNodeByKey", "targetNode", "$getNearestNodeFromDOMNode", "height", "targetBlockElemHeight", "top", "targetBlockElemTop", "getBoundingClientRectWithoutTransform", "window", "scrollY", "insertBefore", "remove", "insertAfter", "querySelectorAll", "forEach", "highlighter", "newInsertedElem", "getElementByKey", "getKey", "newInsertedElemRect", "highlightElem", "createElement", "className", "backgroundColor", "transition", "zIndex", "pointerEvents", "boxSizing", "borderRadius", "position", "body", "appendChild", "left", "onDragStart", "nodeKey", "node", "setData", "onDragEnd", "createPortal", "_jsxs", "Fragment", "_jsx", "draggable", "ref", "type", "DraggableBlockPlugin", "t0", "t1", "undefined", "useLexicalComposerContext", "_editable", "c", "_c", "useLexicalComposerContext", "$createParagraphNode", "$getRoot", "baseClass", "InsertParagraphAtEndPlugin", "$", "_c", "editor", "useLexicalComposerContext", "editorConfig", "useEditorConfigContext", "admin", "hideInsertParagraphAtEnd", "t0", "_jsx", "className", "onClick", "update", "_temp", "role", "tabIndex", "children", "paragraphNode", "$createParagraphNode", "$getRoot", "append", "select", "c", "_c", "useLexicalComposerContext", "React", "MarkdownShortcutPlugin", "$", "_c", "editorConfig", "useEditorConfigContext", "editor", "useLexicalComposerContext", "t0", "t1", "features", "markdownTransformers", "registerMarkdownShortcuts", "useEffect", "useLexicalComposerContext", "$getSelection", "$isRangeSelection", "RootNode", "useEffect", "NormalizeSelectionPlugin", "editor", "registerNodeTransform", "root", "selection", "anchorNode", "anchor", "getNode", "focusNode", "focus", "isAttached", "selectEnd", "console", "warn", "useLexicalComposerContext", "$getSelection", "COMMAND_PRIORITY_LOW", "SELECT_ALL_COMMAND", "useEffect", "SelectAllPlugin", "editor", "registerCommand", "activeElement", "document", "HTMLInputElement", "select", "useLexicalComposerContext", "useTranslation", "useCallback", "useMemo", "useState", "ReactDOM", "c", "_c", "useMenuTriggerMatch", "trigger", "t0", "$", "_c", "maxLength", "t1", "minLength", "t2", "undefined", "t3", "t4", "query", "validChars", "PUNCTUATION", "match", "RegExp", "exec", "maybeLeadingWhitespace", "matchingString", "length", "leadOffset", "index", "replaceableString", "baseClass", "SlashMenuItem", "isSelected", "item", "onClick", "onMouseEnter", "ref", "fieldProps", "featureClientSchemaMap", "schemaPath", "useEditorConfigContext", "i18n", "useTranslation", "className", "key", "title", "label", "length", "substring", "_jsxs", "id", "role", "tabIndex", "type", "Icon", "_jsx", "SlashMenuPlugin", "anchorElem", "document", "body", "editor", "useLexicalComposerContext", "queryString", "setQueryString", "useState", "editorConfig", "checkForTriggerMatch", "useMenuTriggerMatch", "minLength", "getDynamicItems", "useCallback", "groupWithItems", "dynamicItem", "features", "slashMenu", "dynamicGroups", "dynamicGroupWithItems", "concat", "groups", "useMemo", "groupsWithItems", "groupWithItem", "push", "map", "group", "filteredItems", "items", "filter", "itemTitle", "RegExp", "exec", "keywords", "some", "keyword", "dynamicItemGroups", "dynamicGroup", "find", "LexicalTypeaheadMenuPlugin", "menuRenderFn", "anchorElementRef", "selectedItemKey", "selectItemAndCleanUp", "setSelectedItemKey", "current", "createPortal", "groupTitle", "oi", "index", "el", "onQueryChange", "triggerFn", "c", "_c", "useLexicalComposerContext", "TEXT_TYPE_TO_FORMAT", "TextNode", "useEffect", "TextPlugin", "t0", "$", "features", "editor", "t1", "enabledFormats", "disabledFormats", "getDisabledFormats", "length", "registerNodeTransform", "textNode", "forEach", "disabledFormat", "hasFormat", "toggleFormat", "t2", "allFormats", "Object", "keys", "enabledSet", "Set", "filter", "format", "has", "c", "_c", "ContentEditable", "useTranslation", "LexicalContentEditable", "t0", "$", "className", "editorConfig", "t", "t1", "admin", "placeholder", "_jsx", "children", "LexicalEditor", "props", "$", "_c", "editorConfig", "editorContainerRef", "isSmallWidthViewport", "onChange", "editorConfigContext", "useEditorConfigContext", "editor", "useLexicalComposerContext", "isEditable", "useLexicalEditable", "floatingAnchorElem", "setFloatingAnchorElem", "useState", "t0", "Symbol", "for", "_floatingAnchorElem", "onRef", "t1", "t2", "uuid", "console", "error", "parentEditor", "registerChild", "handleFocus", "focusEditor", "handleBlur", "blurEditor", "unregisterFocus", "registerCommand", "FOCUS_COMMAND", "COMMAND_PRIORITY_LOW", "unregisterBlur", "BLUR_COMMAND", "unregisterChild", "useEffect", "t3", "_jsxs", "Fragment", "children", "features", "plugins", "map", "_temp", "className", "ref", "_temp2", "_jsx", "RichTextPlugin", "contentEditable", "LexicalContentEditable", "NormalizeSelectionPlugin", "InsertParagraphAtEndPlugin", "DecoratorPlugin", "ClipboardPlugin", "TextPlugin", "SelectAllPlugin", "OnChangePlugin", "ignoreSelectionChange", "editorState", "editor_0", "tags", "has", "size", "admin", "hideDraggableBlockElement", "DraggableBlockPlugin", "anchorElem", "hideAddBlockButton", "AddBlockHandlePlugin", "plugin_1", "plugin", "position", "desktopOnly", "EditorPlugin", "clientProps", "key", "SlashMenuPlugin", "HistoryPlugin", "markdownTransformers", "length", "MarkdownShortcutPlugin", "_temp3", "_temp4", "_temp5", "plugin_0", "plugin_2", "plugin_3", "plugin_4", "NestProviders", "children", "providers", "length", "Component", "_jsx", "slice", "LexicalProvider", "props", "composerKey", "editorConfig", "fieldProps", "isSmallWidthViewport", "onChange", "readOnly", "value", "parentContext", "useEditorConfigContext", "editDepth", "useEditDepth", "editorContainerRef", "useRef", "initialConfig", "useMemo", "Error", "JSON", "stringify", "Array", "isArray", "editable", "editorState", "undefined", "namespace", "lexical", "nodes", "getEnabledNodes", "onError", "error", "theme", "LexicalComposer", "EditorConfigProvider", "features", "LexicalEditorComponent", "baseClass", "RichTextComponent", "props", "editorConfig", "field", "admin", "className", "description", "readOnly", "readOnlyFromAdmin", "label", "localized", "required", "path", "pathFromProps", "readOnlyFromTopLevelProps", "validate", "readOnlyFromProps", "editDepth", "useEditDepth", "memoizedValidate", "useCallback", "value", "validationOptions", "customComponents", "AfterInput", "BeforeInput", "Description", "Error", "Label", "disabled", "disabledFromField", "initialValue", "setValue", "showError", "useField", "potentiallyStalePath", "isSmallWidthViewport", "setIsSmallWidthViewport", "useState", "rerenderProviderKey", "setRerenderProviderKey", "prevInitialValueRef", "React", "useRef", "prevValueRef", "useEffect", "updateViewPortWidth", "isNextSmallWidthViewport", "window", "matchMedia", "matches", "addEventListener", "removeEventListener", "classes", "hideGutter", "filter", "Boolean", "join", "pathWithEditDepth", "runDeprioritized", "useRunDeprioritized", "handleChange", "editorState", "updateFieldValue", "newState", "toJSON", "current", "styles", "useMemo", "mergeFieldStyles", "handleInitialValueChange", "useEffectEvent", "dequal", "JSON", "parse", "stringify", "Date", "Object", "is", "_jsxs", "style", "_jsx", "RenderCustomComponent", "CustomComponent", "Fallback", "FieldError", "FieldLabel", "ErrorBoundary", "fallbackRender", "onReset", "LexicalProvider", "composerKey", "fieldProps", "onChange", "FieldDescription", "error", "role", "color", "message", "RichText"]
}
