{"version":3,"file":"initLexicalFeatures.js","names":["getFromImportMap","initLexicalFeatures","args","clientFeatures","resolvedFeatureMapArray","Array","from","sanitizedEditorConfig","resolvedFeatureMap","entries","sort","a","b","order","featureClientSchemaMap","featureClientImportMap","featureKey","resolvedFeature","ClientFeaturePayloadComponent","ClientFeature","clientFeatureProvider","importMap","payload","PayloadComponent","schemaPath","silent","clientFeatureProps","key","clientProps","generateSchemaMap","featureSchemaPath","split","join","entry","clientFieldSchemaMap","startsWith","fields","componentImports","payloadComponent","resolvedComponent"],"sources":["../../src/utilities/initLexicalFeatures.ts"],"sourcesContent":["import type { I18nClient } from '@payloadcms/translations'\n\nimport { type ClientFieldSchemaMap, type FieldSchemaMap, type Payload } from 'payload'\nimport { getFromImportMap } from 'payload/shared'\n\nimport type { FeatureProviderProviderClient } from '../features/typesClient.js'\nimport type { SanitizedServerEditorConfig } from '../lexical/config/types.js'\nimport type { FeatureClientSchemaMap, LexicalRichTextFieldProps } from '../types.js'\ntype Args = {\n  clientFieldSchemaMap: ClientFieldSchemaMap\n  fieldSchemaMap: FieldSchemaMap\n  i18n: I18nClient\n  path: string\n  payload: Payload\n  sanitizedEditorConfig: SanitizedServerEditorConfig\n  schemaPath: string\n}\n\nexport function initLexicalFeatures(args: Args): {\n  clientFeatures: LexicalRichTextFieldProps['clientFeatures']\n  featureClientImportMap: Record<string, any>\n  featureClientSchemaMap: FeatureClientSchemaMap\n} {\n  const clientFeatures: LexicalRichTextFieldProps['clientFeatures'] = {}\n\n  // turn args.resolvedFeatureMap into an array of [key, value] pairs, ordered by value.order, lowest order first:\n  const resolvedFeatureMapArray = Array.from(\n    args.sanitizedEditorConfig.resolvedFeatureMap.entries(),\n  ).sort((a, b) => a[1].order - b[1].order)\n\n  const featureClientSchemaMap: FeatureClientSchemaMap = {}\n\n  /**\n   * All modules added to the import map, keyed by the provided key, if feature.componentImports with type object is used\n   */\n  const featureClientImportMap: Record<string, any> = {}\n\n  for (const [featureKey, resolvedFeature] of resolvedFeatureMapArray) {\n    clientFeatures[featureKey] = {}\n\n    /**\n     * Handle client features\n     */\n    const ClientFeaturePayloadComponent = resolvedFeature.ClientFeature\n\n    if (ClientFeaturePayloadComponent) {\n      const clientFeatureProvider = getFromImportMap<FeatureProviderProviderClient>({\n        importMap: args.payload.importMap,\n        PayloadComponent: ClientFeaturePayloadComponent,\n        schemaPath: 'lexical-clientComponent',\n        silent: true,\n      })\n\n      if (!clientFeatureProvider) {\n        continue\n      }\n\n      const clientFeatureProps = resolvedFeature.clientFeatureProps ?? {}\n      clientFeatureProps.featureKey = resolvedFeature.key\n      clientFeatureProps.order = resolvedFeature.order\n      if (\n        typeof ClientFeaturePayloadComponent === 'object' &&\n        ClientFeaturePayloadComponent.clientProps\n      ) {\n        clientFeatureProps.clientProps = ClientFeaturePayloadComponent.clientProps\n      }\n\n      // As clientFeatureProvider is a client function, we cannot execute it on the server here. Thus, the client will have to execute clientFeatureProvider with its props\n      clientFeatures[featureKey] = { clientFeatureProps, clientFeatureProvider }\n    }\n\n    /**\n     * Handle sub-fields (formstate of those)\n     */\n    // The args.fieldSchemaMap generated before in buildFormState should contain all of lexical features' sub-field schemas\n    // as well, as it already called feature.generateSchemaMap for each feature.\n    // We will check for the existance resolvedFeature.generateSchemaMap to skip unnecessary loops for constructing featureSchemaMap, but we don't run it here\n    if (resolvedFeature.generateSchemaMap) {\n      const featureSchemaPath = [\n        ...args.schemaPath.split('.'),\n        'lexical_internal_feature',\n        featureKey,\n      ].join('.')\n\n      featureClientSchemaMap[featureKey] = {}\n\n      // Like args.fieldSchemaMap, we only want to include the sub-fields of the current feature\n      for (const [key, entry] of args.clientFieldSchemaMap.entries()) {\n        if (key.startsWith(featureSchemaPath)) {\n          featureClientSchemaMap[featureKey][key] = 'fields' in entry ? entry.fields : [entry]\n        }\n      }\n      if (\n        resolvedFeature.componentImports &&\n        typeof resolvedFeature.componentImports === 'object'\n      ) {\n        for (const key in resolvedFeature.componentImports) {\n          const payloadComponent = resolvedFeature.componentImports[key]\n\n          const resolvedComponent = getFromImportMap({\n            importMap: args.payload.importMap,\n            PayloadComponent: payloadComponent,\n            schemaPath: 'lexical-clientComponent',\n            silent: true,\n          })\n\n          featureClientImportMap[`${resolvedFeature.key}.${key}`] = resolvedComponent\n        }\n      }\n    }\n  }\n  return {\n    clientFeatures,\n    featureClientImportMap,\n    featureClientSchemaMap,\n  }\n}\n"],"mappings":"AAGA,SAASA,gBAAgB,QAAQ;AAejC,OAAO,SAASC,oBAAoBC,IAAU;EAK5C,MAAMC,cAAA,GAA8D,CAAC;EAErE;EACA,MAAMC,uBAAA,GAA0BC,KAAA,CAAMC,IAAI,CACxCJ,IAAA,CAAKK,qBAAqB,CAACC,kBAAkB,CAACC,OAAO,IACrDC,IAAI,CAAC,CAACC,CAAA,EAAGC,CAAA,KAAMD,CAAC,CAAC,EAAE,CAACE,KAAK,GAAGD,CAAC,CAAC,EAAE,CAACC,KAAK;EAExC,MAAMC,sBAAA,GAAiD,CAAC;EAExD;;;EAGA,MAAMC,sBAAA,GAA8C,CAAC;EAErD,KAAK,MAAM,CAACC,UAAA,EAAYC,eAAA,CAAgB,IAAIb,uBAAA,EAAyB;IACnED,cAAc,CAACa,UAAA,CAAW,GAAG,CAAC;IAE9B;;;IAGA,MAAME,6BAAA,GAAgCD,eAAA,CAAgBE,aAAa;IAEnE,IAAID,6BAAA,EAA+B;MACjC,MAAME,qBAAA,GAAwBpB,gBAAA,CAAgD;QAC5EqB,SAAA,EAAWnB,IAAA,CAAKoB,OAAO,CAACD,SAAS;QACjCE,gBAAA,EAAkBL,6BAAA;QAClBM,UAAA,EAAY;QACZC,MAAA,EAAQ;MACV;MAEA,IAAI,CAACL,qBAAA,EAAuB;QAC1B;MACF;MAEA,MAAMM,kBAAA,GAAqBT,eAAA,CAAgBS,kBAAkB,IAAI,CAAC;MAClEA,kBAAA,CAAmBV,UAAU,GAAGC,eAAA,CAAgBU,GAAG;MACnDD,kBAAA,CAAmBb,KAAK,GAAGI,eAAA,CAAgBJ,KAAK;MAChD,IACE,OAAOK,6BAAA,KAAkC,YACzCA,6BAAA,CAA8BU,WAAW,EACzC;QACAF,kBAAA,CAAmBE,WAAW,GAAGV,6BAAA,CAA8BU,WAAW;MAC5E;MAEA;MACAzB,cAAc,CAACa,UAAA,CAAW,GAAG;QAAEU,kBAAA;QAAoBN;MAAsB;IAC3E;IAEA;;MAAA,CAGA;IACA;IACA;IACA,IAAIH,eAAA,CAAgBY,iBAAiB,EAAE;MACrC,MAAMC,iBAAA,GAAoB,C,GACrB5B,IAAA,CAAKsB,UAAU,CAACO,KAAK,CAAC,MACzB,4BACAf,UAAA,CACD,CAACgB,IAAI,CAAC;MAEPlB,sBAAsB,CAACE,UAAA,CAAW,GAAG,CAAC;MAEtC;MACA,KAAK,MAAM,CAACW,GAAA,EAAKM,KAAA,CAAM,IAAI/B,IAAA,CAAKgC,oBAAoB,CAACzB,OAAO,IAAI;QAC9D,IAAIkB,GAAA,CAAIQ,UAAU,CAACL,iBAAA,GAAoB;UACrChB,sBAAsB,CAACE,UAAA,CAAW,CAACW,GAAA,CAAI,GAAG,YAAYM,KAAA,GAAQA,KAAA,CAAMG,MAAM,GAAG,CAACH,KAAA,CAAM;QACtF;MACF;MACA,IACEhB,eAAA,CAAgBoB,gBAAgB,IAChC,OAAOpB,eAAA,CAAgBoB,gBAAgB,KAAK,UAC5C;QACA,KAAK,MAAMV,GAAA,IAAOV,eAAA,CAAgBoB,gBAAgB,EAAE;UAClD,MAAMC,gBAAA,GAAmBrB,eAAA,CAAgBoB,gBAAgB,CAACV,GAAA,CAAI;UAE9D,MAAMY,iBAAA,GAAoBvC,gBAAA,CAAiB;YACzCqB,SAAA,EAAWnB,IAAA,CAAKoB,OAAO,CAACD,SAAS;YACjCE,gBAAA,EAAkBe,gBAAA;YAClBd,UAAA,EAAY;YACZC,MAAA,EAAQ;UACV;UAEAV,sBAAsB,CAAC,GAAGE,eAAA,CAAgBU,GAAG,IAAIA,GAAA,EAAK,CAAC,GAAGY,iBAAA;QAC5D;MACF;IACF;EACF;EACA,OAAO;IACLpC,cAAA;IACAY,sBAAA;IACAD;EACF;AACF","ignoreList":[]}