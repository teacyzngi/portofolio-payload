{"version":3,"file":"collectTopLevelJSXInLines.js","names":["linesFromStartToContentAndPropsString","createTagRegexes","collectTopLevelJSXInLines","lines","jsxToMatch","finds","regex","linesLength","length","i","line","startMatch","match","regExpStart","content","endLineIndex","propsString","isEndOptional","regexpEndRegex","regExpEnd","startLineIndex","push"],"sources":["../../../src/utilities/jsx/collectTopLevelJSXInLines.ts"],"sourcesContent":["import { linesFromStartToContentAndPropsString } from '../../features/blocks/server/markdown/linesFromMatchToContentAndPropsString.js'\nimport { createTagRegexes } from '../../features/blocks/server/markdown/markdownTransformer.js'\n\n/**\n * Helpful utility for parsing out all matching top-level JSX tags in a given string.\n * This will collect them in a list, that contains the content of the JSX tag and the props string.\n *\n * While this is not used within payload, this can be used for certain payload blocks that need to\n * be serializable and deserializable to and from JSX.\n *\n * @example:\n *\n * Say you have Steps block that contains a steps array. Its JSX representation may look like this:\n *\n * <Steps>\n *   <Step title=\"Step1\">\n *     <h1>Step 1</h1>\n *   </Step>\n *   <Step title=\"Step2\">\n *     <h1>Step 2</h1>\n *   </Step>\n * </Steps>\n *\n * In this case, the Steps block would have the following content as its children string:\n * <Step title=\"Step1\">\n *   <h1>Step 1</h1>\n * </Step>\n * <Step title=\"Step2\">\n *   <h1>Step 2</h1>\n * </Step>\n *\n * It could then use this function to collect all the top-level JSX tags (= the steps):\n *\n * collectTopLevelJSXInLines(children.split('\\n'), 'Step')\n *\n * This will return:\n *\n * [\n *   {\n *     content: '<h1>Step 1</h1>',\n *     propsString: 'title=\"Step1\"',\n *   },\n *   {\n *     content: '<h1>Step 2</h1>',\n *     propsString: 'title=\"Step2\"',\n *   },\n * ]\n *\n * You can then map this data to construct the data for this blocks array field.\n */\nexport function collectTopLevelJSXInLines(\n  lines: Array<string>,\n  jsxToMatch: string,\n): {\n  content: string\n  propsString: string\n}[] {\n  const finds: {\n    content: string\n    propsString: string\n  }[] = []\n  const regex = createTagRegexes(jsxToMatch)\n\n  const linesLength = lines.length\n\n  for (let i = 0; i < linesLength; i++) {\n    const line = lines[i]!\n    const startMatch = line.match(regex.regExpStart)\n    if (!startMatch) {\n      continue // Try next transformer\n    }\n\n    const { content, endLineIndex, propsString } = linesFromStartToContentAndPropsString({\n      isEndOptional: false,\n      lines,\n      regexpEndRegex: regex.regExpEnd,\n      startLineIndex: i,\n      startMatch,\n    })\n\n    finds.push({\n      content,\n      propsString,\n    })\n\n    i = endLineIndex\n    continue\n  }\n\n  return finds\n}\n"],"mappings":"AAAA,SAASA,qCAAqC,QAAQ;AACtD,SAASC,gBAAgB,QAAQ;AAEjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA,OAAO,SAASC,0BACdC,KAAoB,EACpBC,UAAkB;EAKlB,MAAMC,KAAA,GAGA,EAAE;EACR,MAAMC,KAAA,GAAQL,gBAAA,CAAiBG,UAAA;EAE/B,MAAMG,WAAA,GAAcJ,KAAA,CAAMK,MAAM;EAEhC,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAIF,WAAA,EAAaE,CAAA,IAAK;IACpC,MAAMC,IAAA,GAAOP,KAAK,CAACM,CAAA,CAAE;IACrB,MAAME,UAAA,GAAaD,IAAA,CAAKE,KAAK,CAACN,KAAA,CAAMO,WAAW;IAC/C,IAAI,CAACF,UAAA,EAAY;MACf,UAAS;IACX;IAEA,MAAM;MAAEG,OAAO;MAAEC,YAAY;MAAEC;IAAW,CAAE,GAAGhB,qCAAA,CAAsC;MACnFiB,aAAA,EAAe;MACfd,KAAA;MACAe,cAAA,EAAgBZ,KAAA,CAAMa,SAAS;MAC/BC,cAAA,EAAgBX,CAAA;MAChBE;IACF;IAEAN,KAAA,CAAMgB,IAAI,CAAC;MACTP,OAAA;MACAE;IACF;IAEAP,CAAA,GAAIM,YAAA;IACJ;EACF;EAEA,OAAOV,KAAA;AACT","ignoreList":[]}