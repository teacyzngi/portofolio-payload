{"version":3,"file":"buildEditorState.js","names":["buildEditorState","nodes","text","editorJSON","root","type","children","direction","format","indent","version","push","detail","mode","style","textFormat","textStyle","length","buildDefaultEditorState"],"sources":["../../src/utilities/buildEditorState.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\nimport type { DefaultNodeTypes, DefaultTypedEditorState, TypedEditorState } from '../nodeTypes.js'\n\n/**\n * Helper to build lexical editor state JSON from text and/or nodes.\n *\n * @param nodes - The nodes to include in the editor state. If you pass the `text` argument, this will append your nodes after the first paragraph node.\n * @param text - The text content to include in the editor state. This will create a paragraph node with a text node for you and set that as the first node.\n * @returns The constructed editor state JSON.\n *\n * @example\n *\n * just passing text:\n *\n * ```ts\n * const editorState = buildEditorState<DefaultNodeTypes>({ text: 'Hello world' }) // result typed as DefaultTypedEditorState\n * ```\n *\n * @example\n *\n * passing nodes:\n *\n * ```ts\n * const editorState = // result typed as TypedEditorState<DefaultNodeTypes | SerializedBlockNode> (or TypedEditorState<SerializedBlockNode>)\n * buildEditorState<DefaultNodeTypes | SerializedBlockNode>({ // or just buildEditorState<SerializedBlockNode> if you *only* want to allow block nodes\n *   nodes: [\n *     {\n *       type: 'block',\n *        fields: {\n *          id: 'id',\n *          blockName: 'Cool block',\n *          blockType: 'myBlock',\n *        },\n *        format: 'left',\n *        version: 1,\n *      }\n *   ],\n * })\n * ```\n */\nexport function buildEditorState<T extends SerializedLexicalNode>({\n  nodes,\n  text,\n}: {\n  nodes?: TypedEditorState<T>['root']['children']\n  text?: string\n}): TypedEditorState<T> {\n  const editorJSON: DefaultTypedEditorState = {\n    root: {\n      type: 'root',\n      children: [],\n      direction: 'ltr',\n      format: '',\n      indent: 0,\n      version: 1,\n    },\n  }\n\n  if (text) {\n    editorJSON.root.children.push({\n      type: 'paragraph',\n      children: [\n        {\n          type: 'text',\n          detail: 0,\n          format: 0,\n          mode: 'normal',\n          style: '',\n          text,\n          version: 1,\n        },\n      ],\n      direction: 'ltr',\n      format: '',\n      indent: 0,\n      textFormat: 0,\n      textStyle: '',\n      version: 1,\n    })\n  }\n\n  if (nodes?.length) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    editorJSON.root.children.push(...(nodes as any))\n  }\n\n  return editorJSON as TypedEditorState<T>\n}\n\n/**\n *\n * Alias for `buildEditorState<DefaultNodeTypes>`\n *\n * @experimental this API may change or be removed in a minor release\n * @internal\n */\nexport const buildDefaultEditorState: typeof buildEditorState<DefaultNodeTypes> =\n  buildEditorState<DefaultNodeTypes>\n"],"mappings":"AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCA,OAAO,SAASA,iBAAkD;EAChEC,KAAK;EACLC;AAAI,CAIL;EACC,MAAMC,UAAA,GAAsC;IAC1CC,IAAA,EAAM;MACJC,IAAA,EAAM;MACNC,QAAA,EAAU,EAAE;MACZC,SAAA,EAAW;MACXC,MAAA,EAAQ;MACRC,MAAA,EAAQ;MACRC,OAAA,EAAS;IACX;EACF;EAEA,IAAIR,IAAA,EAAM;IACRC,UAAA,CAAWC,IAAI,CAACE,QAAQ,CAACK,IAAI,CAAC;MAC5BN,IAAA,EAAM;MACNC,QAAA,EAAU,CACR;QACED,IAAA,EAAM;QACNO,MAAA,EAAQ;QACRJ,MAAA,EAAQ;QACRK,IAAA,EAAM;QACNC,KAAA,EAAO;QACPZ,IAAA;QACAQ,OAAA,EAAS;MACX,EACD;MACDH,SAAA,EAAW;MACXC,MAAA,EAAQ;MACRC,MAAA,EAAQ;MACRM,UAAA,EAAY;MACZC,SAAA,EAAW;MACXN,OAAA,EAAS;IACX;EACF;EAEA,IAAIT,KAAA,EAAOgB,MAAA,EAAQ;IACjB;IACAd,UAAA,CAAWC,IAAI,CAACE,QAAQ,CAACK,IAAI,IAAKV,KAAA;EACpC;EAEA,OAAOE,UAAA;AACT;AAEA;;;;;;;AAOA,OAAO,MAAMe,uBAAA,GACXlB,gBAAA","ignoreList":[]}