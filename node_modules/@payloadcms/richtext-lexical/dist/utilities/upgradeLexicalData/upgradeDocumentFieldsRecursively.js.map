{"version":3,"file":"upgradeDocumentFieldsRecursively.js","names":["createHeadlessEditor","fieldAffectsData","fieldHasSubFields","fieldIsArrayType","tabHasName","getEnabledNodes","upgradeDocumentFieldsRecursively","data","fields","found","payload","field","name","type","tabs","forEach","tab","Array","isArray","row","blockTypeToMatch","blockType","block","blocks","blockReferences","find","slug","editor","features","length","editorState","headlessEditor","nodes","editorConfig","update","setEditorState","parseEditorState","discrete","getEditorState","toJSON"],"sources":["../../../src/utilities/upgradeLexicalData/upgradeDocumentFieldsRecursively.ts"],"sourcesContent":["import type { SerializedEditorState } from 'lexical'\nimport type { Field, FlattenedBlock, Payload } from 'payload'\n\nimport { createHeadlessEditor } from '@lexical/headless'\nimport { fieldAffectsData, fieldHasSubFields, fieldIsArrayType, tabHasName } from 'payload/shared'\n\nimport type { LexicalRichTextAdapter } from '../../types.js'\n\nimport { getEnabledNodes } from '../../lexical/nodes/index.js'\n\ntype NestedRichTextFieldsArgs = {\n  data: Record<string, unknown>\n\n  fields: Field[]\n  found: number\n  payload: Payload\n}\n\nexport const upgradeDocumentFieldsRecursively = ({\n  data,\n  fields,\n  found,\n  payload,\n}: NestedRichTextFieldsArgs): number => {\n  for (const field of fields) {\n    if (fieldHasSubFields(field) && !fieldIsArrayType(field)) {\n      if (fieldAffectsData(field) && typeof data[field.name] === 'object') {\n        found += upgradeDocumentFieldsRecursively({\n          data: data[field.name] as Record<string, unknown>,\n          fields: field.fields,\n          found,\n          payload,\n        })\n      } else {\n        found += upgradeDocumentFieldsRecursively({\n          data,\n          fields: field.fields,\n          found,\n          payload,\n        })\n      }\n    } else if (field.type === 'tabs') {\n      field.tabs.forEach((tab) => {\n        found += upgradeDocumentFieldsRecursively({\n          data: (tabHasName(tab) ? data[tab.name] : data) as Record<string, unknown>,\n          fields: tab.fields,\n          found,\n          payload,\n        })\n      })\n    } else if (Array.isArray(data[field.name])) {\n      if (field.type === 'blocks') {\n        ;(data[field.name] as Record<string, unknown>[]).forEach((row) => {\n          const blockTypeToMatch: string = row?.blockType as string\n\n          const block =\n            payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (block) => typeof block !== 'string' && block.slug === blockTypeToMatch,\n            ) as FlattenedBlock | undefined)\n\n          if (block) {\n            found += upgradeDocumentFieldsRecursively({\n              data: row,\n              fields: block.fields,\n              found,\n              payload,\n            })\n          }\n        })\n      }\n\n      if (field.type === 'array') {\n        ;(data[field.name] as Record<string, unknown>[]).forEach((row) => {\n          found += upgradeDocumentFieldsRecursively({\n            data: row,\n            fields: field.fields,\n            found,\n            payload,\n          })\n        })\n      }\n    }\n\n    if (\n      field.type === 'richText' &&\n      data[field.name] &&\n      !Array.isArray(data[field.name]) &&\n      'root' in (data[field.name] as Record<string, unknown>)\n    ) {\n      // Lexical richText\n      const editor: LexicalRichTextAdapter = field.editor as LexicalRichTextAdapter\n      if (editor && typeof editor === 'object') {\n        if ('features' in editor && editor.features?.length) {\n          // Load lexical editor into lexical, then save it immediately\n          const editorState = data[field.name] as SerializedEditorState\n\n          const headlessEditor = createHeadlessEditor({\n            nodes: getEnabledNodes({\n              editorConfig: editor.editorConfig,\n            }),\n          })\n          headlessEditor.update(\n            () => {\n              headlessEditor.setEditorState(headlessEditor.parseEditorState(editorState))\n            },\n            { discrete: true },\n          )\n\n          // get editor state\n          data[field.name] = headlessEditor.getEditorState().toJSON()\n\n          found++\n        }\n      }\n    }\n  }\n\n  return found\n}\n"],"mappings":"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","ignoreList":[]}