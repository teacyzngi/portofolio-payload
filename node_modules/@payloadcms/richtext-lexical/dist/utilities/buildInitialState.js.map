{"version":3,"file":"buildInitialState.js","names":["fieldSchemasToFormState","buildInitialState","context","initialState","initialStateFromArgs","nodeData","node","children","type","blockNode","id","fields","schemaFieldsPath","lexicalFieldSchemaPath","blockType","formStateResult","clientFieldSchemaMap","collectionSlug","data","documentData","fieldSchemaMap","get","initialBlockData","operation","permissions","preferences","readOnly","disabled","renderAllFields","renderFieldFn","req","schemaPath","formState","currentFieldPreferences","field","name","collapsedArray","collapsed","Array","isArray","includes"],"sources":["../../src/utilities/buildInitialState.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\nimport type {\n  ClientFieldSchemaMap,\n  DocumentPreferences,\n  FieldSchemaMap,\n  FormState,\n  Operation,\n  PayloadRequest,\n  RichTextField,\n  SanitizedFieldPermissions,\n} from 'payload'\n\nimport { fieldSchemasToFormState } from '@payloadcms/ui/forms/fieldSchemasToFormState'\n\nimport type { SerializedBlockNode } from '../nodeTypes.js'\n\nexport type InitialLexicalFormState = {\n  [nodeID: string]: {\n    [key: string]: any\n    formState?: FormState\n  }\n}\n\ntype Props = {\n  context: {\n    clientFieldSchemaMap: ClientFieldSchemaMap\n    collectionSlug: string\n    disabled?: boolean\n    documentData?: any\n    field: RichTextField\n    fieldSchemaMap: FieldSchemaMap\n    id?: number | string\n    lexicalFieldSchemaPath: string\n    operation: Operation\n    permissions?: SanitizedFieldPermissions\n    preferences: DocumentPreferences\n    renderFieldFn: any\n    req: PayloadRequest\n  }\n  initialState?: InitialLexicalFormState\n  nodeData: SerializedLexicalNode[]\n}\n\nexport async function buildInitialState({\n  context,\n  initialState: initialStateFromArgs,\n  nodeData,\n}: Props): Promise<InitialLexicalFormState> {\n  let initialState: InitialLexicalFormState = initialStateFromArgs ?? {}\n  for (const node of nodeData) {\n    if ('children' in node) {\n      initialState = await buildInitialState({\n        context,\n        initialState,\n        nodeData: node.children as SerializedLexicalNode[],\n      })\n    }\n\n    if (node.type === 'block' || node.type === 'inlineBlock') {\n      const blockNode = node as SerializedBlockNode\n      const id = blockNode?.fields?.id\n      if (!id) {\n        continue\n      }\n\n      const schemaFieldsPath =\n        node.type === 'block'\n          ? `${context.lexicalFieldSchemaPath}.lexical_internal_feature.blocks.lexical_blocks.${blockNode.fields.blockType}.fields`\n          : `${context.lexicalFieldSchemaPath}.lexical_internal_feature.blocks.lexical_inline_blocks.${blockNode.fields.blockType}.fields`\n\n      // Build form state for the block\n\n      const formStateResult = await fieldSchemasToFormState({\n        id: context.id,\n        clientFieldSchemaMap: context.clientFieldSchemaMap,\n        collectionSlug: context.collectionSlug,\n        data: blockNode.fields,\n        documentData: context.documentData,\n        fields: (context.fieldSchemaMap.get(schemaFieldsPath) as any)?.fields,\n        fieldSchemaMap: context.fieldSchemaMap,\n        initialBlockData: blockNode.fields,\n        operation: context.operation as any, // TODO: Type\n        permissions: true,\n        preferences: context.preferences,\n        readOnly: context.disabled,\n        renderAllFields: true, // If this function runs, the parent lexical field is being re-rendered => thus we can assume all its sub-fields need to be re-rendered\n        renderFieldFn: context.renderFieldFn,\n        req: context.req,\n        schemaPath: schemaFieldsPath,\n      })\n\n      if (!initialState[id]) {\n        initialState[id] = {}\n      }\n\n      initialState[id].formState = formStateResult\n\n      if (node.type === 'block') {\n        const currentFieldPreferences = context.preferences?.fields?.[context.field.name]\n        const collapsedArray = currentFieldPreferences?.collapsed\n        if (Array.isArray(collapsedArray) && collapsedArray.includes(id)) {\n          initialState[id].collapsed = true\n        }\n      }\n    }\n  }\n  return initialState\n}\n"],"mappings":"AAYA,SAASA,uBAAuB,QAAQ;AA+BxC,OAAO,eAAeC,kBAAkB;EACtCC,OAAO;EACPC,YAAA,EAAcC,oBAAoB;EAClCC;AAAQ,CACF;EACN,IAAIF,YAAA,GAAwCC,oBAAA,IAAwB,CAAC;EACrE,KAAK,MAAME,IAAA,IAAQD,QAAA,EAAU;IAC3B,IAAI,cAAcC,IAAA,EAAM;MACtBH,YAAA,GAAe,MAAMF,iBAAA,CAAkB;QACrCC,OAAA;QACAC,YAAA;QACAE,QAAA,EAAUC,IAAA,CAAKC;MACjB;IACF;IAEA,IAAID,IAAA,CAAKE,IAAI,KAAK,WAAWF,IAAA,CAAKE,IAAI,KAAK,eAAe;MACxD,MAAMC,SAAA,GAAYH,IAAA;MAClB,MAAMI,EAAA,GAAKD,SAAA,EAAWE,MAAA,EAAQD,EAAA;MAC9B,IAAI,CAACA,EAAA,EAAI;QACP;MACF;MAEA,MAAME,gBAAA,GACJN,IAAA,CAAKE,IAAI,KAAK,UACV,GAAGN,OAAA,CAAQW,sBAAsB,mDAAmDJ,SAAA,CAAUE,MAAM,CAACG,SAAS,SAAS,GACvH,GAAGZ,OAAA,CAAQW,sBAAsB,0DAA0DJ,SAAA,CAAUE,MAAM,CAACG,SAAS,SAAS;MAEpI;MAEA,MAAMC,eAAA,GAAkB,MAAMf,uBAAA,CAAwB;QACpDU,EAAA,EAAIR,OAAA,CAAQQ,EAAE;QACdM,oBAAA,EAAsBd,OAAA,CAAQc,oBAAoB;QAClDC,cAAA,EAAgBf,OAAA,CAAQe,cAAc;QACtCC,IAAA,EAAMT,SAAA,CAAUE,MAAM;QACtBQ,YAAA,EAAcjB,OAAA,CAAQiB,YAAY;QAClCR,MAAA,EAAST,OAAA,CAAQkB,cAAc,CAACC,GAAG,CAACT,gBAAA,GAA2BD,MAAA;QAC/DS,cAAA,EAAgBlB,OAAA,CAAQkB,cAAc;QACtCE,gBAAA,EAAkBb,SAAA,CAAUE,MAAM;QAClCY,SAAA,EAAWrB,OAAA,CAAQqB,SAAS;QAC5BC,WAAA,EAAa;QACbC,WAAA,EAAavB,OAAA,CAAQuB,WAAW;QAChCC,QAAA,EAAUxB,OAAA,CAAQyB,QAAQ;QAC1BC,eAAA,EAAiB;QACjBC,aAAA,EAAe3B,OAAA,CAAQ2B,aAAa;QACpCC,GAAA,EAAK5B,OAAA,CAAQ4B,GAAG;QAChBC,UAAA,EAAYnB;MACd;MAEA,IAAI,CAACT,YAAY,CAACO,EAAA,CAAG,EAAE;QACrBP,YAAY,CAACO,EAAA,CAAG,GAAG,CAAC;MACtB;MAEAP,YAAY,CAACO,EAAA,CAAG,CAACsB,SAAS,GAAGjB,eAAA;MAE7B,IAAIT,IAAA,CAAKE,IAAI,KAAK,SAAS;QACzB,MAAMyB,uBAAA,GAA0B/B,OAAA,CAAQuB,WAAW,EAAEd,MAAA,GAAST,OAAA,CAAQgC,KAAK,CAACC,IAAI,CAAC;QACjF,MAAMC,cAAA,GAAiBH,uBAAA,EAAyBI,SAAA;QAChD,IAAIC,KAAA,CAAMC,OAAO,CAACH,cAAA,KAAmBA,cAAA,CAAeI,QAAQ,CAAC9B,EAAA,GAAK;UAChEP,YAAY,CAACO,EAAA,CAAG,CAAC2B,SAAS,GAAG;QAC/B;MACF;IACF;EACF;EACA,OAAOlC,YAAA;AACT","ignoreList":[]}