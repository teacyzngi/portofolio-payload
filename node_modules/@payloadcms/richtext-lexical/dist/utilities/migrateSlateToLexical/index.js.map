{"version":3,"file":"index.js","names":["migrateDocumentFieldsRecursively","migrateSlateToLexical","payload","collections","config","errors","allLocales","localization","localeCodes","totalCollections","length","locale","curCollection","collection","migrateCollection","cur","max","global","globals","migrateGlobal","console","error","JSON","stringify","log","slug","document","findGlobal","depth","draft","undefined","overrideAccess","found","migrateDocument","fields","updateGlobal","data","_status","e","push","documentCount","count","totalDocs","page","migrated","documents","find","pagination","docs","id","update"],"sources":["../../../src/utilities/migrateSlateToLexical/index.ts"],"sourcesContent":["/* eslint-disable no-console */\nimport type { CollectionConfig, Field, GlobalConfig, Payload } from 'payload'\n\nimport { migrateDocumentFieldsRecursively } from './migrateDocumentFieldsRecursively.js'\n\n/**\n * This goes through every single collection and field in the payload config, and migrates its data from Slate to Lexical. This does not support sub-fields within slate.\n *\n * It will only translate fields fulfilling all these requirements:\n * - field schema uses lexical editor\n * - lexical editor has SlateToLexicalFeature added\n * - saved field data is in Slate format\n *\n * @param payload\n */\nexport async function migrateSlateToLexical({ payload }: { payload: Payload }) {\n  const collections = payload.config.collections\n\n  const errors: unknown[] = []\n\n  const allLocales = payload.config.localization ? payload.config.localization.localeCodes : [null]\n\n  const totalCollections = collections.length\n  for (const locale of allLocales) {\n    let curCollection = 0\n    for (const collection of collections) {\n      curCollection++\n      await migrateCollection({\n        collection,\n        cur: curCollection,\n        errors,\n        locale,\n        max: totalCollections,\n        payload,\n      })\n    }\n    for (const global of payload.config.globals) {\n      await migrateGlobal({\n        errors,\n        global,\n        locale,\n        payload,\n      })\n    }\n  }\n\n  if (errors.length) {\n    console.error(`Found ${errors.length} errors::`, JSON.stringify(errors, null, 2))\n  } else {\n    console.log('Migration successful - no errors')\n  }\n}\n\nasync function migrateGlobal({\n  errors,\n  global,\n  locale,\n  payload,\n}: {\n  errors: unknown[]\n  global: GlobalConfig\n  locale: null | string\n  payload: Payload\n}) {\n  console.log(`SlateToLexical: ${locale}: Migrating global:`, global.slug)\n\n  const document = await payload.findGlobal({\n    slug: global.slug,\n    depth: 0,\n    draft: true,\n    locale: locale || undefined,\n    overrideAccess: true,\n  })\n\n  const found = migrateDocument({\n    document,\n    fields: global.fields,\n    payload,\n  })\n\n  if (found) {\n    try {\n      await payload.updateGlobal({\n        slug: global.slug,\n        data: document,\n        depth: 0,\n        draft: document?._status === 'draft',\n        locale: locale || undefined,\n      })\n      // Catch it, because some errors were caused by the user previously (e.g. invalid relationships) and will throw an error now, even though they are not related to the migration\n    } catch (e) {\n      console.log('Error updating global', e, {\n        slug: global.slug,\n      })\n      errors.push(e)\n    }\n  }\n}\n\nasync function migrateCollection({\n  collection,\n  cur,\n  errors,\n  locale,\n  max,\n  payload,\n}: {\n  collection: CollectionConfig\n  cur: number\n  errors: unknown[]\n  locale: null | string\n  max: number\n  payload: Payload\n}) {\n  console.log(\n    `SlateToLexical: ${locale}: Migrating collection:`,\n    collection.slug,\n    '(' + cur + '/' + max + ')',\n  )\n\n  const documentCount = (\n    await payload.count({\n      collection: collection.slug,\n      depth: 0,\n      locale: locale || undefined,\n    })\n  ).totalDocs\n\n  let page = 1\n  let migrated = 0\n\n  while (migrated < documentCount) {\n    const documents = await payload.find({\n      collection: collection.slug,\n      depth: 0,\n      draft: true,\n      locale: locale || undefined,\n      overrideAccess: true,\n      page,\n      pagination: true,\n    })\n\n    for (const document of documents.docs) {\n      migrated++\n      console.log(\n        `SlateToLexical: ${locale}: Migrating collection:`,\n        collection.slug,\n        '(' +\n          cur +\n          '/' +\n          max +\n          ') - Migrating Document: ' +\n          document.id +\n          ' (' +\n          migrated +\n          '/' +\n          documentCount +\n          ')',\n      )\n      const found = migrateDocument({\n        document,\n        fields: collection.fields,\n        payload,\n      })\n\n      if (found) {\n        try {\n          await payload.update({\n            id: document.id,\n            collection: collection.slug,\n            data: document,\n            depth: 0,\n            draft: document?._status === 'draft',\n            locale: locale || undefined,\n          })\n          // Catch it, because some errors were caused by the user previously (e.g. invalid relationships) and will throw an error now, even though they are not related to the migration\n        } catch (e) {\n          errors.push(e)\n\n          console.log('Error updating collection', e, {\n            id: document.id,\n            slug: collection.slug,\n          })\n        }\n      }\n    }\n    page++\n  }\n}\n\nfunction migrateDocument({\n  document,\n  fields,\n  payload,\n}: {\n  document: Record<string, unknown>\n  fields: Field[]\n  payload: Payload\n}): boolean {\n  return !!migrateDocumentFieldsRecursively({\n    data: document,\n    fields,\n    found: 0,\n    payload,\n  })\n}\n"],"mappings":"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","ignoreList":[]}