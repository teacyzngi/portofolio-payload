{"version":3,"file":"migrateDocumentFieldsRecursively.js","names":["fieldAffectsData","fieldHasSubFields","fieldIsArrayType","tabHasName","convertSlateToLexical","migrateDocumentFieldsRecursively","data","fields","found","payload","field","name","type","tabs","forEach","tab","Array","isArray","row","blockTypeToMatch","blockType","block","blocks","blockReferences","find","slug","editor","features","length","slateToLexicalFeature","editorConfig","resolvedFeatureMap","get","converters","sanitizedServerFeatureProps","slateData"],"sources":["../../../src/utilities/migrateSlateToLexical/migrateDocumentFieldsRecursively.ts"],"sourcesContent":["import type { Field, FlattenedBlock, Payload } from 'payload'\n\nimport { fieldAffectsData, fieldHasSubFields, fieldIsArrayType, tabHasName } from 'payload/shared'\n\nimport type {\n  SlateNode,\n  SlateNodeConverter,\n} from '../../features/migrations/slateToLexical/converter/types.js'\nimport type { LexicalRichTextAdapter } from '../../types.js'\n\nimport { convertSlateToLexical } from '../../features/migrations/slateToLexical/converter/index.js'\n\ntype NestedRichTextFieldsArgs = {\n  data: Record<string, unknown>\n\n  fields: Field[]\n  found: number\n  payload: Payload\n}\n\nexport const migrateDocumentFieldsRecursively = ({\n  data,\n  fields,\n  found,\n  payload,\n}: NestedRichTextFieldsArgs): number => {\n  for (const field of fields) {\n    if (fieldHasSubFields(field) && !fieldIsArrayType(field)) {\n      if (fieldAffectsData(field) && typeof data[field.name] === 'object') {\n        found += migrateDocumentFieldsRecursively({\n          data: data[field.name] as Record<string, unknown>,\n          fields: field.fields,\n          found,\n          payload,\n        })\n      } else {\n        found += migrateDocumentFieldsRecursively({\n          data,\n          fields: field.fields,\n          found,\n          payload,\n        })\n      }\n    } else if (field.type === 'tabs') {\n      field.tabs.forEach((tab) => {\n        found += migrateDocumentFieldsRecursively({\n          data: (tabHasName(tab) ? data[tab.name] : data) as Record<string, unknown>,\n          fields: tab.fields,\n          found,\n          payload,\n        })\n      })\n    } else if (Array.isArray(data[field.name])) {\n      if (field.type === 'blocks') {\n        ;(data[field.name] as Array<Record<string, unknown>>).forEach((row) => {\n          const blockTypeToMatch: string = row?.blockType as string\n          const block =\n            payload?.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (block) => typeof block !== 'string' && block.slug === blockTypeToMatch,\n            ) as FlattenedBlock | undefined)\n\n          if (block) {\n            found += migrateDocumentFieldsRecursively({\n              data: row,\n              fields: block.fields,\n              found,\n              payload,\n            })\n          }\n        })\n      }\n\n      if (field.type === 'array') {\n        ;(data[field.name] as Array<Record<string, unknown>>).forEach((row) => {\n          found += migrateDocumentFieldsRecursively({\n            data: row,\n            fields: field.fields,\n            found,\n            payload,\n          })\n        })\n      }\n    }\n\n    if (field.type === 'richText' && Array.isArray(data[field.name])) {\n      // Slate richText\n      const editor: LexicalRichTextAdapter = field.editor as LexicalRichTextAdapter\n      if (editor && typeof editor === 'object') {\n        if ('features' in editor && editor.features?.length) {\n          // find slatetolexical feature\n          const slateToLexicalFeature = editor.editorConfig.resolvedFeatureMap.get('slateToLexical')\n          if (slateToLexicalFeature) {\n            // DO CONVERSION\n\n            const { converters } = slateToLexicalFeature.sanitizedServerFeatureProps as {\n              converters?: SlateNodeConverter[]\n            }\n\n            data[field.name] = convertSlateToLexical({\n              converters: converters!,\n              slateData: data[field.name] as SlateNode[],\n            })\n\n            found++\n          }\n        }\n      }\n    }\n  }\n\n  return found\n}\n"],"mappings":"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","ignoreList":[]}