{"version":3,"file":"types.js","names":[],"sources":["../src/types.ts"],"sourcesContent":["import type { EditorConfig as LexicalEditorConfig, SerializedEditorState } from 'lexical'\nimport type {\n  ClientField,\n  DefaultServerCellComponentProps,\n  LabelFunction,\n  RichTextAdapter,\n  RichTextField,\n  RichTextFieldClient,\n  RichTextFieldClientProps,\n  SanitizedConfig,\n  ServerFieldBase,\n  StaticLabel,\n} from 'payload'\n\nimport type {\n  BaseClientFeatureProps,\n  FeatureProviderProviderClient,\n} from './features/typesClient.js'\nimport type { FeatureProviderServer } from './features/typesServer.js'\nimport type { SanitizedServerEditorConfig } from './lexical/config/types.js'\nimport type { InitialLexicalFormState } from './utilities/buildInitialState.js'\n\nexport type LexicalFieldAdminProps = {\n  /**\n   * Controls if the add block button should be hidden. @default false\n   */\n  hideAddBlockButton?: boolean\n  /**\n   * Controls if the draggable block element should be hidden. @default false\n   */\n  hideDraggableBlockElement?: boolean\n  /**\n   * Controls if the gutter (padding to the left & gray vertical line) should be hidden. @default false\n   */\n  hideGutter?: boolean\n  /**\n   * Controls if the insert paragraph at the end button should be hidden. @default false\n   */\n  hideInsertParagraphAtEnd?: boolean\n  /**\n   * Changes the placeholder text in the editor if no content is present.\n   */\n  placeholder?: LabelFunction | StaticLabel\n}\n\nexport type LexicalFieldAdminClientProps = {\n  placeholder?: string\n} & Omit<LexicalFieldAdminProps, 'placeholder'>\n\nexport type FeaturesInput =\n  | (({\n      defaultFeatures,\n      rootFeatures,\n    }: {\n      /**\n       * This opinionated array contains all \"recommended\" default features.\n       *\n       * @Example\n       *\n       * ```ts\n       *  editor: lexicalEditor({\n       *    features: ({ defaultFeatures }) => [...defaultFeatures, FixedToolbarFeature()],\n       *  })\n       *  ```\n       */\n      defaultFeatures: FeatureProviderServer<any, any, any>[]\n      /**\n       * This array contains all features that are enabled in the root richText editor (the one defined in the payload.config.ts).\n       * If this field is the root richText editor, or if the root richText editor is not a lexical editor, this array will be empty.\n       *\n       * @Example\n       *\n       * ```ts\n       *  editor: lexicalEditor({\n       *    features: ({ rootFeatures }) => [...rootFeatures, FixedToolbarFeature()],\n       *  })\n       *  ```\n       */\n      rootFeatures: FeatureProviderServer<any, any, any>[]\n    }) => FeatureProviderServer<any, any, any>[])\n  | FeatureProviderServer<any, any, any>[]\n\nexport type LexicalEditorProps = {\n  admin?: LexicalFieldAdminProps\n  features?: FeaturesInput\n  lexical?: LexicalEditorConfig\n}\n\nexport type LexicalRichTextAdapter = {\n  editorConfig: SanitizedServerEditorConfig\n  features: FeatureProviderServer<any, any, any>[]\n} & RichTextAdapter<SerializedEditorState, AdapterProps>\n\nexport type LexicalRichTextAdapterProvider =\n  /**\n   * This is being called during the payload sanitization process\n   */\n  ({\n    config,\n    isRoot,\n    parentIsLocalized,\n  }: {\n    config: SanitizedConfig\n    isRoot?: boolean\n    parentIsLocalized: boolean\n  }) => Promise<LexicalRichTextAdapter>\n\nexport type SingleFeatureClientSchemaMap = {\n  [key: string]: ClientField[]\n}\nexport type FeatureClientSchemaMap = {\n  [featureKey: string]: SingleFeatureClientSchemaMap\n}\n\nexport type LexicalRichTextFieldProps = {\n  admin?: LexicalFieldAdminClientProps\n  // clientFeatures is added through the rsc field\n  clientFeatures: {\n    [featureKey: string]: {\n      clientFeatureProps?: object\n      clientFeatureProvider?: FeatureProviderProviderClient<any, any>\n    }\n  }\n  featureClientImportMap: Record<string, any>\n  featureClientSchemaMap: FeatureClientSchemaMap\n  initialLexicalFormState: InitialLexicalFormState\n  lexicalEditorConfig: LexicalEditorConfig | undefined // Undefined if default lexical editor config should be used\n} & Pick<ServerFieldBase, 'permissions'> &\n  RichTextFieldClientProps<SerializedEditorState, AdapterProps, object>\n\nexport type LexicalRichTextCellProps = DefaultServerCellComponentProps<\n  RichTextFieldClient<SerializedEditorState, AdapterProps, object>,\n  SerializedEditorState\n>\n\nexport type AdapterProps = {\n  editorConfig: SanitizedServerEditorConfig\n}\n\nexport type GeneratedFeatureProviderComponent = {\n  clientFeature: FeatureProviderProviderClient<any, any>\n  clientFeatureProps: BaseClientFeatureProps<object>\n}\n\nexport type LexicalRichTextField = RichTextField<SerializedEditorState, AdapterProps>\n"],"mappings":"AAgJA","ignoreList":[]}