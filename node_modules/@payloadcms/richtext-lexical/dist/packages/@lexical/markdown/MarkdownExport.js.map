{"version":3,"file":"MarkdownExport.js","names":["$getRoot","$isDecoratorNode","$isElementNode","$isLineBreakNode","$isTextNode","isEmptyParagraph","transformersByType","createMarkdownExport","transformers","shouldPreserveNewLines","byType","elementTransformers","multilineElement","element","isNewlineDelimited","textFormatTransformers","textFormat","filter","transformer","format","length","sort","a","b","includes","node","output","children","getChildren","forEach","child","i","result","exportTopLevelElements","textMatch","push","concat","join","textTransformersIndex","textMatchTransformers","export","_node","exportChildren","getTextContent","unclosedTags","unclosableTags","mainLoop","parentNode","textNode","textContent","exportTextFormat","textTransformers","frozenString","trim","hasFormat","replace","openingTags","closingTagsBefore","closingTagsAfter","prevNode","getTextSibling","nextNode","applied","Set","tag","has","add","find","unclosedTag","nodeHasFormat","nextNodeHasFormat","unhandledUnclosedTags","pop","backward","sibling","getPreviousSibling","getNextSibling","parent","getParentOrThrow","isInline","descendant","getLastDescendant","getFirstDescendant"],"sources":["../../../../src/packages/@lexical/markdown/MarkdownExport.ts"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type { ElementNode, LexicalNode, TextFormatType, TextNode } from 'lexical'\n\nimport { $getRoot, $isDecoratorNode, $isElementNode, $isLineBreakNode, $isTextNode } from 'lexical'\n\nimport type {\n  ElementTransformer,\n  MultilineElementTransformer,\n  TextFormatTransformer,\n  TextMatchTransformer,\n  Transformer,\n} from './MarkdownTransformers.js'\n\nimport { isEmptyParagraph, transformersByType } from './utils.js'\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nexport function createMarkdownExport(\n  transformers: Array<Transformer>,\n  shouldPreserveNewLines: boolean = false,\n): (node?: ElementNode) => string {\n  const byType = transformersByType(transformers)\n  const elementTransformers = [...byType.multilineElement, ...byType.element]\n  const isNewlineDelimited = !shouldPreserveNewLines\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat\n    .filter((transformer) => transformer.format.length === 1)\n    // Make sure all text transformers that contain 'code' in their format are at the end of the array. Otherwise, formatted code like\n    // <strong><code>code</code></strong> will be exported as `**Bold Code**`, as the code format will be applied first, and the bold format\n    // will be applied second and thus skipped entirely, as the code format will prevent any further formatting.\n    .sort((a, b) => {\n      if (a.format.includes('code') && !b.format.includes('code')) {\n        return 1\n      } else if (!a.format.includes('code') && b.format.includes('code')) {\n        return -1\n      } else {\n        return 0\n      }\n    })\n\n  return (node) => {\n    const output: string[] = []\n    const children = (node || $getRoot()).getChildren()\n\n    children.forEach((child, i) => {\n      const result = exportTopLevelElements(\n        child,\n        elementTransformers,\n        textFormatTransformers,\n        byType.textMatch,\n      )\n\n      if (result != null) {\n        output.push(\n          // separate consecutive group of texts with a line break: eg. [\"hello\", \"world\"] -> [\"hello\", \"/nworld\"]\n          isNewlineDelimited &&\n            i > 0 &&\n            !isEmptyParagraph(child) &&\n            !isEmptyParagraph(children[i - 1]!)\n            ? '\\n'.concat(result)\n            : result,\n        )\n      }\n    })\n    // Ensure consecutive groups of texts are at least \\n\\n apart while each empty paragraph render as a newline.\n    // Eg. [\"hello\", \"\", \"\", \"hi\", \"\\nworld\"] -> \"hello\\n\\n\\nhi\\n\\nworld\"\n    return output.join('\\n')\n  }\n}\n\nfunction exportTopLevelElements(\n  node: LexicalNode,\n  elementTransformers: Array<ElementTransformer | MultilineElementTransformer>,\n  textTransformersIndex: Array<TextFormatTransformer>,\n  textMatchTransformers: Array<TextMatchTransformer>,\n): null | string {\n  for (const transformer of elementTransformers) {\n    if (!transformer.export) {\n      continue\n    }\n    const result = transformer.export(node, (_node) =>\n      exportChildren(_node, textTransformersIndex, textMatchTransformers),\n    )\n\n    if (result != null) {\n      return result\n    }\n  }\n\n  if ($isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers)\n  } else if ($isDecoratorNode(node)) {\n    return node.getTextContent()\n  } else {\n    return null\n  }\n}\n\nfunction exportChildren(\n  node: ElementNode,\n  textTransformersIndex: Array<TextFormatTransformer>,\n  textMatchTransformers: Array<TextMatchTransformer>,\n  unclosedTags?: Array<{ format: TextFormatType; tag: string }>,\n  unclosableTags?: Array<{ format: TextFormatType; tag: string }>,\n): string {\n  const output = []\n  const children = node.getChildren()\n  // keep track of unclosed tags from the very beginning\n  if (!unclosedTags) {\n    unclosedTags = []\n  }\n  if (!unclosableTags) {\n    unclosableTags = []\n  }\n\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      if (!transformer.export) {\n        continue\n      }\n\n      const result = transformer.export(\n        child,\n        (parentNode) =>\n          exportChildren(\n            parentNode,\n            textTransformersIndex,\n            textMatchTransformers,\n            unclosedTags,\n            // Add current unclosed tags to the list of unclosable tags - we don't want nested tags from\n            // textmatch transformers to close the outer ones, as that may result in invalid markdown.\n            // E.g. **text [text**](https://lexical.io)\n            // is invalid markdown, as the closing ** is inside the link.\n            //\n            [...unclosableTags, ...unclosedTags],\n          ),\n        (textNode, textContent) =>\n          exportTextFormat(\n            textNode,\n            textContent,\n            textTransformersIndex,\n            unclosedTags,\n            unclosableTags,\n          ),\n      )\n\n      if (result != null) {\n        output.push(result)\n        continue mainLoop\n      }\n    }\n\n    if ($isLineBreakNode(child)) {\n      output.push('\\n')\n    } else if ($isTextNode(child)) {\n      output.push(\n        exportTextFormat(\n          child,\n          child.getTextContent(),\n          textTransformersIndex,\n          unclosedTags,\n          unclosableTags,\n        ),\n      )\n    } else if ($isElementNode(child)) {\n      // empty paragraph returns \"\"\n      output.push(\n        exportChildren(\n          child,\n          textTransformersIndex,\n          textMatchTransformers,\n          unclosedTags,\n          unclosableTags,\n        ),\n      )\n    } else if ($isDecoratorNode(child)) {\n      output.push(child.getTextContent())\n    }\n  }\n\n  return output.join('')\n}\n\nfunction exportTextFormat(\n  node: TextNode,\n  textContent: string,\n  textTransformers: Array<TextFormatTransformer>,\n  // unclosed tags include the markdown tags that haven't been closed yet, and their associated formats\n  unclosedTags: Array<{ format: TextFormatType; tag: string }>,\n  unclosableTags?: Array<{ format: TextFormatType; tag: string }>,\n): string {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim()\n  let output = frozenString\n\n  if (!node.hasFormat('code')) {\n    // Escape any markdown characters in the text content\n    output = output.replace(/([*_`~\\\\])/g, '\\\\$1')\n  }\n\n  // the opening tags to be added to the result\n  let openingTags = ''\n  // the closing tags to be added to the result\n  let closingTagsBefore = ''\n  let closingTagsAfter = ''\n\n  const prevNode = getTextSibling(node, true)\n  const nextNode = getTextSibling(node, false)\n\n  const applied = new Set()\n\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0]!\n    const tag = transformer.tag\n\n    // dedup applied formats\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format)\n\n      // append the tag to openningTags, if it's not applied to the previous nodes,\n      // or the nodes before that (which would result in an unclosed tag)\n      if (!hasFormat(prevNode, format) || !unclosedTags.find((element) => element.tag === tag)) {\n        unclosedTags.push({ format, tag })\n        openingTags += tag\n      }\n    }\n  }\n\n  // close any tags in the same order they were applied, if necessary\n  for (let i = 0; i < unclosedTags.length; i++) {\n    const unclosedTag = unclosedTags[i]!\n    const nodeHasFormat = hasFormat(node, unclosedTag.format)\n    const nextNodeHasFormat = hasFormat(nextNode, unclosedTag.format)\n\n    // prevent adding closing tag if next sibling will do it\n    if (nodeHasFormat && nextNodeHasFormat) {\n      continue\n    }\n\n    const unhandledUnclosedTags = [...unclosedTags] // Shallow copy to avoid modifying the original array\n\n    while (unhandledUnclosedTags.length > i) {\n      const unclosedTag = unhandledUnclosedTags.pop()\n\n      // If tag is unclosable, don't close it and leave it in the original array,\n      // So that it can be closed when it's no longer unclosable\n      if (\n        unclosableTags &&\n        unclosedTag &&\n        unclosableTags.find((element) => element.tag === unclosedTag.tag)\n      ) {\n        continue\n      }\n\n      if (unclosedTag && typeof unclosedTag.tag === 'string') {\n        if (!nodeHasFormat) {\n          // Handles cases where the tag has not been closed before, e.g. if the previous node\n          // was a text match transformer that did not account for closing tags of the next node (e.g. a link)\n          closingTagsBefore += unclosedTag.tag\n        } else if (!nextNodeHasFormat) {\n          closingTagsAfter += unclosedTag.tag\n        }\n      }\n      // Mutate the original array to remove the closed tag\n      unclosedTags.pop()\n    }\n    break\n  }\n\n  output = openingTags + output + closingTagsAfter\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return closingTagsBefore + textContent.replace(frozenString, () => output)\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node: TextNode, backward: boolean): null | TextNode {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling()\n\n  if (!sibling) {\n    const parent = node.getParentOrThrow()\n\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling()\n    }\n  }\n\n  while (sibling) {\n    if ($isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break\n      }\n\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant()\n\n      if ($isTextNode(descendant)) {\n        return descendant\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling()\n      }\n    }\n\n    if ($isTextNode(sibling)) {\n      return sibling\n    }\n\n    if (!$isElementNode(sibling)) {\n      return null\n    }\n  }\n\n  return null\n}\n\nfunction hasFormat(node: LexicalNode | null | undefined, format: TextFormatType): boolean {\n  return $isTextNode(node) && node.hasFormat(format)\n}\n"],"mappings":"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","ignoreList":[]}