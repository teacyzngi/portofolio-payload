{"version":3,"file":"utils.js","names":["$isListItemNode","$isListNode","$isHeadingNode","$isQuoteNode","$isParagraphNode","$isTextNode","autoFormatBase","markdownFormatKind","regEx","regExForAutoFormatting","requiresParagraphStart","paragraphStartBase","markdownHeader1","export","createHeadingExport","markdownHeader2","markdownHeader3","markdownHeader4","markdownHeader5","markdownHeader6","markdownBlockQuote","blockQuoteExport","markdownUnorderedListDash","listExport","markdownUnorderedListAsterisk","markdownOrderedList","markdownHorizontalRule","markdownHorizontalRuleUsingDashes","markdownInlineCode","exportFormat","exportTag","markdownBold","markdownItalic","markdownBold2","markdownItalic2","fakeMarkdownUnderline","exportTagClose","markdownStrikethrough","markdownStrikethroughItalicBold","markdownItalicbold","markdownStrikethroughItalic","markdownStrikethroughBold","markdownLink","allMarkdownCriteriaForTextNodes","allMarkdownCriteriaForParagraphs","getAllMarkdownCriteriaForParagraphs","getAllMarkdownCriteriaForTextNodes","level","node","exportChildren","getTag","repeat","processNestedLists","LIST_INDENT_SIZE","listNode","depth","output","children","getChildren","index","listItemNode","getChildrenSize","firstChild","getFirstChild","push","indent","prefix","getListType","getStart","join","indexBy","list","callback","item","key","transformersByType","transformers","byType","t","type","element","multilineElement","textFormat","textMatch","PUNCTUATION_OR_SPACE","MARKDOWN_EMPTY_LINE_REG_EXP","isEmptyParagraph","test","getTextContent"],"sources":["../../../../src/packages/@lexical/markdown/utils.ts"],"sourcesContent":["/* eslint-disable regexp/no-obscure-range */\n/* eslint-disable regexp/no-empty-group */\n/* eslint-disable regexp/no-empty-capturing-group */\n/* eslint-disable regexp/optimal-quantifier-concatenation */\n/* eslint-disable regexp/no-misleading-capturing-group */\n/* eslint-disable regexp/no-contradiction-with-assertion */\n/* eslint-disable regexp/no-super-linear-backtracking */\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type { ListNode } from '@lexical/list'\n\nimport { $isListItemNode, $isListNode } from '@lexical/list'\nimport { $isHeadingNode, $isQuoteNode } from '@lexical/rich-text'\nimport {\n  $isParagraphNode,\n  $isTextNode,\n  type ElementNode,\n  type LexicalNode,\n  type TextFormatType,\n} from 'lexical'\n\nimport type {\n  ElementTransformer,\n  MultilineElementTransformer,\n  TextFormatTransformer,\n  TextMatchTransformer,\n  Transformer,\n} from './MarkdownTransformers.js'\n\ntype MarkdownFormatKind =\n  | 'bold'\n  | 'code'\n  | 'horizontalRule'\n  | 'italic'\n  | 'italic_bold'\n  | 'link'\n  | 'noTransformation'\n  | 'paragraphBlockQuote'\n  | 'paragraphCodeBlock'\n  | 'paragraphH1'\n  | 'paragraphH2'\n  | 'paragraphH3'\n  | 'paragraphH4'\n  | 'paragraphH5'\n  | 'paragraphH6'\n  | 'paragraphOrderedList'\n  | 'paragraphUnorderedList'\n  | 'strikethrough'\n  | 'strikethrough_bold'\n  | 'strikethrough_italic'\n  | 'strikethrough_italic_bold'\n  | 'underline'\n\ntype MarkdownCriteria = Readonly<{\n  export?: (\n    node: LexicalNode,\n    traverseChildren: (elementNode: ElementNode) => string,\n  ) => null | string\n  exportFormat?: TextFormatType\n  exportTag?: string\n  exportTagClose?: string\n  markdownFormatKind: MarkdownFormatKind | null | undefined\n  regEx: RegExp\n  regExForAutoFormatting: RegExp\n  requiresParagraphStart: boolean | null | undefined\n}>\n\ntype MarkdownCriteriaArray = Array<MarkdownCriteria>\n\nconst autoFormatBase: MarkdownCriteria = {\n  markdownFormatKind: null,\n  regEx: /(?:)/,\n  regExForAutoFormatting: /(?:)/,\n  requiresParagraphStart: false,\n}\n\nconst paragraphStartBase: MarkdownCriteria = {\n  ...autoFormatBase,\n  requiresParagraphStart: true,\n}\n\nconst markdownHeader1: MarkdownCriteria = {\n  ...paragraphStartBase,\n  export: createHeadingExport(1),\n  markdownFormatKind: 'paragraphH1',\n  regEx: /^# /,\n  regExForAutoFormatting: /^# /,\n}\n\nconst markdownHeader2: MarkdownCriteria = {\n  ...paragraphStartBase,\n  export: createHeadingExport(2),\n  markdownFormatKind: 'paragraphH2',\n  regEx: /^## /,\n  regExForAutoFormatting: /^## /,\n}\n\nconst markdownHeader3: MarkdownCriteria = {\n  ...paragraphStartBase,\n  export: createHeadingExport(3),\n  markdownFormatKind: 'paragraphH3',\n  regEx: /^### /,\n  regExForAutoFormatting: /^### /,\n}\n\nconst markdownHeader4: MarkdownCriteria = {\n  ...paragraphStartBase,\n  export: createHeadingExport(4),\n  markdownFormatKind: 'paragraphH4',\n  regEx: /^#### /,\n  regExForAutoFormatting: /^#### /,\n}\n\nconst markdownHeader5: MarkdownCriteria = {\n  ...paragraphStartBase,\n  export: createHeadingExport(5),\n  markdownFormatKind: 'paragraphH5',\n  regEx: /^##### /,\n  regExForAutoFormatting: /^##### /,\n}\n\nconst markdownHeader6: MarkdownCriteria = {\n  ...paragraphStartBase,\n  export: createHeadingExport(6),\n  markdownFormatKind: 'paragraphH6',\n  regEx: /^###### /,\n  regExForAutoFormatting: /^###### /,\n}\n\nconst markdownBlockQuote: MarkdownCriteria = {\n  ...paragraphStartBase,\n  export: blockQuoteExport,\n  markdownFormatKind: 'paragraphBlockQuote',\n  regEx: /^> /,\n  regExForAutoFormatting: /^> /,\n}\n\nconst markdownUnorderedListDash: MarkdownCriteria = {\n  ...paragraphStartBase,\n  export: listExport,\n  markdownFormatKind: 'paragraphUnorderedList',\n  regEx: /^(\\s{0,10})- /,\n  regExForAutoFormatting: /^(\\s{0,10})- /,\n}\n\nconst markdownUnorderedListAsterisk: MarkdownCriteria = {\n  ...paragraphStartBase,\n  export: listExport,\n  markdownFormatKind: 'paragraphUnorderedList',\n  regEx: /^(\\s{0,10})\\* /,\n  regExForAutoFormatting: /^(\\s{0,10})\\* /,\n}\n\nconst markdownOrderedList: MarkdownCriteria = {\n  ...paragraphStartBase,\n  export: listExport,\n  markdownFormatKind: 'paragraphOrderedList',\n  regEx: /^(\\s{0,10})(\\d+)\\.\\s/,\n  regExForAutoFormatting: /^(\\s{0,10})(\\d+)\\.\\s/,\n}\n\nconst markdownHorizontalRule: MarkdownCriteria = {\n  ...paragraphStartBase,\n  markdownFormatKind: 'horizontalRule',\n  regEx: /^\\*\\*\\*$/,\n  regExForAutoFormatting: /^\\*\\*\\* /,\n}\n\nconst markdownHorizontalRuleUsingDashes: MarkdownCriteria = {\n  ...paragraphStartBase,\n  markdownFormatKind: 'horizontalRule',\n  regEx: /^---$/,\n  regExForAutoFormatting: /^--- /,\n}\n\nconst markdownInlineCode: MarkdownCriteria = {\n  ...autoFormatBase,\n  exportFormat: 'code',\n  exportTag: '`',\n  markdownFormatKind: 'code',\n  regEx: /(`)(\\s*)([^`]*)(\\s*)(`)()/,\n  regExForAutoFormatting: /(`)(\\s*\\b)([^`]*)(\\b\\s*)(`)(\\s)$/,\n}\n\nconst markdownBold: MarkdownCriteria = {\n  ...autoFormatBase,\n  exportFormat: 'bold',\n  exportTag: '**',\n  markdownFormatKind: 'bold',\n  regEx: /(\\*\\*)(\\s*)([^*]*)(\\s*)(\\*\\*)()/,\n  regExForAutoFormatting: /(\\*\\*)(\\s*\\b)([^*]*)(\\b\\s*)(\\*\\*)(\\s)$/,\n}\n\nconst markdownItalic: MarkdownCriteria = {\n  ...autoFormatBase,\n  exportFormat: 'italic',\n  exportTag: '*',\n  markdownFormatKind: 'italic',\n  regEx: /(\\*)(\\s*)([^*]*)(\\s*)(\\*)()/,\n  regExForAutoFormatting: /(\\*)(\\s*\\b)([^*]*)(\\b\\s*)(\\*)(\\s)$/,\n}\n\nconst markdownBold2: MarkdownCriteria = {\n  ...autoFormatBase,\n  exportFormat: 'bold',\n  exportTag: '_',\n  markdownFormatKind: 'bold',\n  regEx: /(__)(\\s*)([^_]*)(\\s*)(__)()/,\n  regExForAutoFormatting: /(__)(\\s*)([^_]*)(\\s*)(__)(\\s)$/,\n}\n\nconst markdownItalic2: MarkdownCriteria = {\n  ...autoFormatBase,\n  exportFormat: 'italic',\n  exportTag: '_',\n  markdownFormatKind: 'italic',\n  regEx: /(_)()([^_]*)()(_)()/,\n  regExForAutoFormatting: /(_)()([^_]*)()(_)(\\s)$/, // Maintain 7 groups.\n}\n\nconst fakeMarkdownUnderline: MarkdownCriteria = {\n  ...autoFormatBase,\n  exportFormat: 'underline',\n  exportTag: '<u>',\n  exportTagClose: '</u>',\n  markdownFormatKind: 'underline',\n  regEx: /(<u>)(\\s*)([^<]*)(\\s*)(<\\/u>)()/,\n  regExForAutoFormatting: /(<u>)(\\s*\\b)([^<]*)(\\b\\s*)(<\\/u>)(\\s)$/,\n}\n\nconst markdownStrikethrough: MarkdownCriteria = {\n  ...autoFormatBase,\n  exportFormat: 'strikethrough',\n  exportTag: '~~',\n  markdownFormatKind: 'strikethrough',\n  regEx: /(~~)(\\s*)([^~]*)(\\s*)(~~)()/,\n  regExForAutoFormatting: /(~~)(\\s*\\b)([^~]*)(\\b\\s*)(~~)(\\s)$/,\n}\n\nconst markdownStrikethroughItalicBold: MarkdownCriteria = {\n  ...autoFormatBase,\n  markdownFormatKind: 'strikethrough_italic_bold',\n  regEx: /(~~_\\*\\*)(\\s*\\b)([^*_~]+)(\\b\\s*)(\\*\\*_~~)()/,\n  regExForAutoFormatting: /(~~_\\*\\*)(\\s*\\b)([^*_~]+)(\\b\\s*)(\\*\\*_~~)(\\s)$/,\n}\n\nconst markdownItalicbold: MarkdownCriteria = {\n  ...autoFormatBase,\n  markdownFormatKind: 'italic_bold',\n  regEx: /(_\\*\\*)(\\s*\\b)([^*_]+)(\\b\\s*)(\\*\\*_)/,\n  regExForAutoFormatting: /(_\\*\\*)(\\s*\\b)([^*_]+)(\\b\\s*)(\\*\\*_)(\\s)$/,\n}\n\nconst markdownStrikethroughItalic: MarkdownCriteria = {\n  ...autoFormatBase,\n  markdownFormatKind: 'strikethrough_italic',\n  regEx: /(~~_)(\\s*)([^_~]+)(\\s*)(_~~)/,\n  regExForAutoFormatting: /(~~_)(\\s*)([^_~]+)(\\s*)(_~~)(\\s)$/,\n}\n\nconst markdownStrikethroughBold: MarkdownCriteria = {\n  ...autoFormatBase,\n  markdownFormatKind: 'strikethrough_bold',\n  regEx: /(~~\\*\\*)(\\s*\\b)([^*~]+)(\\b\\s*)(\\*\\*~~)/,\n  regExForAutoFormatting: /(~~\\*\\*)(\\s*\\b)([^*~]+)(\\b\\s*)(\\*\\*~~)(\\s)$/,\n}\n\nconst markdownLink: MarkdownCriteria = {\n  ...autoFormatBase,\n  markdownFormatKind: 'link',\n  regEx: /(\\[)([^\\]]*)(\\]\\()([^)]*)(\\)*)()/,\n  regExForAutoFormatting: /(\\[)([^\\]]*)(\\]\\()([^)]*)(\\)*)(\\s)$/,\n}\n\nconst allMarkdownCriteriaForTextNodes: MarkdownCriteriaArray = [\n  // Place the combination formats ahead of the individual formats.\n  // Combos\n  markdownStrikethroughItalicBold,\n  markdownItalicbold,\n  markdownStrikethroughItalic,\n  markdownStrikethroughBold, // Individuals\n  markdownInlineCode,\n  markdownBold,\n  markdownItalic, // Must appear after markdownBold\n  markdownBold2,\n  markdownItalic2, // Must appear after markdownBold2.\n  fakeMarkdownUnderline,\n  markdownStrikethrough,\n  markdownLink,\n]\n\nconst allMarkdownCriteriaForParagraphs: MarkdownCriteriaArray = [\n  markdownHeader1,\n  markdownHeader2,\n  markdownHeader3,\n  markdownHeader4,\n  markdownHeader5,\n  markdownHeader6,\n  markdownBlockQuote,\n  markdownUnorderedListDash,\n  markdownUnorderedListAsterisk,\n  markdownOrderedList,\n  markdownHorizontalRule,\n  markdownHorizontalRuleUsingDashes,\n]\n\nexport function getAllMarkdownCriteriaForParagraphs(): MarkdownCriteriaArray {\n  return allMarkdownCriteriaForParagraphs\n}\n\nexport function getAllMarkdownCriteriaForTextNodes(): MarkdownCriteriaArray {\n  return allMarkdownCriteriaForTextNodes\n}\n\ntype Block = (\n  node: LexicalNode,\n  exportChildren: (elementNode: ElementNode) => string,\n) => null | string\n\nfunction createHeadingExport(level: number): Block {\n  return (node, exportChildren) => {\n    return $isHeadingNode(node) && node.getTag() === 'h' + level\n      ? '#'.repeat(level) + ' ' + exportChildren(node)\n      : null\n  }\n}\n\nfunction listExport(node: LexicalNode, exportChildren: (_node: ElementNode) => string) {\n  return $isListNode(node) ? processNestedLists(node, exportChildren, 0) : null\n}\n\n// TODO: should be param\nconst LIST_INDENT_SIZE = 4\n\nfunction processNestedLists(\n  listNode: ListNode,\n  exportChildren: (node: ElementNode) => string,\n  depth: number,\n): string {\n  const output: string[] = []\n  const children = listNode.getChildren()\n  let index = 0\n\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild()\n\n        if ($isListNode(firstChild)) {\n          output.push(processNestedLists(firstChild, exportChildren, depth + 1))\n          continue\n        }\n      }\n\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE)\n      const prefix = listNode.getListType() === 'bullet' ? '- ' : `${listNode.getStart() + index}. `\n      output.push(indent + prefix + exportChildren(listItemNode))\n      index++\n    }\n  }\n\n  return output.join('\\n')\n}\n\nfunction blockQuoteExport(node: LexicalNode, exportChildren: (_node: ElementNode) => string) {\n  return $isQuoteNode(node) ? '> ' + exportChildren(node) : null\n}\n\nexport function indexBy<T>(\n  list: Array<T>,\n  callback: (arg0: T) => string | undefined,\n): Readonly<Record<string, Array<T>>> {\n  const index: Record<string, Array<T>> = {}\n\n  for (const item of list) {\n    const key = callback(item)\n\n    if (!key) {\n      continue\n    }\n\n    if (index[key]) {\n      index[key].push(item)\n    } else {\n      index[key] = [item]\n    }\n  }\n\n  return index\n}\n\nexport function transformersByType(transformers: Array<Transformer>): Readonly<{\n  element: Array<ElementTransformer>\n  multilineElement: Array<MultilineElementTransformer>\n  textFormat: Array<TextFormatTransformer>\n  textMatch: Array<TextMatchTransformer>\n}> {\n  const byType = indexBy(transformers, (t) => t.type)\n\n  return {\n    element: (byType.element || []) as Array<ElementTransformer>,\n    multilineElement: (byType['multiline-element'] || []) as Array<MultilineElementTransformer>,\n    textFormat: (byType['text-format'] || []) as Array<TextFormatTransformer>,\n    textMatch: (byType['text-match'] || []) as Array<TextMatchTransformer>,\n  }\n}\n\nexport const PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/\n\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/\n\nexport function isEmptyParagraph(node: LexicalNode): boolean {\n  if (!$isParagraphNode(node)) {\n    return false\n  }\n\n  const firstChild = node.getFirstChild()\n  return (\n    firstChild == null ||\n    (node.getChildrenSize() === 1 &&\n      $isTextNode(firstChild) &&\n      MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent()))\n  )\n}\n"],"mappings":"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","ignoreList":[]}