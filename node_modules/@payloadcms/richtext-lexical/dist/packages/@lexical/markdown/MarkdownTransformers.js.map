{"version":3,"file":"MarkdownTransformers.js","names":["$createListItemNode","$createListNode","$isListItemNode","$isListNode","ListItemNode","ListNode","$createHeadingNode","$createQuoteNode","$isHeadingNode","$isQuoteNode","HeadingNode","QuoteNode","$createLineBreakNode","EMPTY_OR_WHITESPACE_ONLY","ORDERED_LIST_REGEX","UNORDERED_LIST_REGEX","CHECK_LIST_REGEX","HEADING_REGEX","QUOTE_REGEX","CODE_START_REGEX","CODE_END_REGEX","CODE_SINGLE_LINE_REGEX","TABLE_ROW_REG_EXP","TABLE_ROW_DIVIDER_REG_EXP","TAG_START_REGEX","TAG_END_REGEX","createBlockNode","createNode","parentNode","children","match","node","append","replace","select","LIST_INDENT_SIZE","getIndent","whitespaces","tabs","spaces","indent","length","Math","floor","listReplace","listType","previousNode","getPreviousSibling","nextNode","getNextSibling","listItem","undefined","getListType","firstChild","getFirstChild","insertBefore","remove","list","Number","setIndent","listExport","listNode","exportChildren","depth","output","getChildren","index","listItemNode","getChildrenSize","push","repeat","prefix","getStart","getChecked","join","HEADING","type","dependencies","export","level","getTag","slice","regExp","tag","QUOTE","lines","split","line","_match","isImport","splice","UNORDERED_LIST","CHECK_LIST","ORDERED_LIST","INLINE_CODE","format","HIGHLIGHT","BOLD_ITALIC_STAR","BOLD_ITALIC_UNDERSCORE","intraword","BOLD_STAR","BOLD_UNDERSCORE","STRIKETHROUGH","ITALIC_STAR","ITALIC_UNDERSCORE","normalizeMarkdown","input","shouldMergeAdjacentLines","inCodeBlock","sanitizedLines","nestedDeepCodeBlock","i","lastLine","test","trim"],"sources":["../../../../src/packages/@lexical/markdown/MarkdownTransformers.ts"],"sourcesContent":["/* eslint-disable regexp/no-unused-capturing-group */\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type { ListType } from '@lexical/list'\nimport type { HeadingTagType } from '@lexical/rich-text'\nimport type { ElementNode, Klass, LexicalNode, TextFormatType, TextNode } from 'lexical'\n\nimport {\n  $createListItemNode,\n  $createListNode,\n  $isListItemNode,\n  $isListNode,\n  ListItemNode,\n  ListNode,\n} from '@lexical/list'\nimport {\n  $createHeadingNode,\n  $createQuoteNode,\n  $isHeadingNode,\n  $isQuoteNode,\n  HeadingNode,\n  QuoteNode,\n} from '@lexical/rich-text'\nimport { $createLineBreakNode } from 'lexical'\n\nexport type Transformer =\n  | ElementTransformer\n  | MultilineElementTransformer\n  | TextFormatTransformer\n  | TextMatchTransformer\n\nexport type ElementTransformer = {\n  dependencies: Array<Klass<LexicalNode>>\n  /**\n   * `export` is called when the `$convertToMarkdownString` is called to convert the editor state into markdown.\n   *\n   * @return return null to cancel the export, even though the regex matched. Lexical will then search for the next transformer.\n   */\n  export: (\n    node: LexicalNode,\n\n    traverseChildren: (node: ElementNode) => string,\n  ) => null | string\n  regExp: RegExp\n  /**\n   * `replace` is called when markdown is imported or typed in the editor\n   *\n   * @return return false to cancel the transform, even though the regex matched. Lexical will then search for the next transformer.\n   */\n  replace: (\n    parentNode: ElementNode,\n    children: Array<LexicalNode>,\n    match: Array<string>,\n    /**\n     * Whether the match is from an import operation (e.g. through `$convertFromMarkdownString`) or not (e.g. through typing in the editor).\n     */\n    isImport: boolean,\n  ) => boolean | void\n  type: 'element'\n}\n\nexport type MultilineElementTransformer = {\n  dependencies: Array<Klass<LexicalNode>>\n  /**\n   * `export` is called when the `$convertToMarkdownString` is called to convert the editor state into markdown.\n   *\n   * @return return null to cancel the export, even though the regex matched. Lexical will then search for the next transformer.\n   */\n  export?: (\n    node: LexicalNode,\n\n    traverseChildren: (node: ElementNode) => string,\n  ) => null | string\n  /**\n   * Use this function to manually handle the import process, once the `regExpStart` has matched successfully.\n   * Without providing this function, the default behavior is to match until `regExpEnd` is found, or until the end of the document if `regExpEnd.optional` is true.\n   *\n   * @returns a tuple or null. The first element of the returned tuple is a boolean indicating if a multiline element was imported. The second element is the index of the last line that was processed. If null is returned, the next multilineElementTransformer will be tried. If undefined is returned, the default behavior will be used.\n   */\n  handleImportAfterStartMatch?: (args: {\n    lines: Array<string>\n    rootNode: ElementNode\n    startLineIndex: number\n    startMatch: RegExpMatchArray\n    transformer: MultilineElementTransformer\n  }) => [boolean, number] | null | undefined\n  /**\n   * This regex determines when to stop matching. Anything in between regExpStart and regExpEnd will be matched\n   */\n  regExpEnd?:\n    | {\n        /**\n         * Whether the end match is optional. If true, the end match is not required to match for the transformer to be triggered.\n         * The entire text from regexpStart to the end of the document will then be matched.\n         */\n        optional?: true\n        regExp: RegExp\n      }\n    | RegExp\n  /**\n   * This regex determines when to start matching\n   */\n  regExpStart: RegExp\n  /**\n   * `replace` is called only when markdown is imported in the editor, not when it's typed\n   *\n   * @return return false to cancel the transform, even though the regex matched. Lexical will then search for the next transformer.\n   */\n  replace: (\n    rootNode: ElementNode,\n    /**\n     * During markdown shortcut transforms, children nodes may be provided to the transformer. If this is the case, no `linesInBetween` will be provided and\n     * the children nodes should be used instead of the `linesInBetween` to create the new node.\n     */\n    children: Array<LexicalNode> | null,\n    startMatch: Array<string>,\n    endMatch: Array<string> | null,\n    /**\n     * linesInBetween includes the text between the start & end matches, split up by lines, not including the matches themselves.\n     * This is null when the transformer is triggered through markdown shortcuts (by typing in the editor)\n     */\n    linesInBetween: Array<string> | null,\n    /**\n     * Whether the match is from an import operation (e.g. through `$convertFromMarkdownString`) or not (e.g. through typing in the editor).\n     */\n    isImport: boolean,\n  ) => boolean | void\n  type: 'multiline-element'\n}\n\nexport type TextFormatTransformer = Readonly<{\n  format: ReadonlyArray<TextFormatType>\n  intraword?: boolean\n  tag: string\n  type: 'text-format'\n}>\n\nexport type TextMatchTransformer = Readonly<{\n  dependencies: Array<Klass<LexicalNode>>\n  /**\n   * Determines how a node should be exported to markdown\n   */\n  export?: (\n    node: LexicalNode,\n\n    exportChildren: (node: ElementNode) => string,\n\n    exportFormat: (node: TextNode, textContent: string) => string,\n  ) => null | string\n  /**\n   * For import operations, this function can be used to determine the end index of the match, after `importRegExp` has matched.\n   * Without this function, the end index will be determined by the length of the match from `importRegExp`. Manually determining the end index can be useful if\n   * the match from `importRegExp` is not the entire text content of the node. That way, `importRegExp` can be used to match only the start of the node, and `getEndIndex`\n   * can be used to match the end of the node.\n   *\n   * @returns The end index of the match, or false if the match was unsuccessful and a different transformer should be tried.\n   */\n  getEndIndex?: (node: TextNode, match: RegExpMatchArray) => false | number\n  /**\n   * This regex determines what text is matched during markdown imports\n   */\n  importRegExp?: RegExp\n  /**\n   * This regex determines what text is matched for markdown shortcuts while typing in the editor\n   */\n  regExp: RegExp\n  /**\n   * Determines how the matched markdown text should be transformed into a node during the markdown import process\n   *\n   * @returns nothing, or a TextNode that may be a child of the new node that is created.\n   * If a TextNode is returned, text format matching will be applied to it (e.g. bold, italic, etc.)\n   */\n  replace?: (node: TextNode, match: RegExpMatchArray) => TextNode | void\n  /**\n   * Single character that allows the transformer to trigger when typed in the editor. This does not affect markdown imports outside of the markdown shortcut plugin.\n   * If the trigger is matched, the `regExp` will be used to match the text in the second step.\n   */\n  trigger?: string\n  type: 'text-match'\n}>\n\nconst EMPTY_OR_WHITESPACE_ONLY = /^[\\t ]*$/\nconst ORDERED_LIST_REGEX = /^(\\s*)(\\d+)\\.\\s/\nconst UNORDERED_LIST_REGEX = /^(\\s*)[-*+]\\s/\nconst CHECK_LIST_REGEX = /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i\nconst HEADING_REGEX = /^(#{1,6})\\s/\nconst QUOTE_REGEX = /^>\\s/\nconst CODE_START_REGEX = /^[ \\t]*(\\\\`\\\\`\\\\`|```)(\\w+)?/\nconst CODE_END_REGEX = /[ \\t]*(\\\\`\\\\`\\\\`|```)$/\nconst CODE_SINGLE_LINE_REGEX = /^[ \\t]*```[^`]+(?:(?:`{1,2}|`{4,})[^`]+)*```(?:[^`]|$)/\nconst TABLE_ROW_REG_EXP = /^\\|(.+)\\|\\s?$/\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/\nconst TAG_START_REGEX = /^[ \\t]*<[a-z_][\\w-]*(?:\\s[^<>]*)?\\/?>/i\nconst TAG_END_REGEX = /^[ \\t]*<\\/[a-z_][\\w-]*\\s*>/i\n\nconst createBlockNode = (\n  createNode: (match: Array<string>) => ElementNode,\n): ElementTransformer['replace'] => {\n  return (parentNode, children, match) => {\n    const node = createNode(match)\n    node.append(...children)\n    parentNode.replace(node)\n    node.select(0, 0)\n  }\n}\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4\n\nfunction getIndent(whitespaces: string): number {\n  const tabs = whitespaces.match(/\\t/g)\n  const spaces = whitespaces.match(/ /g)\n\n  let indent = 0\n\n  if (tabs) {\n    indent += tabs.length\n  }\n\n  if (spaces) {\n    indent += Math.floor(spaces.length / LIST_INDENT_SIZE)\n  }\n\n  return indent\n}\n\nconst listReplace = (listType: ListType): ElementTransformer['replace'] => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling()\n    const nextNode = parentNode.getNextSibling()\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined)\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild()\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem)\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem)\n      }\n      parentNode.remove()\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem)\n      parentNode.remove()\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined)\n      list.append(listItem)\n      parentNode.replace(list)\n    }\n    listItem.append(...children)\n    listItem.select(0, 0)\n    const indent = getIndent(match[1]!)\n    if (indent) {\n      listItem.setIndent(indent)\n    }\n  }\n}\n\nconst listExport = (\n  listNode: ListNode,\n  exportChildren: (node: ElementNode) => string,\n  depth: number,\n): string => {\n  const output: string[] = []\n  const children = listNode.getChildren()\n  let index = 0\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild()\n        if ($isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1))\n          continue\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE)\n      const listType = listNode.getListType()\n      const prefix =\n        listType === 'number'\n          ? `${listNode.getStart() + index}. `\n          : listType === 'check'\n            ? `- [${listItemNode.getChecked() ? 'x' : ' '}] `\n            : '- '\n      output.push(indent + prefix + exportChildren(listItemNode))\n      index++\n    }\n  }\n\n  return output.join('\\n')\n}\n\nexport const HEADING: ElementTransformer = {\n  type: 'element',\n  dependencies: [HeadingNode],\n  export: (node, exportChildren) => {\n    if (!$isHeadingNode(node)) {\n      return null\n    }\n    const level = Number(node.getTag().slice(1))\n    return '#'.repeat(level) + ' ' + exportChildren(node)\n  },\n  regExp: HEADING_REGEX,\n  replace: createBlockNode((match) => {\n    const tag = ('h' + match[1]!.length) as HeadingTagType\n    return $createHeadingNode(tag)\n  }),\n}\n\nexport const QUOTE: ElementTransformer = {\n  type: 'element',\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null\n    }\n\n    const lines = exportChildren(node).split('\\n')\n    const output: string[] = []\n    for (const line of lines) {\n      output.push('> ' + line)\n    }\n    return output.join('\\n')\n  },\n  regExp: QUOTE_REGEX,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling()\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [\n          $createLineBreakNode(),\n          ...children,\n        ])\n        previousNode.select(0, 0)\n        parentNode.remove()\n        return\n      }\n    }\n\n    const node = $createQuoteNode()\n    node.append(...children)\n    parentNode.replace(node)\n    node.select(0, 0)\n  },\n}\n\nexport const UNORDERED_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: UNORDERED_LIST_REGEX,\n  replace: listReplace('bullet'),\n}\n\nexport const CHECK_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: CHECK_LIST_REGEX,\n  replace: listReplace('check'),\n}\n\nexport const ORDERED_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: ORDERED_LIST_REGEX,\n  replace: listReplace('number'),\n}\n\nexport const INLINE_CODE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['code'],\n  tag: '`',\n}\n\nexport const HIGHLIGHT: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['highlight'],\n  tag: '==',\n}\n\nexport const BOLD_ITALIC_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold', 'italic'],\n  tag: '***',\n}\n\nexport const BOLD_ITALIC_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n}\n\nexport const BOLD_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold'],\n  tag: '**',\n}\n\nexport const BOLD_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n}\n\nexport const STRIKETHROUGH: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['strikethrough'],\n  tag: '~~',\n}\n\nexport const ITALIC_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['italic'],\n  tag: '*',\n}\n\nexport const ITALIC_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n}\n\nexport function normalizeMarkdown(input: string, shouldMergeAdjacentLines: boolean): string {\n  const lines = input.split('\\n')\n  let inCodeBlock = false\n  const sanitizedLines: string[] = []\n  let nestedDeepCodeBlock = 0\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!\n    const lastLine = sanitizedLines[sanitizedLines.length - 1]\n\n    // Code blocks of ```single line``` don't toggle the inCodeBlock flag\n    if (CODE_SINGLE_LINE_REGEX.test(line)) {\n      sanitizedLines.push(line)\n      continue\n    }\n\n    if (CODE_END_REGEX.test(line)) {\n      if (nestedDeepCodeBlock === 0) {\n        inCodeBlock = true\n      }\n      if (nestedDeepCodeBlock === 1) {\n        inCodeBlock = false\n      }\n      if (nestedDeepCodeBlock > 0) {\n        nestedDeepCodeBlock--\n      }\n      sanitizedLines.push(line)\n      continue\n    }\n\n    // Toggle inCodeBlock state when encountering start or end of a code block\n    if (CODE_START_REGEX.test(line)) {\n      inCodeBlock = true\n      nestedDeepCodeBlock++\n      sanitizedLines.push(line)\n      continue\n    }\n\n    // If we are inside a code block, keep the line unchanged\n    if (inCodeBlock) {\n      sanitizedLines.push(line)\n      continue\n    }\n\n    // In markdown the concept of \"empty paragraphs\" does not exist.\n    // Blocks must be separated by an empty line. Non-empty adjacent lines must be merged.\n    if (\n      EMPTY_OR_WHITESPACE_ONLY.test(line) ||\n      EMPTY_OR_WHITESPACE_ONLY.test(lastLine!) ||\n      !lastLine ||\n      HEADING_REGEX.test(lastLine) ||\n      HEADING_REGEX.test(line) ||\n      QUOTE_REGEX.test(line) ||\n      ORDERED_LIST_REGEX.test(line) ||\n      UNORDERED_LIST_REGEX.test(line) ||\n      CHECK_LIST_REGEX.test(line) ||\n      TABLE_ROW_REG_EXP.test(line) ||\n      TABLE_ROW_DIVIDER_REG_EXP.test(line) ||\n      !shouldMergeAdjacentLines ||\n      TAG_START_REGEX.test(line) ||\n      TAG_END_REGEX.test(line) ||\n      TAG_START_REGEX.test(lastLine) ||\n      TAG_END_REGEX.test(lastLine) ||\n      CODE_END_REGEX.test(lastLine)\n    ) {\n      sanitizedLines.push(line)\n    } else {\n      sanitizedLines[sanitizedLines.length - 1] = lastLine + ' ' + line.trim()\n    }\n  }\n\n  return sanitizedLines.join('\\n')\n}\n"],"mappings":"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","ignoreList":[]}