{"version":3,"file":"MarkdownShortcuts.js","names":["$createRangeSelection","$getSelection","$isLineBreakNode","$isRangeSelection","$isRootOrShadowRoot","$isTextNode","$setSelection","TRANSFORMERS","indexBy","PUNCTUATION_OR_SPACE","transformersByType","runElementTransformers","parentNode","anchorNode","anchorOffset","elementTransformers","grandParentNode","getParent","getFirstChild","textContent","getTextContent","regExp","replace","match","length","endsWith","nextSiblings","getNextSiblings","leadingNode","remainderNode","splitText","remove","siblings","runMultilineElementTransformers","regExpEnd","regExpStart","optional","runTextMatchTransformers","transformersByTrigger","lastChar","transformers","slice","transformer","startIndex","index","endIndex","replaceNode","selectNext","$runTextFormatTransformers","textFormatTransformers","closeTagEndIndex","closeChar","matchers","matcher","tag","tagLength","closeTagStartIndex","isEqualSubString","afterCloseTagChar","intraword","test","closeNode","openNode","openTagStartIndex","getOpenTagStartIndex","sibling","getPreviousSibling","siblingTextContent","prevOpenNodeText","beforeOpenTagChar","prevCloseNodeText","closeNodeText","setTextContent","openNodeText","selection","nextSelection","newOffset","anchor","set","__key","focus","format","hasFormat","formatText","key","offset","type","toggleFormat","string","maxIndex","i","stringA","aStart","stringB","bStart","registerMarkdownShortcuts","editor","byType","textFormatTransformersByTrigger","textFormat","textMatchTransformersByTrigger","textMatch","trigger","dependencies","node","hasNode","Error","getType","$transform","element","multilineElement","registerUpdateListener","dirtyLeaves","editorState","prevEditorState","tags","has","isComposing","read","prevSelection","isCollapsed","is","anchorKey","_nodeMap","get","update"],"sources":["../../../../src/packages/@lexical/markdown/MarkdownShortcuts.ts"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type { ElementNode, LexicalEditor, TextNode } from 'lexical'\n\nimport {\n  $createRangeSelection,\n  $getSelection,\n  $isLineBreakNode,\n  $isRangeSelection,\n  $isRootOrShadowRoot,\n  $isTextNode,\n  $setSelection,\n} from 'lexical'\n\nimport type {\n  ElementTransformer,\n  MultilineElementTransformer,\n  TextFormatTransformer,\n  TextMatchTransformer,\n  Transformer,\n} from './MarkdownTransformers.js'\n\nimport { TRANSFORMERS } from './index.js'\nimport { indexBy, PUNCTUATION_OR_SPACE, transformersByType } from './utils.js'\n\nfunction runElementTransformers(\n  parentNode: ElementNode,\n  anchorNode: TextNode,\n  anchorOffset: number,\n  elementTransformers: ReadonlyArray<ElementTransformer>,\n): boolean {\n  const grandParentNode = parentNode.getParent()\n\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false\n  }\n\n  const textContent = anchorNode.getTextContent()\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false\n  }\n\n  for (const { regExp, replace } of elementTransformers) {\n    const match = textContent.match(regExp)\n\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings()\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset)\n      leadingNode?.remove()\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings\n      if (replace(parentNode, siblings, match, false) !== false) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction runMultilineElementTransformers(\n  parentNode: ElementNode,\n  anchorNode: TextNode,\n  anchorOffset: number,\n  elementTransformers: ReadonlyArray<MultilineElementTransformer>,\n): boolean {\n  const grandParentNode = parentNode.getParent()\n\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false\n  }\n\n  const textContent = anchorNode.getTextContent()\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false\n  }\n\n  for (const { regExpEnd, regExpStart, replace } of elementTransformers) {\n    if (\n      (regExpEnd && !('optional' in regExpEnd)) ||\n      (regExpEnd && 'optional' in regExpEnd && !regExpEnd.optional)\n    ) {\n      continue\n    }\n\n    const match = textContent.match(regExpStart)\n\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings()\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset)\n      leadingNode?.remove()\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings\n\n      if (replace(parentNode, siblings, match, null, null, false) !== false) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction runTextMatchTransformers(\n  anchorNode: TextNode,\n  anchorOffset: number,\n  transformersByTrigger: Readonly<Record<string, Array<TextMatchTransformer>>>,\n): boolean {\n  let textContent = anchorNode.getTextContent()\n  const lastChar = textContent[anchorOffset - 1]!\n  const transformers = transformersByTrigger[lastChar]\n\n  if (transformers == null) {\n    return false\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset)\n  }\n\n  for (const transformer of transformers) {\n    if (!transformer.replace || !transformer.regExp) {\n      continue\n    }\n    const match = textContent.match(transformer.regExp)\n\n    if (match === null) {\n      continue\n    }\n\n    const startIndex = match.index || 0\n    const endIndex = startIndex + match[0].length\n    let replaceNode\n\n    if (startIndex === 0) {\n      ;[replaceNode] = anchorNode.splitText(endIndex)\n    } else {\n      ;[, replaceNode] = anchorNode.splitText(startIndex, endIndex)\n    }\n    if (replaceNode) {\n      replaceNode.selectNext(0, 0)\n      transformer.replace(replaceNode, match)\n    }\n    return true\n  }\n\n  return false\n}\n\nfunction $runTextFormatTransformers(\n  anchorNode: TextNode,\n  anchorOffset: number,\n  textFormatTransformers: Readonly<Record<string, ReadonlyArray<TextFormatTransformer>>>,\n): boolean {\n  const textContent = anchorNode.getTextContent()\n  const closeTagEndIndex = anchorOffset - 1\n  const closeChar = textContent[closeTagEndIndex]!\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar]\n\n  if (!matchers) {\n    return false\n  }\n\n  for (const matcher of matchers) {\n    const { tag } = matcher\n    const tagLength = tag.length\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1]\n\n    if (\n      matcher.intraword === false &&\n      afterCloseTagChar &&\n      !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)\n    ) {\n      continue\n    }\n\n    const closeNode = anchorNode\n    let openNode = closeNode\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag)\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling: null | TextNode = openNode\n\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling<TextNode>())) {\n      if ($isLineBreakNode(sibling)) {\n        break\n      }\n\n      if ($isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent()\n        openNode = sibling\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag)\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent()\n\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1]\n\n    if (\n      matcher.intraword === false &&\n      beforeOpenTagChar &&\n      !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)\n    ) {\n      continue\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent()\n    const closeNodeText =\n      prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1)\n    closeNode.setTextContent(closeNodeText)\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText\n    openNode.setTextContent(\n      openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength),\n    )\n    const selection = $getSelection()\n    const nextSelection = $createRangeSelection()\n    $setSelection(nextSelection)\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text')\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text')\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format)\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(\n      nextSelection.focus.key,\n      nextSelection.focus.offset,\n      nextSelection.focus.type,\n    )\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format)\n      }\n    }\n\n    if ($isRangeSelection(selection)) {\n      nextSelection.format = selection.format\n    }\n\n    return true\n  }\n\n  return false\n}\n\nfunction getOpenTagStartIndex(string: string, maxIndex: number, tag: string): number {\n  const tagLength = tag.length\n\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength\n\n    if (\n      isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation\n      string[startIndex + tagLength] !== ' '\n    ) {\n      return startIndex\n    }\n  }\n\n  return -1\n}\n\nfunction isEqualSubString(\n  stringA: string,\n  aStart: number,\n  stringB: string,\n  bStart: number,\n  length: number,\n): boolean {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function registerMarkdownShortcuts(\n  editor: LexicalEditor,\n  transformers: Array<Transformer> = TRANSFORMERS,\n): () => void {\n  const byType = transformersByType(transformers)\n  const textFormatTransformersByTrigger = indexBy(\n    byType.textFormat,\n    ({ tag }) => tag[tag.length - 1],\n  )\n  const textMatchTransformersByTrigger = indexBy(byType.textMatch, ({ trigger }) => trigger)\n\n  for (const transformer of transformers) {\n    const type = transformer.type\n    if (type === 'element' || type === 'text-match' || type === 'multiline-element') {\n      const dependencies = transformer.dependencies\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          throw new Error(\n            'MarkdownShortcuts: missing dependency %s for transformer. Ensure node dependency is included in editor initial config.' +\n              node.getType(),\n          )\n        }\n      }\n    }\n  }\n\n  const $transform = (parentNode: ElementNode, anchorNode: TextNode, anchorOffset: number) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return\n    }\n\n    if (\n      runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, byType.multilineElement)\n    ) {\n      return\n    }\n\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersByTrigger)) {\n      return\n    }\n\n    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersByTrigger)\n  }\n\n  return editor.registerUpdateListener(({ dirtyLeaves, editorState, prevEditorState, tags }) => {\n    // Ignore updates from collaboration and undo/redo (as changes already calculated)\n    if (tags.has('collaboration') || tags.has('historic')) {\n      return\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return\n    }\n\n    const selection = editorState.read($getSelection)\n    const prevSelection = prevEditorState.read($getSelection)\n\n    // We expect selection to be a collapsed range and not match previous one (as we want\n    // to trigger transforms only as user types)\n    if (\n      !$isRangeSelection(prevSelection) ||\n      !$isRangeSelection(selection) ||\n      !selection.isCollapsed() ||\n      selection.is(prevSelection)\n    ) {\n      return\n    }\n\n    const anchorKey = selection.anchor.key\n    const anchorOffset = selection.anchor.offset\n\n    const anchorNode = editorState._nodeMap.get(anchorKey)\n\n    if (\n      !$isTextNode(anchorNode) ||\n      !dirtyLeaves.has(anchorKey) ||\n      (anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1)\n    ) {\n      return\n    }\n\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return\n      }\n\n      const parentNode = anchorNode.getParent()\n\n      if (parentNode === null) {\n        return\n      }\n\n      $transform(parentNode, anchorNode, selection.anchor.offset)\n    })\n  })\n}\n"],"mappings":"AAAA;;;;;;GAUA,SACEA,qBAAqB,EACrBC,aAAa,EACbC,gBAAgB,EAChBC,iBAAiB,EACjBC,mBAAmB,EACnBC,WAAW,EACXC,aAAa,QACR;AAUP,SAASC,YAAY,QAAQ;AAC7B,SAASC,OAAO,EAAEC,oBAAoB,EAAEC,kBAAkB,QAAQ;AAElE,SAASC,uBACPC,UAAuB,EACvBC,UAAoB,EACpBC,YAAoB,EACpBC,mBAAsD;EAEtD,MAAMC,eAAA,GAAkBJ,UAAA,CAAWK,SAAS;EAE5C,IAAI,CAACb,mBAAA,CAAoBY,eAAA,KAAoBJ,UAAA,CAAWM,aAAa,OAAOL,UAAA,EAAY;IACtF,OAAO;EACT;EAEA,MAAMM,WAAA,GAAcN,UAAA,CAAWO,cAAc;EAE7C;EACA;EACA;EACA;EACA;EACA;EACA,IAAID,WAAW,CAACL,YAAA,GAAe,EAAE,KAAK,KAAK;IACzC,OAAO;EACT;EAEA,KAAK,MAAM;IAAEO,MAAM;IAAEC;EAAO,CAAE,IAAIP,mBAAA,EAAqB;IACrD,MAAMQ,KAAA,GAAQJ,WAAA,CAAYI,KAAK,CAACF,MAAA;IAEhC,IAAIE,KAAA,IAASA,KAAK,CAAC,EAAE,CAACC,MAAM,MAAMD,KAAK,CAAC,EAAE,CAACE,QAAQ,CAAC,OAAOX,YAAA,GAAeA,YAAA,GAAe,IAAI;MAC3F,MAAMY,YAAA,GAAeb,UAAA,CAAWc,eAAe;MAC/C,MAAM,CAACC,WAAA,EAAaC,aAAA,CAAc,GAAGhB,UAAA,CAAWiB,SAAS,CAAChB,YAAA;MAC1Dc,WAAA,EAAaG,MAAA;MACb,MAAMC,QAAA,GAAWH,aAAA,GAAgB,CAACA,aAAA,E,GAAkBH,YAAA,CAAa,GAAGA,YAAA;MACpE,IAAIJ,OAAA,CAAQV,UAAA,EAAYoB,QAAA,EAAUT,KAAA,EAAO,WAAW,OAAO;QACzD,OAAO;MACT;IACF;EACF;EAEA,OAAO;AACT;AAEA,SAASU,gCACPrB,UAAuB,EACvBC,UAAoB,EACpBC,YAAoB,EACpBC,mBAA+D;EAE/D,MAAMC,eAAA,GAAkBJ,UAAA,CAAWK,SAAS;EAE5C,IAAI,CAACb,mBAAA,CAAoBY,eAAA,KAAoBJ,UAAA,CAAWM,aAAa,OAAOL,UAAA,EAAY;IACtF,OAAO;EACT;EAEA,MAAMM,WAAA,GAAcN,UAAA,CAAWO,cAAc;EAE7C;EACA;EACA;EACA;EACA;EACA;EACA,IAAID,WAAW,CAACL,YAAA,GAAe,EAAE,KAAK,KAAK;IACzC,OAAO;EACT;EAEA,KAAK,MAAM;IAAEoB,SAAS;IAAEC,WAAW;IAAEb;EAAO,CAAE,IAAIP,mBAAA,EAAqB;IACrE,IACEmB,SAAC,IAAa,EAAE,cAAcA,SAAQ,KACrCA,SAAA,IAAa,cAAcA,SAAA,IAAa,CAACA,SAAA,CAAUE,QAAQ,EAC5D;MACA;IACF;IAEA,MAAMb,KAAA,GAAQJ,WAAA,CAAYI,KAAK,CAACY,WAAA;IAEhC,IAAIZ,KAAA,IAASA,KAAK,CAAC,EAAE,CAACC,MAAM,MAAMD,KAAK,CAAC,EAAE,CAACE,QAAQ,CAAC,OAAOX,YAAA,GAAeA,YAAA,GAAe,IAAI;MAC3F,MAAMY,YAAA,GAAeb,UAAA,CAAWc,eAAe;MAC/C,MAAM,CAACC,WAAA,EAAaC,aAAA,CAAc,GAAGhB,UAAA,CAAWiB,SAAS,CAAChB,YAAA;MAC1Dc,WAAA,EAAaG,MAAA;MACb,MAAMC,QAAA,GAAWH,aAAA,GAAgB,CAACA,aAAA,E,GAAkBH,YAAA,CAAa,GAAGA,YAAA;MAEpE,IAAIJ,OAAA,CAAQV,UAAA,EAAYoB,QAAA,EAAUT,KAAA,EAAO,MAAM,MAAM,WAAW,OAAO;QACrE,OAAO;MACT;IACF;EACF;EAEA,OAAO;AACT;AAEA,SAASc,yBACPxB,UAAoB,EACpBC,YAAoB,EACpBwB,qBAA4E;EAE5E,IAAInB,WAAA,GAAcN,UAAA,CAAWO,cAAc;EAC3C,MAAMmB,QAAA,GAAWpB,WAAW,CAACL,YAAA,GAAe,EAAE;EAC9C,MAAM0B,YAAA,GAAeF,qBAAqB,CAACC,QAAA,CAAS;EAEpD,IAAIC,YAAA,IAAgB,MAAM;IACxB,OAAO;EACT;EAEA;EACA;EACA,IAAI1B,YAAA,GAAeK,WAAA,CAAYK,MAAM,EAAE;IACrCL,WAAA,GAAcA,WAAA,CAAYsB,KAAK,CAAC,GAAG3B,YAAA;EACrC;EAEA,KAAK,MAAM4B,WAAA,IAAeF,YAAA,EAAc;IACtC,IAAI,CAACE,WAAA,CAAYpB,OAAO,IAAI,CAACoB,WAAA,CAAYrB,MAAM,EAAE;MAC/C;IACF;IACA,MAAME,KAAA,GAAQJ,WAAA,CAAYI,KAAK,CAACmB,WAAA,CAAYrB,MAAM;IAElD,IAAIE,KAAA,KAAU,MAAM;MAClB;IACF;IAEA,MAAMoB,UAAA,GAAapB,KAAA,CAAMqB,KAAK,IAAI;IAClC,MAAMC,QAAA,GAAWF,UAAA,GAAapB,KAAK,CAAC,EAAE,CAACC,MAAM;IAC7C,IAAIsB,WAAA;IAEJ,IAAIH,UAAA,KAAe,GAAG;MACnB,CAACG,WAAA,CAAY,GAAGjC,UAAA,CAAWiB,SAAS,CAACe,QAAA;IACxC,OAAO;MACJ,GAAGC,WAAA,CAAY,GAAGjC,UAAA,CAAWiB,SAAS,CAACa,UAAA,EAAYE,QAAA;IACtD;IACA,IAAIC,WAAA,EAAa;MACfA,WAAA,CAAYC,UAAU,CAAC,GAAG;MAC1BL,WAAA,CAAYpB,OAAO,CAACwB,WAAA,EAAavB,KAAA;IACnC;IACA,OAAO;EACT;EAEA,OAAO;AACT;AAEA,SAASyB,2BACPnC,UAAoB,EACpBC,YAAoB,EACpBmC,sBAAsF;EAEtF,MAAM9B,WAAA,GAAcN,UAAA,CAAWO,cAAc;EAC7C,MAAM8B,gBAAA,GAAmBpC,YAAA,GAAe;EACxC,MAAMqC,SAAA,GAAYhC,WAAW,CAAC+B,gBAAA,CAAiB;EAC/C;EACA,MAAME,QAAA,GAAWH,sBAAsB,CAACE,SAAA,CAAU;EAElD,IAAI,CAACC,QAAA,EAAU;IACb,OAAO;EACT;EAEA,KAAK,MAAMC,OAAA,IAAWD,QAAA,EAAU;IAC9B,MAAM;MAAEE;IAAG,CAAE,GAAGD,OAAA;IAChB,MAAME,SAAA,GAAYD,GAAA,CAAI9B,MAAM;IAC5B,MAAMgC,kBAAA,GAAqBN,gBAAA,GAAmBK,SAAA,GAAY;IAE1D;IACA,IAAIA,SAAA,GAAY,GAAG;MACjB,IAAI,CAACE,gBAAA,CAAiBtC,WAAA,EAAaqC,kBAAA,EAAoBF,GAAA,EAAK,GAAGC,SAAA,GAAY;QACzE;MACF;IACF;IAEA;IACA,IAAIpC,WAAW,CAACqC,kBAAA,GAAqB,EAAE,KAAK,KAAK;MAC/C;IACF;IAEA;IACA,MAAME,iBAAA,GAAoBvC,WAAW,CAAC+B,gBAAA,GAAmB,EAAE;IAE3D,IACEG,OAAA,CAAQM,SAAS,KAAK,SACtBD,iBAAA,IACA,CAACjD,oBAAA,CAAqBmD,IAAI,CAACF,iBAAA,GAC3B;MACA;IACF;IAEA,MAAMG,SAAA,GAAYhD,UAAA;IAClB,IAAIiD,QAAA,GAAWD,SAAA;IACf,IAAIE,iBAAA,GAAoBC,oBAAA,CAAqB7C,WAAA,EAAaqC,kBAAA,EAAoBF,GAAA;IAE9E;IACA;IACA,IAAIW,OAAA,GAA2BH,QAAA;IAE/B,OAAOC,iBAAA,GAAoB,MAAME,OAAA,GAAUA,OAAA,CAAQC,kBAAkB,EAAW,GAAI;MAClF,IAAIhE,gBAAA,CAAiB+D,OAAA,GAAU;QAC7B;MACF;MAEA,IAAI5D,WAAA,CAAY4D,OAAA,GAAU;QACxB,MAAME,kBAAA,GAAqBF,OAAA,CAAQ7C,cAAc;QACjD0C,QAAA,GAAWG,OAAA;QACXF,iBAAA,GAAoBC,oBAAA,CAAqBG,kBAAA,EAAoBA,kBAAA,CAAmB3C,MAAM,EAAE8B,GAAA;MAC1F;IACF;IAEA;IACA,IAAIS,iBAAA,GAAoB,GAAG;MACzB;IACF;IAEA;IACA,IAAID,QAAA,KAAaD,SAAA,IAAaE,iBAAA,GAAoBR,SAAA,KAAcC,kBAAA,EAAoB;MAClF;IACF;IAEA;IACA,MAAMY,gBAAA,GAAmBN,QAAA,CAAS1C,cAAc;IAEhD,IAAI2C,iBAAA,GAAoB,KAAKK,gBAAgB,CAACL,iBAAA,GAAoB,EAAE,KAAKZ,SAAA,EAAW;MAClF;IACF;IAEA;IACA,MAAMkB,iBAAA,GAAoBD,gBAAgB,CAACL,iBAAA,GAAoB,EAAE;IAEjE,IACEV,OAAA,CAAQM,SAAS,KAAK,SACtBU,iBAAA,IACA,CAAC5D,oBAAA,CAAqBmD,IAAI,CAACS,iBAAA,GAC3B;MACA;IACF;IAEA;IACA;IACA,MAAMC,iBAAA,GAAoBT,SAAA,CAAUzC,cAAc;IAClD,MAAMmD,aAAA,GACJD,iBAAA,CAAkB7B,KAAK,CAAC,GAAGe,kBAAA,IAAsBc,iBAAA,CAAkB7B,KAAK,CAACS,gBAAA,GAAmB;IAC9FW,SAAA,CAAUW,cAAc,CAACD,aAAA;IACzB,MAAME,YAAA,GAAeX,QAAA,KAAaD,SAAA,GAAYU,aAAA,GAAgBH,gBAAA;IAC9DN,QAAA,CAASU,cAAc,CACrBC,YAAA,CAAahC,KAAK,CAAC,GAAGsB,iBAAA,IAAqBU,YAAA,CAAahC,KAAK,CAACsB,iBAAA,GAAoBR,SAAA;IAEpF,MAAMmB,SAAA,GAAYzE,aAAA;IAClB,MAAM0E,aAAA,GAAgB3E,qBAAA;IACtBM,aAAA,CAAcqE,aAAA;IACd;IACA,MAAMC,SAAA,GAAY1B,gBAAA,GAAmBK,SAAA,IAAaO,QAAA,KAAaD,SAAA,GAAY,IAAI,KAAK;IACpFc,aAAA,CAAcE,MAAM,CAACC,GAAG,CAAChB,QAAA,CAASiB,KAAK,EAAEhB,iBAAA,EAAmB;IAC5DY,aAAA,CAAcK,KAAK,CAACF,GAAG,CAACjB,SAAA,CAAUkB,KAAK,EAAEH,SAAA,EAAW;IAEpD;IACA,KAAK,MAAMK,MAAA,IAAU5B,OAAA,CAAQ4B,MAAM,EAAE;MACnC,IAAI,CAACN,aAAA,CAAcO,SAAS,CAACD,MAAA,GAAS;QACpCN,aAAA,CAAcQ,UAAU,CAACF,MAAA;MAC3B;IACF;IAEA;IACAN,aAAA,CAAcE,MAAM,CAACC,GAAG,CACtBH,aAAA,CAAcK,KAAK,CAACI,GAAG,EACvBT,aAAA,CAAcK,KAAK,CAACK,MAAM,EAC1BV,aAAA,CAAcK,KAAK,CAACM,IAAI;IAG1B;IACA,KAAK,MAAML,MAAA,IAAU5B,OAAA,CAAQ4B,MAAM,EAAE;MACnC,IAAIN,aAAA,CAAcO,SAAS,CAACD,MAAA,GAAS;QACnCN,aAAA,CAAcY,YAAY,CAACN,MAAA;MAC7B;IACF;IAEA,IAAI9E,iBAAA,CAAkBuE,SAAA,GAAY;MAChCC,aAAA,CAAcM,MAAM,GAAGP,SAAA,CAAUO,MAAM;IACzC;IAEA,OAAO;EACT;EAEA,OAAO;AACT;AAEA,SAASjB,qBAAqBwB,MAAc,EAAEC,QAAgB,EAAEnC,GAAW;EACzE,MAAMC,SAAA,GAAYD,GAAA,CAAI9B,MAAM;EAE5B,KAAK,IAAIkE,CAAA,GAAID,QAAA,EAAUC,CAAA,IAAKnC,SAAA,EAAWmC,CAAA,IAAK;IAC1C,MAAM/C,UAAA,GAAa+C,CAAA,GAAInC,SAAA;IAEvB,IACEE,gBAAA,CAAiB+B,MAAA,EAAQ7C,UAAA,EAAYW,GAAA,EAAK,GAAGC,SAAA;IAAc;IAC3DiC,MAAM,CAAC7C,UAAA,GAAaY,SAAA,CAAU,KAAK,KACnC;MACA,OAAOZ,UAAA;IACT;EACF;EAEA,OAAO,CAAC;AACV;AAEA,SAASc,iBACPkC,OAAe,EACfC,MAAc,EACdC,OAAe,EACfC,MAAc,EACdtE,MAAc;EAEd,KAAK,IAAIkE,CAAA,GAAI,GAAGA,CAAA,GAAIlE,MAAA,EAAQkE,CAAA,IAAK;IAC/B,IAAIC,OAAO,CAACC,MAAA,GAASF,CAAA,CAAE,KAAKG,OAAO,CAACC,MAAA,GAASJ,CAAA,CAAE,EAAE;MAC/C,OAAO;IACT;EACF;EAEA,OAAO;AACT;AAEA,OAAO,SAASK,0BACdC,MAAqB,EACrBxD,YAAA,GAAmCjC,YAAY;EAE/C,MAAM0F,MAAA,GAASvF,kBAAA,CAAmB8B,YAAA;EAClC,MAAM0D,+BAAA,GAAkC1F,OAAA,CACtCyF,MAAA,CAAOE,UAAU,EACjB,CAAC;IAAE7C;EAAG,CAAE,KAAKA,GAAG,CAACA,GAAA,CAAI9B,MAAM,GAAG,EAAE;EAElC,MAAM4E,8BAAA,GAAiC5F,OAAA,CAAQyF,MAAA,CAAOI,SAAS,EAAE,CAAC;IAAEC;EAAO,CAAE,KAAKA,OAAA;EAElF,KAAK,MAAM5D,WAAA,IAAeF,YAAA,EAAc;IACtC,MAAM8C,IAAA,GAAO5C,WAAA,CAAY4C,IAAI;IAC7B,IAAIA,IAAA,KAAS,aAAaA,IAAA,KAAS,gBAAgBA,IAAA,KAAS,qBAAqB;MAC/E,MAAMiB,YAAA,GAAe7D,WAAA,CAAY6D,YAAY;MAC7C,KAAK,MAAMC,IAAA,IAAQD,YAAA,EAAc;QAC/B,IAAI,CAACP,MAAA,CAAOS,OAAO,CAACD,IAAA,GAAO;UACzB,MAAM,IAAIE,KAAA,CACR,2HACEF,IAAA,CAAKG,OAAO;QAElB;MACF;IACF;EACF;EAEA,MAAMC,UAAA,GAAaA,CAAChG,UAAA,EAAyBC,UAAA,EAAsBC,YAAA;IACjE,IAAIH,sBAAA,CAAuBC,UAAA,EAAYC,UAAA,EAAYC,YAAA,EAAcmF,MAAA,CAAOY,OAAO,GAAG;MAChF;IACF;IAEA,IACE5E,+BAAA,CAAgCrB,UAAA,EAAYC,UAAA,EAAYC,YAAA,EAAcmF,MAAA,CAAOa,gBAAgB,GAC7F;MACA;IACF;IAEA,IAAIzE,wBAAA,CAAyBxB,UAAA,EAAYC,YAAA,EAAcsF,8BAAA,GAAiC;MACtF;IACF;IAEApD,0BAAA,CAA2BnC,UAAA,EAAYC,YAAA,EAAcoF,+BAAA;EACvD;EAEA,OAAOF,MAAA,CAAOe,sBAAsB,CAAC,CAAC;IAAEC,WAAW;IAAEC,WAAW;IAAEC,eAAe;IAAEC;EAAI,CAAE;IACvF;IACA,IAAIA,IAAA,CAAKC,GAAG,CAAC,oBAAoBD,IAAA,CAAKC,GAAG,CAAC,aAAa;MACrD;IACF;IAEA;IACA,IAAIpB,MAAA,CAAOqB,WAAW,IAAI;MACxB;IACF;IAEA,MAAM3C,SAAA,GAAYuC,WAAA,CAAYK,IAAI,CAACrH,aAAA;IACnC,MAAMsH,aAAA,GAAgBL,eAAA,CAAgBI,IAAI,CAACrH,aAAA;IAE3C;IACA;IACA,IACE,CAACE,iBAAA,CAAkBoH,aAAA,KACnB,CAACpH,iBAAA,CAAkBuE,SAAA,KACnB,CAACA,SAAA,CAAU8C,WAAW,MACtB9C,SAAA,CAAU+C,EAAE,CAACF,aAAA,GACb;MACA;IACF;IAEA,MAAMG,SAAA,GAAYhD,SAAA,CAAUG,MAAM,CAACO,GAAG;IACtC,MAAMtE,YAAA,GAAe4D,SAAA,CAAUG,MAAM,CAACQ,MAAM;IAE5C,MAAMxE,UAAA,GAAaoG,WAAA,CAAYU,QAAQ,CAACC,GAAG,CAACF,SAAA;IAE5C,IACE,CAACrH,WAAA,CAAYQ,UAAA,KACb,CAACmG,WAAA,CAAYI,GAAG,CAACM,SAAA,KAChB5G,YAAA,KAAiB,KAAKA,YAAA,GAAeyG,aAAA,CAAc1C,MAAM,CAACQ,MAAM,GAAG,GACpE;MACA;IACF;IAEAW,MAAA,CAAO6B,MAAM,CAAC;MACZ;MACA,IAAIhH,UAAA,CAAWqE,SAAS,CAAC,SAAS;QAChC;MACF;MAEA,MAAMtE,UAAA,GAAaC,UAAA,CAAWI,SAAS;MAEvC,IAAIL,UAAA,KAAe,MAAM;QACvB;MACF;MAEAgG,UAAA,CAAWhG,UAAA,EAAYC,UAAA,EAAY6D,SAAA,CAAUG,MAAM,CAACQ,MAAM;IAC5D;EACF;AACF","ignoreList":[]}