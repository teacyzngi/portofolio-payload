{"version":3,"file":"importTextFormatTransformer.js","names":["PUNCTUATION_OR_SPACE","findOutermostTextFormatTransformer","textNode","textFormatTransformersIndex","textContent","getTextContent","match","findOutermostMatch","textFormatMatchStart","index","textFormatMatchEnd","length","transformer","transformersByTag","endIndex","startIndex","textTransformersIndex","openTagsMatch","openTagsRegExp","tag","replace","fullMatchRegExp","fullMatchRegExpByTag","fullMatch","intraword","beforeChar","afterChar","test","importTextFormatTransformer","nodeAfter","nodeBefore","transformedNode","splitText","setTextContent","format","hasFormat","toggleFormat"],"sources":["../../../../src/packages/@lexical/markdown/importTextFormatTransformer.ts"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type { TextNode } from 'lexical'\n\nimport type { TextFormatTransformersIndex } from './MarkdownImport.js'\nimport type { TextFormatTransformer } from './MarkdownTransformers.js'\n\nimport { PUNCTUATION_OR_SPACE } from './utils.js'\n\nexport function findOutermostTextFormatTransformer(\n  textNode: TextNode,\n  textFormatTransformersIndex: TextFormatTransformersIndex,\n): {\n  endIndex: number\n  match: RegExpMatchArray\n  startIndex: number\n  transformer: TextFormatTransformer\n} | null {\n  const textContent = textNode.getTextContent()\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex)\n\n  if (!match) {\n    return null\n  }\n\n  const textFormatMatchStart: number = match.index || 0\n  const textFormatMatchEnd = textFormatMatchStart + match[0].length\n\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  const transformer: TextFormatTransformer = textFormatTransformersIndex.transformersByTag[match[1]]\n\n  return {\n    endIndex: textFormatMatchEnd,\n    match,\n    startIndex: textFormatMatchStart,\n    transformer,\n  }\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(\n  textContent: string,\n  textTransformersIndex: TextFormatTransformersIndex,\n): null | RegExpMatchArray {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp)\n\n  if (openTagsMatch == null) {\n    return null\n  }\n\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '')\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag]\n    if (fullMatchRegExp == null) {\n      continue\n    }\n\n    const fullMatch = textContent.match(fullMatchRegExp)\n    const transformer = textTransformersIndex.transformersByTag[tag]\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const { index = 0 } = fullMatch\n      const beforeChar = textContent[index - 1]\n      const afterChar = textContent[index + fullMatch[0].length]\n\n      if (\n        (!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) &&\n        (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))\n      ) {\n        return fullMatch\n      }\n    }\n  }\n\n  return null\n}\n\nexport function importTextFormatTransformer(\n  textNode: TextNode,\n  startIndex: number,\n  endIndex: number,\n  transformer: TextFormatTransformer,\n  match: RegExpMatchArray,\n): {\n  nodeAfter: TextNode | undefined // If split\n  nodeBefore: TextNode | undefined // If split\n  transformedNode: TextNode\n} {\n  const textContent = textNode.getTextContent()\n\n  // No text matches - we can safely process the text format match\n  let nodeAfter: TextNode | undefined\n  let nodeBefore: TextNode | undefined\n  let transformedNode: TextNode\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    transformedNode = textNode\n  } else {\n    if (startIndex === 0) {\n      ;[transformedNode, nodeAfter] = textNode.splitText(endIndex) as [\n        TextNode,\n        TextNode | undefined,\n      ]\n    } else {\n      ;[nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex) as [\n        TextNode,\n        TextNode,\n        TextNode | undefined,\n      ]\n    }\n  }\n\n  transformedNode.setTextContent(match[2]!)\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!transformedNode.hasFormat(format)) {\n        transformedNode.toggleFormat(format)\n      }\n    }\n  }\n\n  return {\n    nodeAfter,\n    nodeBefore,\n    transformedNode,\n  }\n}\n"],"mappings":"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","ignoreList":[]}