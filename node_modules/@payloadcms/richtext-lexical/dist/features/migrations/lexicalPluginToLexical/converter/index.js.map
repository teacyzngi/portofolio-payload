{"version":3,"file":"index.js","names":["convertLexicalPluginToLexical","converters","lexicalPluginData","quiet","root","type","children","convertLexicalPluginNodesToLexical","lexicalPluginNodes","jsonContent","parentNodeType","direction","format","indent","version","length","unknownConverter","find","converter","nodeTypes","includes","map","lexicalPluginNode","i","convertParagraphNode","convertTextNode","childIndex","console","warn","node"],"sources":["../../../../../src/features/migrations/lexicalPluginToLexical/converter/index.ts"],"sourcesContent":["import type {\n  SerializedEditorState,\n  SerializedLexicalNode,\n  SerializedParagraphNode,\n  SerializedTextNode,\n} from 'lexical'\n\nimport type { LexicalPluginNodeConverter, PayloadPluginLexicalData } from './types.js'\n\nexport function convertLexicalPluginToLexical({\n  converters,\n  lexicalPluginData,\n  quiet,\n}: {\n  converters: LexicalPluginNodeConverter[]\n  lexicalPluginData: PayloadPluginLexicalData\n  quiet?: boolean\n}): SerializedEditorState {\n  return {\n    root: {\n      type: 'root',\n      children: convertLexicalPluginNodesToLexical({\n        converters,\n        lexicalPluginNodes: lexicalPluginData?.jsonContent?.root?.children || [],\n        parentNodeType: 'root',\n        quiet,\n      }),\n      direction: lexicalPluginData?.jsonContent?.root?.direction || 'ltr',\n      format: lexicalPluginData?.jsonContent?.root?.format || '',\n      indent: lexicalPluginData?.jsonContent?.root?.indent || 0,\n      version: 1,\n    },\n  }\n}\n\nexport function convertLexicalPluginNodesToLexical({\n  converters,\n  lexicalPluginNodes,\n  parentNodeType,\n  quiet,\n}: {\n  converters: LexicalPluginNodeConverter[]\n  lexicalPluginNodes: SerializedLexicalNode[] | undefined\n  /**\n   * Type of the parent lexical node (not the type of the original, parent payload-plugin-lexical type)\n   */\n  parentNodeType: string\n  quiet?: boolean\n}): SerializedLexicalNode[] {\n  if (!lexicalPluginNodes?.length || !converters?.length) {\n    return []\n  }\n  const unknownConverter = converters.find((converter) => converter.nodeTypes.includes('unknown'))\n  // @ts-expect-error - vestiges of the migration to strict mode. Probably not important enough in this file to fix\n  return (\n    lexicalPluginNodes.map((lexicalPluginNode, i) => {\n      if (lexicalPluginNode.type === 'paragraph') {\n        return convertParagraphNode(converters, lexicalPluginNode, quiet)\n      }\n      if (lexicalPluginNode.type === 'text' || !lexicalPluginNode.type) {\n        return convertTextNode(lexicalPluginNode)\n      }\n\n      const converter = converters.find((converter) =>\n        converter.nodeTypes.includes(lexicalPluginNode.type),\n      )\n\n      if (converter) {\n        return converter.converter({\n          childIndex: i,\n          converters,\n          lexicalPluginNode,\n          parentNodeType,\n          quiet,\n        })\n      }\n\n      if (!quiet) {\n        console.warn(\n          'lexicalPluginToLexical > No converter found for node type: ' + lexicalPluginNode.type,\n        )\n      }\n\n      return unknownConverter?.converter({\n        childIndex: i,\n        converters,\n        lexicalPluginNode,\n        parentNodeType,\n        quiet,\n      })\n    }) || []\n  )\n}\n\nexport function convertParagraphNode(\n  converters: LexicalPluginNodeConverter[],\n  node: SerializedLexicalNode,\n  quiet?: boolean,\n): SerializedParagraphNode {\n  return {\n    ...node,\n    type: 'paragraph',\n\n    children: convertLexicalPluginNodesToLexical({\n      converters,\n      lexicalPluginNodes: (node as any).children || [],\n      parentNodeType: 'paragraph',\n      quiet,\n    }),\n    version: 1,\n  } as SerializedParagraphNode\n}\nexport function convertTextNode(node: SerializedLexicalNode): SerializedTextNode {\n  return node as SerializedTextNode\n}\n"],"mappings":"AASA,OAAO,SAASA,8BAA8B;EAC5CC,UAAU;EACVC,iBAAiB;EACjBC;AAAK,CAKN;EACC,OAAO;IACLC,IAAA,EAAM;MACJC,IAAA,EAAM;MACNC,QAAA,EAAUC,kCAAA,CAAmC;QAC3CN,UAAA;QACAO,kBAAA,EAAoBN,iBAAA,EAAmBO,WAAA,EAAaL,IAAA,EAAME,QAAA,IAAY,EAAE;QACxEI,cAAA,EAAgB;QAChBP;MACF;MACAQ,SAAA,EAAWT,iBAAA,EAAmBO,WAAA,EAAaL,IAAA,EAAMO,SAAA,IAAa;MAC9DC,MAAA,EAAQV,iBAAA,EAAmBO,WAAA,EAAaL,IAAA,EAAMQ,MAAA,IAAU;MACxDC,MAAA,EAAQX,iBAAA,EAAmBO,WAAA,EAAaL,IAAA,EAAMS,MAAA,IAAU;MACxDC,OAAA,EAAS;IACX;EACF;AACF;AAEA,OAAO,SAASP,mCAAmC;EACjDN,UAAU;EACVO,kBAAkB;EAClBE,cAAc;EACdP;AAAK,CASN;EACC,IAAI,CAACK,kBAAA,EAAoBO,MAAA,IAAU,CAACd,UAAA,EAAYc,MAAA,EAAQ;IACtD,OAAO,EAAE;EACX;EACA,MAAMC,gBAAA,GAAmBf,UAAA,CAAWgB,IAAI,CAAEC,SAAA,IAAcA,SAAA,CAAUC,SAAS,CAACC,QAAQ,CAAC;EACrF;EACA,OACEZ,kBAAA,CAAmBa,GAAG,CAAC,CAACC,iBAAA,EAAmBC,CAAA;IACzC,IAAID,iBAAA,CAAkBjB,IAAI,KAAK,aAAa;MAC1C,OAAOmB,oBAAA,CAAqBvB,UAAA,EAAYqB,iBAAA,EAAmBnB,KAAA;IAC7D;IACA,IAAImB,iBAAA,CAAkBjB,IAAI,KAAK,UAAU,CAACiB,iBAAA,CAAkBjB,IAAI,EAAE;MAChE,OAAOoB,eAAA,CAAgBH,iBAAA;IACzB;IAEA,MAAMJ,SAAA,GAAYjB,UAAA,CAAWgB,IAAI,CAAEC,SAAA,IACjCA,SAAA,CAAUC,SAAS,CAACC,QAAQ,CAACE,iBAAA,CAAkBjB,IAAI;IAGrD,IAAIa,SAAA,EAAW;MACb,OAAOA,SAAA,CAAUA,SAAS,CAAC;QACzBQ,UAAA,EAAYH,CAAA;QACZtB,UAAA;QACAqB,iBAAA;QACAZ,cAAA;QACAP;MACF;IACF;IAEA,IAAI,CAACA,KAAA,EAAO;MACVwB,OAAA,CAAQC,IAAI,CACV,gEAAgEN,iBAAA,CAAkBjB,IAAI;IAE1F;IAEA,OAAOW,gBAAA,EAAkBE,SAAA,CAAU;MACjCQ,UAAA,EAAYH,CAAA;MACZtB,UAAA;MACAqB,iBAAA;MACAZ,cAAA;MACAP;IACF;EACF,MAAM,EAAE;AAEZ;AAEA,OAAO,SAASqB,qBACdvB,UAAwC,EACxC4B,IAA2B,EAC3B1B,KAAe;EAEf,OAAO;IACL,GAAG0B,IAAI;IACPxB,IAAA,EAAM;IAENC,QAAA,EAAUC,kCAAA,CAAmC;MAC3CN,UAAA;MACAO,kBAAA,EAAoBqB,IAAC,CAAavB,QAAQ,IAAI,EAAE;MAChDI,cAAA,EAAgB;MAChBP;IACF;IACAW,OAAA,EAAS;EACX;AACF;AACA,OAAO,SAASW,gBAAgBI,IAA2B;EACzD,OAAOA,IAAA;AACT","ignoreList":[]}