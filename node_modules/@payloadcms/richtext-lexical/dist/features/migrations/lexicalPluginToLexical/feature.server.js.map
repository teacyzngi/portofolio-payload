{"version":3,"file":"feature.server.js","names":["createServerFeature","defaultConverters","convertLexicalPluginToLexical","UnknownConvertedNode","LexicalPluginToLexicalFeature","feature","props","converters","ClientFeature","hooks","disableHooks","undefined","afterRead","value","lexicalPluginData","quiet","nodes","node","sanitizedServerFeatureProps","key"],"sources":["../../../../src/features/migrations/lexicalPluginToLexical/feature.server.ts"],"sourcesContent":["import type { LexicalPluginNodeConverter, PayloadPluginLexicalData } from './converter/types.js'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { defaultConverters } from './converter/defaultConverters.js'\nimport { convertLexicalPluginToLexical } from './converter/index.js'\nimport { UnknownConvertedNode } from './nodes/unknownConvertedNode/index.js'\n\nexport type LexicalPluginToLexicalFeatureProps = {\n  converters?:\n    | (({\n        defaultConverters,\n      }: {\n        defaultConverters: LexicalPluginNodeConverter[]\n      }) => LexicalPluginNodeConverter[])\n    | LexicalPluginNodeConverter[]\n  disableHooks?: boolean\n  quiet?: boolean\n}\n\nexport const LexicalPluginToLexicalFeature =\n  createServerFeature<LexicalPluginToLexicalFeatureProps>({\n    feature: ({ props }) => {\n      if (!props) {\n        props = {}\n      }\n\n      let converters: LexicalPluginNodeConverter[] = []\n\n      if (props?.converters && typeof props?.converters === 'function') {\n        converters = props.converters({ defaultConverters })\n      } else if (props.converters && typeof props?.converters !== 'function') {\n        converters = props.converters\n      } else {\n        converters = defaultConverters\n      }\n\n      props.converters = converters\n\n      return {\n        ClientFeature: '@payloadcms/richtext-lexical/client#LexicalPluginToLexicalFeatureClient',\n        hooks: props.disableHooks\n          ? undefined\n          : {\n              afterRead: [\n                ({ value }) => {\n                  if (!value || !('jsonContent' in value)) {\n                    // incomingEditorState null or not from Lexical Plugin\n                    return value\n                  }\n\n                  // Lexical Plugin => convert to lexical\n                  return convertLexicalPluginToLexical({\n                    converters: props.converters as LexicalPluginNodeConverter[],\n                    lexicalPluginData: value as PayloadPluginLexicalData,\n                    quiet: props?.quiet,\n                  })\n                },\n              ],\n            },\n        nodes: [\n          {\n            node: UnknownConvertedNode,\n          },\n        ],\n        sanitizedServerFeatureProps: props,\n      }\n    },\n    key: 'lexicalPluginToLexical',\n  })\n"],"mappings":"AAEA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,iBAAiB,QAAQ;AAClC,SAASC,6BAA6B,QAAQ;AAC9C,SAASC,oBAAoB,QAAQ;AAcrC,OAAO,MAAMC,6BAAA,GACXJ,mBAAA,CAAwD;EACtDK,OAAA,EAASA,CAAC;IAAEC;EAAK,CAAE;IACjB,IAAI,CAACA,KAAA,EAAO;MACVA,KAAA,GAAQ,CAAC;IACX;IAEA,IAAIC,UAAA,GAA2C,EAAE;IAEjD,IAAID,KAAA,EAAOC,UAAA,IAAc,OAAOD,KAAA,EAAOC,UAAA,KAAe,YAAY;MAChEA,UAAA,GAAaD,KAAA,CAAMC,UAAU,CAAC;QAAEN;MAAkB;IACpD,OAAO,IAAIK,KAAA,CAAMC,UAAU,IAAI,OAAOD,KAAA,EAAOC,UAAA,KAAe,YAAY;MACtEA,UAAA,GAAaD,KAAA,CAAMC,UAAU;IAC/B,OAAO;MACLA,UAAA,GAAaN,iBAAA;IACf;IAEAK,KAAA,CAAMC,UAAU,GAAGA,UAAA;IAEnB,OAAO;MACLC,aAAA,EAAe;MACfC,KAAA,EAAOH,KAAA,CAAMI,YAAY,GACrBC,SAAA,GACA;QACEC,SAAA,EAAW,CACT,CAAC;UAAEC;QAAK,CAAE;UACR,IAAI,CAACA,KAAA,IAAS,EAAE,iBAAiBA,KAAI,GAAI;YACvC;YACA,OAAOA,KAAA;UACT;UAEA;UACA,OAAOX,6BAAA,CAA8B;YACnCK,UAAA,EAAYD,KAAA,CAAMC,UAAU;YAC5BO,iBAAA,EAAmBD,KAAA;YACnBE,KAAA,EAAOT,KAAA,EAAOS;UAChB;QACF;MAEJ;MACJC,KAAA,EAAO,CACL;QACEC,IAAA,EAAMd;MACR,EACD;MACDe,2BAAA,EAA6BZ;IAC/B;EACF;EACAa,GAAA,EAAK;AACP","ignoreList":[]}