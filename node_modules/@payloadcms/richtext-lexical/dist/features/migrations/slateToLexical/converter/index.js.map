{"version":3,"file":"index.js","names":["NodeFormat","convertSlateToLexical","converters","slateData","root","type","children","convertSlateNodesToLexical","canContainParagraphs","parentNodeType","slateNodes","direction","format","indent","version","length","unknownConverter","find","converter","nodeTypes","includes","flatMap","slateNode","i","convertParagraphNode","convertTextNode","childIndex","console","warn","node","textFormat","textStyle","detail","convertNodeToFormat","mode","style","text","bold","IS_BOLD","italic","IS_ITALIC","strikethrough","IS_STRIKETHROUGH","underline","IS_UNDERLINE","subscript","IS_SUBSCRIPT","superscript","IS_SUPERSCRIPT","code","IS_CODE"],"sources":["../../../../../src/features/migrations/slateToLexical/converter/index.ts"],"sourcesContent":["import type {\n  SerializedEditorState,\n  SerializedLexicalNode,\n  SerializedParagraphNode,\n  SerializedTextNode,\n} from 'lexical'\n\nimport type { SlateNode, SlateNodeConverter } from './types.js'\n\nimport { NodeFormat } from '../../../../lexical/utils/nodeFormat.js'\n\nexport function convertSlateToLexical({\n  converters,\n  slateData,\n}: {\n  converters: SlateNodeConverter[]\n  slateData: SlateNode[]\n}): SerializedEditorState {\n  return {\n    root: {\n      type: 'root',\n      children: convertSlateNodesToLexical({\n        canContainParagraphs: true,\n        converters,\n        parentNodeType: 'root',\n        slateNodes: slateData,\n      }),\n      direction: 'ltr',\n      format: '',\n      indent: 0,\n      version: 1,\n    },\n  }\n}\n\nexport function convertSlateNodesToLexical({\n  canContainParagraphs,\n  converters,\n  parentNodeType,\n  slateNodes,\n}: {\n  canContainParagraphs: boolean\n  converters: SlateNodeConverter[] | undefined\n  /**\n   * Type of the parent lexical node (not the type of the original, parent slate type)\n   */\n  parentNodeType: string\n  slateNodes: SlateNode[]\n}): SerializedLexicalNode[] {\n  if (!converters?.length || !slateNodes?.length) {\n    return []\n  }\n  const unknownConverter = converters.find((converter) => converter.nodeTypes.includes('unknown'))\n  // @ts-expect-error - vestiges of the migration to strict mode. Probably not important enough in this file to fix\n  return (\n    // Flatten in case we unwrap an array of child nodes\n    slateNodes.flatMap((slateNode, i) => {\n      if (!('type' in slateNode)) {\n        if (canContainParagraphs) {\n          // This is a paragraph node. They do not have a type property in Slate\n          return convertParagraphNode(converters, slateNode)\n        } else {\n          // Unwrap generic Slate nodes recursively since depth wasn't guaranteed by Slate, especially when copy + pasting rich text\n          // - If there are children and it can't be a paragraph in Lexical, assume that the generic node should be unwrapped until the text nodes, and only assume that its a text node when there are no more children\n          if (slateNode.children) {\n            return convertSlateNodesToLexical({\n              canContainParagraphs,\n              converters,\n              parentNodeType,\n              slateNodes: slateNode.children || [],\n            })\n          }\n          // This is a simple text node. canContainParagraphs may be false if this is nested inside a paragraph already, since paragraphs cannot contain paragraphs\n          return convertTextNode(slateNode)\n        }\n      }\n      if (slateNode.type === 'p') {\n        return convertParagraphNode(converters, slateNode)\n      }\n\n      const converter = converters.find((converter) =>\n        converter.nodeTypes.includes(slateNode.type!),\n      )\n\n      if (converter) {\n        return converter.converter({ childIndex: i, converters, parentNodeType, slateNode })\n      }\n\n      console.warn('slateToLexical > No converter found for node type: ' + slateNode.type)\n      return unknownConverter?.converter({\n        childIndex: i,\n        converters,\n        parentNodeType,\n        slateNode,\n      })\n    }) || []\n  )\n}\n\nexport function convertParagraphNode(\n  converters: SlateNodeConverter[],\n  node: SlateNode,\n): SerializedParagraphNode {\n  return {\n    type: 'paragraph',\n    children: convertSlateNodesToLexical({\n      canContainParagraphs: false,\n      converters,\n      parentNodeType: 'paragraph',\n      slateNodes: node.children || [],\n    }),\n    direction: 'ltr',\n    format: '',\n    indent: 0,\n    textFormat: 0,\n    textStyle: '',\n    version: 1,\n  }\n}\nexport function convertTextNode(node: SlateNode): SerializedTextNode {\n  return {\n    type: 'text',\n    detail: 0,\n    format: convertNodeToFormat(node),\n    mode: 'normal',\n    style: '',\n    text: node.text ?? '',\n    version: 1,\n  }\n}\n\nexport function convertNodeToFormat(node: SlateNode): number {\n  let format = 0\n  if (node.bold) {\n    format = format | NodeFormat.IS_BOLD\n  }\n  if (node.italic) {\n    format = format | NodeFormat.IS_ITALIC\n  }\n  if (node.strikethrough) {\n    format = format | NodeFormat.IS_STRIKETHROUGH\n  }\n  if (node.underline) {\n    format = format | NodeFormat.IS_UNDERLINE\n  }\n  if (node.subscript) {\n    format = format | NodeFormat.IS_SUBSCRIPT\n  }\n  if (node.superscript) {\n    format = format | NodeFormat.IS_SUPERSCRIPT\n  }\n  if (node.code) {\n    format = format | NodeFormat.IS_CODE\n  }\n  return format\n}\n"],"mappings":"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","ignoreList":[]}