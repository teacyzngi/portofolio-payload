{"version":3,"file":"index.js","names":["TableCellNode","TableNode","TableRowNode","sanitizeFields","createServerFeature","convertLexicalNodesToHTML","createNode","TableMarkdownTransformer","fields","name","type","defaultValue","required","EXPERIMENTAL_TableFeature","feature","config","isRoot","parentIsLocalized","validRelationships","collections","map","c","slug","sanitizedFields","requireFieldLevelRichTextEditor","ClientFeature","generateSchemaMap","schemaMap","Map","set","markdownTransformers","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","nodeTypes","getType","tagName","headerState","headerStateClass","backgroundColor","colSpan","rowSpan","key"],"sources":["../../../../src/features/experimental_table/server/index.ts"],"sourcesContent":["import type {\n  SerializedTableCellNode as _SerializedTableCellNode,\n  SerializedTableNode as _SerializedTableNode,\n  SerializedTableRowNode as _SerializedTableRowNode,\n} from '@lexical/table'\nimport type { SerializedLexicalNode } from 'lexical'\nimport type { Config, Field, FieldSchemaMap } from 'payload'\n\nimport { TableCellNode, TableNode, TableRowNode } from '@lexical/table'\nimport { sanitizeFields } from 'payload'\n\nimport type { StronglyTypedElementNode } from '../../../nodeTypes.js'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { convertLexicalNodesToHTML } from '../../converters/lexicalToHtml_deprecated/converter/index.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { TableMarkdownTransformer } from '../markdownTransformer.js'\n\nconst fields: Field[] = [\n  {\n    name: 'rows',\n    type: 'number',\n    defaultValue: 5,\n    required: true,\n  },\n  {\n    name: 'columns',\n    type: 'number',\n    defaultValue: 5,\n    required: true,\n  },\n]\n\nexport type SerializedTableCellNode<T extends SerializedLexicalNode = SerializedLexicalNode> =\n  StronglyTypedElementNode<_SerializedTableCellNode, 'tablecell', T>\n\nexport type SerializedTableNode<T extends SerializedLexicalNode = SerializedLexicalNode> =\n  StronglyTypedElementNode<_SerializedTableNode, 'table', T>\n\nexport type SerializedTableRowNode<T extends SerializedLexicalNode = SerializedLexicalNode> =\n  StronglyTypedElementNode<_SerializedTableRowNode, 'tablerow', T>\nexport const EXPERIMENTAL_TableFeature = createServerFeature({\n  feature: async ({ config, isRoot, parentIsLocalized }) => {\n    const validRelationships = config.collections.map((c) => c.slug) || []\n\n    const sanitizedFields = await sanitizeFields({\n      config: config as unknown as Config,\n      fields,\n      parentIsLocalized,\n      requireFieldLevelRichTextEditor: isRoot,\n      validRelationships,\n    })\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#TableFeatureClient',\n      generateSchemaMap: () => {\n        const schemaMap: FieldSchemaMap = new Map()\n\n        schemaMap.set('fields', {\n          fields: sanitizedFields,\n        })\n\n        return schemaMap\n      },\n      markdownTransformers: [TableMarkdownTransformer],\n      nodes: [\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n                return `<div class=\"lexical-table-container\"><table class=\"lexical-table\" style=\"border-collapse: collapse;\">${childrenText}</table></div>`\n              },\n              nodeTypes: [TableNode.getType()],\n            },\n          },\n          node: TableNode,\n        }),\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n\n                const tagName = node.headerState > 0 ? 'th' : 'td'\n                const headerStateClass = `lexical-table-cell-header-${node.headerState}`\n                const backgroundColor = node.backgroundColor\n                  ? `background-color: ${node.backgroundColor};`\n                  : ''\n                const colSpan = node.colSpan && node.colSpan > 1 ? `colspan=\"${node.colSpan}\"` : ''\n                const rowSpan = node.rowSpan && node.rowSpan > 1 ? `rowspan=\"${node.rowSpan}\"` : ''\n\n                return `<${tagName} class=\"lexical-table-cell ${headerStateClass}\" style=\"border: 1px solid #ccc; padding: 8px; ${backgroundColor}\" ${colSpan} ${rowSpan}>${childrenText}</${tagName}>`\n              },\n              nodeTypes: [TableCellNode.getType()],\n            },\n          },\n          node: TableCellNode,\n        }),\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n                return `<tr class=\"lexical-table-row\">${childrenText}</tr>`\n              },\n              nodeTypes: [TableRowNode.getType()],\n            },\n          },\n          node: TableRowNode,\n        }),\n      ],\n    }\n  },\n  key: 'experimental_table',\n})\n"],"mappings":"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","ignoreList":[]}