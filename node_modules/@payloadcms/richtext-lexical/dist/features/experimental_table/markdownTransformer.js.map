{"version":3,"file":"markdownTransformer.js","names":["$createTableCellNode","$createTableNode","$createTableRowNode","$isTableCellNode","$isTableNode","$isTableRowNode","TableCellHeaderStates","TableCellNode","TableNode","TableRowNode","$isParagraphNode","$isTextNode","$convertFromMarkdownString","$convertToMarkdownString","TABLE_ROW_REG_EXP","TABLE_ROW_DIVIDER_REG_EXP","TableMarkdownTransformer","allTransformers","type","dependencies","export","node","output","row","getChildren","rowOutput","isHeaderRow","cell","push","replace","trim","__headerState","ROW","join","map","_","regExp","parentNode","_1","match","match0","test","table","getPreviousSibling","rows","lastRow","length","forEach","setHeaderStyles","remove","matchCells","mapToTableCells","sibling","maxCells","getChildrenSize","firstChild","getFirstChild","cells","getTextContent","Math","max","unshift","previousSibling","tableRow","append","i","$createTableCell","getTableColumnsSize","selectEnd","textContent","NO_STATUS","split","text"],"sources":["../../../src/features/experimental_table/markdownTransformer.ts"],"sourcesContent":["import type { LexicalNode } from 'lexical'\n\nimport {\n  $createTableCellNode,\n  $createTableNode,\n  $createTableRowNode,\n  $isTableCellNode,\n  $isTableNode,\n  $isTableRowNode,\n  TableCellHeaderStates,\n  TableCellNode,\n  TableNode,\n  TableRowNode,\n} from '@lexical/table'\nimport { $isParagraphNode, $isTextNode } from 'lexical'\n\nimport {\n  $convertFromMarkdownString,\n  $convertToMarkdownString,\n  type ElementTransformer,\n  type Transformer,\n} from '../../packages/@lexical/markdown/index.js'\n\n// Very primitive table setup\nconst TABLE_ROW_REG_EXP = /^\\|(.+)\\|\\s?$/\n// eslint-disable-next-line regexp/no-unused-capturing-group\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/\n\nexport const TableMarkdownTransformer: (props: {\n  allTransformers: Transformer[]\n}) => ElementTransformer = ({ allTransformers }) => ({\n  type: 'element',\n  dependencies: [TableNode, TableRowNode, TableCellNode],\n  export: (node: LexicalNode) => {\n    if (!$isTableNode(node)) {\n      return null\n    }\n\n    const output: string[] = []\n\n    for (const row of node.getChildren()) {\n      const rowOutput: string[] = []\n      if (!$isTableRowNode(row)) {\n        continue\n      }\n\n      let isHeaderRow = false\n      for (const cell of row.getChildren()) {\n        // It's TableCellNode, so it's just to make flow happy\n        if ($isTableCellNode(cell)) {\n          rowOutput.push(\n            $convertToMarkdownString(allTransformers, cell).replace(/\\n/g, '\\\\n').trim(),\n          )\n\n          if (cell.__headerState === TableCellHeaderStates.ROW) {\n            isHeaderRow = true\n          }\n        }\n      }\n\n      output.push(`| ${rowOutput.join(' | ')} |`)\n      if (isHeaderRow) {\n        output.push(`| ${rowOutput.map((_) => '---').join(' | ')} |`)\n      }\n    }\n\n    return output.join('\\n')\n  },\n  regExp: TABLE_ROW_REG_EXP,\n  replace: (parentNode, _1, match) => {\n    const match0 = match[0]\n    if (!match0) {\n      return\n    }\n    // Header row\n    if (TABLE_ROW_DIVIDER_REG_EXP.test(match0)) {\n      const table = parentNode.getPreviousSibling()\n      if (!table || !$isTableNode(table)) {\n        return\n      }\n\n      const rows = table.getChildren()\n      const lastRow = rows[rows.length - 1]\n      if (!lastRow || !$isTableRowNode(lastRow)) {\n        return\n      }\n\n      // Add header state to row cells\n      lastRow.getChildren().forEach((cell) => {\n        if (!$isTableCellNode(cell)) {\n          return\n        }\n        cell.setHeaderStyles(TableCellHeaderStates.ROW, TableCellHeaderStates.ROW)\n      })\n\n      // Remove line\n      parentNode.remove()\n      return\n    }\n\n    const matchCells = mapToTableCells(match0, allTransformers)\n\n    if (matchCells == null) {\n      return\n    }\n\n    const rows = [matchCells]\n    let sibling = parentNode.getPreviousSibling()\n    let maxCells = matchCells.length\n\n    while (sibling) {\n      if (!$isParagraphNode(sibling)) {\n        break\n      }\n\n      if (sibling.getChildrenSize() !== 1) {\n        break\n      }\n\n      const firstChild = sibling.getFirstChild()\n\n      if (!$isTextNode(firstChild)) {\n        break\n      }\n\n      const cells = mapToTableCells(firstChild.getTextContent(), allTransformers)\n\n      if (cells == null) {\n        break\n      }\n\n      maxCells = Math.max(maxCells, cells.length)\n      rows.unshift(cells)\n      const previousSibling = sibling.getPreviousSibling()\n      sibling.remove()\n      sibling = previousSibling\n    }\n\n    const table = $createTableNode()\n\n    for (const cells of rows) {\n      const tableRow = $createTableRowNode()\n      table.append(tableRow)\n\n      for (let i = 0; i < maxCells; i++) {\n        tableRow.append(i < cells.length ? cells[i]! : $createTableCell('', allTransformers))\n      }\n    }\n\n    const previousSibling = parentNode.getPreviousSibling()\n    if ($isTableNode(previousSibling) && getTableColumnsSize(previousSibling) === maxCells) {\n      previousSibling.append(...table.getChildren())\n      parentNode.remove()\n    } else {\n      parentNode.replace(table)\n    }\n\n    table.selectEnd()\n  },\n})\n\nfunction getTableColumnsSize(table: TableNode) {\n  const row = table.getFirstChild()\n  return $isTableRowNode(row) ? row.getChildrenSize() : 0\n}\n\nconst $createTableCell = (textContent: string, allTransformers: Transformer[]): TableCellNode => {\n  textContent = textContent.replace(/\\\\n/g, '\\n')\n  const cell = $createTableCellNode(TableCellHeaderStates.NO_STATUS)\n  $convertFromMarkdownString(textContent, allTransformers, cell)\n  return cell\n}\n\nconst mapToTableCells = (\n  textContent: string,\n  allTransformers: Transformer[],\n): Array<TableCellNode> | null => {\n  const match = textContent.match(TABLE_ROW_REG_EXP)\n  if (!match || !match[1]) {\n    return null\n  }\n  return match[1].split('|').map((text) => $createTableCell(text, allTransformers))\n}\n"],"mappings":"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","ignoreList":[]}