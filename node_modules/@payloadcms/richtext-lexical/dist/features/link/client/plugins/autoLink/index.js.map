{"version":3,"file":"index.js","names":["c","_c","useLexicalComposerContext","mergeRegister","$createTextNode","$getSelection","$isElementNode","$isLineBreakNode","$isNodeSelection","$isRangeSelection","$isTextNode","TextNode","TextNodeValue","useEffect","$createAutoLinkNode","$isAutoLinkNode","AutoLinkNode","$isLinkNode","createLinkMatcherWithRegExp","regExp","urlTransformer","text","match","exec","index","length","url","findFirstMatch","matchers","matcher","PUNCTUATION_OR_SPACE","isSeparator","char","undefined","test","endsWithSeparator","textContent","startsWithSeparator","startsWithTLD","isEmail","isPreviousNodeValid","node","previousNode","getPreviousSibling","getLastDescendant","getTextContent","isNextNodeValid","nextNode","getNextSibling","getFirstDescendant","isContentAroundIsValid","matchStart","matchEnd","nodes","contentBeforeIsValid","contentAfterIsValid","extractMatchingNodes","startIndex","endIndex","unmodifiedBeforeNodes","matchingNodes","unmodifiedAfterNodes","matchingOffset","currentOffset","currentNodes","currentNode","currentNodeText","currentNodeLength","currentNodeStart","currentNodeEnd","push","shift","$createAutoLinkNode_","fields","linkType","linkNode","remainingTextNode","linkTextNode","splitText","textNode","setFormat","getFormat","setDetail","getDetail","setStyle","getStyle","append","replace","firstTextNode","offset","firstLinkTextNode","linkNodes","forEach","endNode","selection","selectedTextNode","getNodes","find","select","anchor","focus","$handleLinkCreation","onChange","initialText","map","join","invalidMatchEnd","matchLength","isValid","actualMatchStart","actualMatchEnd","substring","handleLinkEdit","children","getChildren","childrenLength","i","child","isSimpleText","replaceWithChildren","getFields","flds","setFields","handleBadNeighbors","previousSibling","nextSibling","isEmailURI","startsWith","j","insertAfter","remove","getLatest","getTextNodesToMatch","textNodesToMatch","useAutoLink","editor","$","t0","t1","hasNodes","Error","onChangeWrapped","prevUrl","registerNodeTransform","parent","getParentOrThrow","previous","URL_REGEX","EMAIL_REGEX","MATCHERS","AutoLinkPlugin"],"sources":["../../../../../../src/features/link/client/plugins/autoLink/index.tsx"],"sourcesContent":["'use client'\nimport type { ElementNode, LexicalEditor, LexicalNode, TextNode } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $createTextNode,\n  $getSelection,\n  $isElementNode,\n  $isLineBreakNode,\n  $isNodeSelection,\n  $isRangeSelection,\n  $isTextNode,\n  TextNode as TextNodeValue,\n} from 'lexical'\nimport { useEffect } from 'react'\n\nimport type { PluginComponent } from '../../../../typesClient.js'\nimport type { LinkFields } from '../../../nodes/types.js'\nimport type { ClientProps } from '../../index.js'\n\nimport { $createAutoLinkNode, $isAutoLinkNode, AutoLinkNode } from '../../../nodes/AutoLinkNode.js'\nimport { $isLinkNode } from '../../../nodes/LinkNode.js'\n\ntype ChangeHandler = (url: null | string, prevUrl: null | string) => void\n\ninterface LinkMatcherResult {\n  fields?: LinkFields\n  index: number\n  length: number\n  text: string\n  url: string\n}\n\nexport type LinkMatcher = (text: string) => LinkMatcherResult | null\n\nexport function createLinkMatcherWithRegExp(\n  regExp: RegExp,\n  urlTransformer: (text: string) => string = (text) => text,\n) {\n  return (text: string) => {\n    const match = regExp.exec(text)\n    if (match === null) {\n      return null\n    }\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(match[0]),\n    }\n  }\n}\n\nfunction findFirstMatch(text: string, matchers: LinkMatcher[]): LinkMatcherResult | null {\n  for (const matcher of matchers) {\n    const match = matcher(text)\n\n    if (match != null) {\n      return match\n    }\n  }\n\n  return null\n}\n\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/\n\nfunction isSeparator(char: string | undefined): boolean {\n  return char !== undefined && PUNCTUATION_OR_SPACE.test(char)\n}\n\nfunction endsWithSeparator(textContent: string): boolean {\n  return isSeparator(textContent[textContent.length - 1])\n}\n\nfunction startsWithSeparator(textContent: string): boolean {\n  return isSeparator(textContent[0])\n}\n\n/**\n * Check if the text content starts with a fullstop followed by a top-level domain.\n * Meaning if the text content can be a beginning of a top level domain.\n * @param textContent\n * @param isEmail\n * @returns boolean\n */\nfunction startsWithTLD(textContent: string, isEmail: boolean): boolean {\n  if (isEmail) {\n    return /^\\.[a-z]{2,}/i.test(textContent)\n  } else {\n    return /^\\.[a-z0-9]+/i.test(textContent)\n  }\n}\n\nfunction isPreviousNodeValid(node: LexicalNode): boolean {\n  let previousNode = node.getPreviousSibling()\n  if ($isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant()\n  }\n  return (\n    previousNode === null ||\n    $isLineBreakNode(previousNode) ||\n    ($isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent()))\n  )\n}\n\nfunction isNextNodeValid(node: LexicalNode): boolean {\n  let nextNode = node.getNextSibling()\n  if ($isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant()\n  }\n  return (\n    nextNode === null ||\n    $isLineBreakNode(nextNode) ||\n    ($isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent()))\n  )\n}\n\nfunction isContentAroundIsValid(\n  matchStart: number,\n  matchEnd: number,\n  text: string,\n  nodes: TextNode[],\n): boolean {\n  const contentBeforeIsValid =\n    matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0]!)\n  if (!contentBeforeIsValid) {\n    return false\n  }\n\n  const contentAfterIsValid =\n    matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]!)\n  return contentAfterIsValid\n}\n\nfunction extractMatchingNodes(\n  nodes: TextNode[],\n  startIndex: number,\n  endIndex: number,\n): [\n  matchingOffset: number,\n  unmodifiedBeforeNodes: TextNode[],\n  matchingNodes: TextNode[],\n  unmodifiedAfterNodes: TextNode[],\n] {\n  const unmodifiedBeforeNodes: TextNode[] = []\n  const matchingNodes: TextNode[] = []\n  const unmodifiedAfterNodes: TextNode[] = []\n  let matchingOffset = 0\n\n  let currentOffset = 0\n  const currentNodes = [...nodes]\n\n  while (currentNodes.length > 0) {\n    const currentNode = currentNodes[0]!\n    const currentNodeText = currentNode.getTextContent()\n    const currentNodeLength = currentNodeText.length\n    const currentNodeStart = currentOffset\n    const currentNodeEnd = currentOffset + currentNodeLength\n\n    if (currentNodeEnd <= startIndex) {\n      unmodifiedBeforeNodes.push(currentNode)\n      matchingOffset += currentNodeLength\n    } else if (currentNodeStart >= endIndex) {\n      unmodifiedAfterNodes.push(currentNode)\n    } else {\n      matchingNodes.push(currentNode)\n    }\n    currentOffset += currentNodeLength\n    currentNodes.shift()\n  }\n  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes]\n}\n\nfunction $createAutoLinkNode_(\n  nodes: TextNode[],\n  startIndex: number,\n  endIndex: number,\n  match: LinkMatcherResult,\n): TextNode | undefined {\n  const fields = {\n    linkType: 'custom',\n    url: match.url,\n    ...match.fields,\n  } as LinkFields\n\n  const linkNode = $createAutoLinkNode({ fields })\n  if (nodes.length === 1) {\n    const remainingTextNode = nodes[0]!\n    let linkTextNode: TextNode | undefined\n    if (startIndex === 0) {\n      ;[linkTextNode] = remainingTextNode.splitText(endIndex)\n    } else {\n      ;[, linkTextNode] = remainingTextNode.splitText(startIndex, endIndex)\n    }\n    if (linkTextNode) {\n      const textNode = $createTextNode(match.text)\n      textNode.setFormat(linkTextNode.getFormat())\n      textNode.setDetail(linkTextNode.getDetail())\n      textNode.setStyle(linkTextNode.getStyle())\n      linkNode.append(textNode)\n      linkTextNode.replace(linkNode)\n    }\n    return remainingTextNode\n  } else if (nodes.length > 1) {\n    const firstTextNode = nodes[0]!\n    let offset = firstTextNode.getTextContent().length\n    let firstLinkTextNode\n    if (startIndex === 0) {\n      firstLinkTextNode = firstTextNode\n    } else {\n      ;[, firstLinkTextNode] = firstTextNode.splitText(startIndex)\n    }\n    const linkNodes: LexicalNode[] = []\n    let remainingTextNode\n    nodes.forEach((currentNode) => {\n      const currentNodeText = currentNode.getTextContent()\n      const currentNodeLength = currentNodeText.length\n      const currentNodeStart = offset\n      const currentNodeEnd = offset + currentNodeLength\n      if (currentNodeStart < endIndex) {\n        if (currentNodeEnd <= endIndex) {\n          linkNodes.push(currentNode)\n        } else {\n          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart)\n          if (linkTextNode) {\n            linkNodes.push(linkTextNode)\n          }\n          remainingTextNode = endNode\n        }\n      }\n      offset += currentNodeLength\n    })\n\n    if (firstLinkTextNode) {\n      const selection = $getSelection()\n      const selectedTextNode = selection ? selection.getNodes().find($isTextNode) : undefined\n      const textNode = $createTextNode(firstLinkTextNode.getTextContent())\n      textNode.setFormat(firstLinkTextNode.getFormat())\n      textNode.setDetail(firstLinkTextNode.getDetail())\n      textNode.setStyle(firstLinkTextNode.getStyle())\n      linkNode.append(textNode, ...linkNodes)\n      // it does not preserve caret position if caret was at the first text node\n      // so we need to restore caret position\n      if (selectedTextNode && selectedTextNode === firstLinkTextNode) {\n        if ($isRangeSelection(selection)) {\n          textNode.select(selection.anchor.offset, selection.focus.offset)\n        } else if ($isNodeSelection(selection)) {\n          textNode.select(0, textNode.getTextContent().length)\n        }\n      }\n      firstLinkTextNode.replace(linkNode)\n      return remainingTextNode\n    }\n  }\n  return undefined\n}\n\nfunction $handleLinkCreation(\n  nodes: TextNode[],\n  matchers: LinkMatcher[],\n  onChange: ChangeHandler,\n): void {\n  let currentNodes = [...nodes]\n  const initialText = currentNodes.map((node) => node.getTextContent()).join('')\n  let text = initialText\n\n  let match\n  let invalidMatchEnd = 0\n\n  while ((match = findFirstMatch(text, matchers)) != null && match !== null) {\n    const matchStart: number = match.index\n    const matchLength: number = match.length\n    const matchEnd = matchStart + matchLength\n    const isValid = isContentAroundIsValid(\n      invalidMatchEnd + matchStart,\n      invalidMatchEnd + matchEnd,\n      initialText,\n      currentNodes,\n    )\n\n    if (isValid) {\n      const [matchingOffset, , matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(\n        currentNodes,\n        invalidMatchEnd + matchStart,\n        invalidMatchEnd + matchEnd,\n      )\n\n      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset\n      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset\n      const remainingTextNode = $createAutoLinkNode_(\n        matchingNodes,\n        actualMatchStart,\n        actualMatchEnd,\n        match,\n      )\n      currentNodes = remainingTextNode\n        ? [remainingTextNode, ...unmodifiedAfterNodes]\n        : unmodifiedAfterNodes\n      onChange(match.url, null)\n      invalidMatchEnd = 0\n    } else {\n      invalidMatchEnd += matchEnd\n    }\n\n    text = text.substring(matchEnd)\n  }\n}\n\nfunction handleLinkEdit(\n  linkNode: AutoLinkNode,\n  matchers: LinkMatcher[],\n  onChange: ChangeHandler,\n): void {\n  // Check children are simple text\n  const children = linkNode.getChildren()\n  const childrenLength = children.length\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i]\n    if (!$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode)\n      onChange(null, linkNode.getFields()?.url ?? null)\n      return\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent()\n  const match = findFirstMatch(text, matchers)\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode)\n    onChange(null, linkNode.getFields()?.url ?? null)\n    return\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode)\n    onChange(null, linkNode.getFields()?.url ?? null)\n    return\n  }\n\n  const url = linkNode.getFields()?.url\n  if (url !== match?.url) {\n    const flds = linkNode.getFields()\n    flds.url = match?.url\n    linkNode.setFields(flds)\n    onChange(match.url, url ?? null)\n  }\n}\n\n// Bad neighbors are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(\n  textNode: TextNode,\n  matchers: LinkMatcher[],\n  onChange: ChangeHandler,\n): void {\n  const previousSibling = textNode.getPreviousSibling()\n  const nextSibling = textNode.getNextSibling()\n  const text = textNode.getTextContent()\n\n  if ($isAutoLinkNode(previousSibling)) {\n    const isEmailURI = previousSibling.getFields()?.url\n      ? (previousSibling.getFields()?.url?.startsWith('mailto:') ?? false)\n      : false\n    if (!startsWithSeparator(text) || startsWithTLD(text, isEmailURI)) {\n      previousSibling.append(textNode)\n      handleLinkEdit(previousSibling, matchers, onChange)\n      onChange(null, previousSibling.getFields()?.url ?? null)\n    }\n  }\n\n  if ($isAutoLinkNode(nextSibling) && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling)\n    handleLinkEdit(nextSibling, matchers, onChange)\n    onChange(null, nextSibling.getFields()?.url ?? null)\n  }\n}\n\nfunction replaceWithChildren(node: ElementNode): LexicalNode[] {\n  const children = node.getChildren()\n  const childrenLength = children.length\n\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]!)\n  }\n\n  node.remove()\n  return children.map((child) => child.getLatest())\n}\n\nfunction getTextNodesToMatch(textNode: TextNode): TextNode[] {\n  // check if next siblings are simple text nodes till a node contains a space separator\n  const textNodesToMatch = [textNode]\n  let nextSibling = textNode.getNextSibling()\n  while (nextSibling !== null && $isTextNode(nextSibling) && nextSibling.isSimpleText()) {\n    textNodesToMatch.push(nextSibling)\n    if (/\\s/.test(nextSibling.getTextContent())) {\n      break\n    }\n    nextSibling = nextSibling.getNextSibling()\n  }\n  return textNodesToMatch\n}\n\nfunction useAutoLink(\n  editor: LexicalEditor,\n  matchers: LinkMatcher[],\n  onChange?: ChangeHandler,\n): void {\n  useEffect(() => {\n    if (!editor.hasNodes([AutoLinkNode])) {\n      throw new Error('LexicalAutoLinkPlugin: AutoLinkNode not registered on editor')\n    }\n\n    const onChangeWrapped = (url: null | string, prevUrl: null | string): void => {\n      if (onChange != null) {\n        onChange(url, prevUrl)\n      }\n    }\n\n    return mergeRegister(\n      editor.registerNodeTransform(TextNodeValue, (textNode: TextNode) => {\n        const parent = textNode.getParentOrThrow()\n        const previous = textNode.getPreviousSibling()\n        if ($isAutoLinkNode(parent)) {\n          handleLinkEdit(parent, matchers, onChangeWrapped)\n        } else if (!$isLinkNode(parent)) {\n          if (\n            textNode.isSimpleText() &&\n            (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))\n          ) {\n            const textNodesToMatch = getTextNodesToMatch(textNode)\n            $handleLinkCreation(textNodesToMatch, matchers, onChangeWrapped)\n          }\n\n          handleBadNeighbors(textNode, matchers, onChangeWrapped)\n        }\n      }),\n    )\n  }, [editor, matchers, onChange])\n}\n\nconst URL_REGEX =\n  /((https?:\\/\\/(www\\.)?)|(www\\.))[-\\w@:%.+~#=]{1,256}\\.[a-zA-Z\\d()]{1,6}\\b([-\\w()@:%+.~#?&/=]*)(?<![-.+():%])/\n\nconst EMAIL_REGEX =\n  /(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\])|(([a-z\\-\\d]+\\.)+[a-z]{2,}))/i\n\nconst MATCHERS = [\n  createLinkMatcherWithRegExp(URL_REGEX, (text) => {\n    return text.startsWith('http') ? text : `https://${text}`\n  }),\n  createLinkMatcherWithRegExp(EMAIL_REGEX, (text) => {\n    return `mailto:${text}`\n  }),\n]\n\nexport const AutoLinkPlugin: PluginComponent<ClientProps> = () => {\n  const [editor] = useLexicalComposerContext()\n\n  useAutoLink(editor, MATCHERS)\n\n  return null\n}\n"],"mappings":"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","ignoreList":[]}