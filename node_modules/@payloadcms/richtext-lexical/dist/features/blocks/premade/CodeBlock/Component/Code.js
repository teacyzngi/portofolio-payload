'use client';

import { jsx as _jsx } from "react/jsx-runtime";
import { CodeField, useFormFields } from '@payloadcms/ui';
import React, { useMemo } from 'react';
import { defaultLanguages } from './defaultLanguages.js';
export const CodeComponent = ({
  autoComplete,
  field,
  forceRender,
  languages = defaultLanguages,
  path,
  permissions,
  readOnly,
  renderedBlocks,
  schemaPath,
  typescript,
  validate
}) => {
  const languageField = useFormFields(([fields]) => fields['language']);
  const language = languageField?.value || languageField?.initialValue || 'typescript';
  const label = languages[language];
  const props = useMemo(() => ({
    ...field,
    type: 'code',
    admin: {
      ...field.admin,
      editorOptions: {},
      editorProps: {
        // If typescript is set, @monaco-editor/react needs to set the URI to a .ts or .tsx file when it calls createModel().
        // This is done through the `defaultPath` prop.
        defaultPath: language === 'ts' ? 'file.tsx' : undefined
      },
      language
    }
  }), [field, language]);
  const key = `${field.name}-${language}-${label}`;
  return props && /*#__PURE__*/_jsx(CodeField, {
    autoComplete: autoComplete,
    field: props,
    forceRender: forceRender,
    onMount: (_editor, monaco) => {
      monaco.editor.defineTheme('vs-dark', {
        base: 'vs-dark',
        colors: {
          'editor.background': '#222222'
        },
        inherit: true,
        rules: []
      });
      monaco.editor.defineTheme('vs', {
        base: 'vs',
        colors: {
          'editor.background': '#f5f5f5'
        },
        inherit: true,
        rules: []
      });
      monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
        allowNonTsExtensions: true,
        // Set module resolution to NodeJs to enable autocompletion
        allowJs: true,
        allowSyntheticDefaultImports: true,
        esModuleInterop: true,
        jsx: monaco.languages.typescript.JsxEmit.React,
        moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
        noEmit: true,
        paths: typescript?.paths,
        reactNamespace: 'React',
        target: monaco.languages.typescript.ScriptTarget[typescript?.target ?? 'ESNext'],
        typeRoots: typescript?.typeRoots ?? ['node_modules/@types']
      });
      monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
        noSemanticValidation: typescript?.enableSemanticValidation ? false : true,
        noSyntaxValidation: false
      });
      const run = async () => {
        if (typescript?.fetchTypes && Array.isArray(typescript.fetchTypes) && typescript.fetchTypes.length > 0) {
          await Promise.all(typescript.fetchTypes.map(async type => {
            const types = await fetch(type.url);
            const typesText = await types.text();
            monaco.languages.typescript.typescriptDefaults.addExtraLib(typesText, type.filePath);
          }));
        }
      };
      void run();
    },
    path: path,
    permissions: permissions,
    readOnly: readOnly,
    renderedBlocks: renderedBlocks,
    schemaPath: schemaPath,
    validate: validate
  }, key);
};
//# sourceMappingURL=Code.js.map