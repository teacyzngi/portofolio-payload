{"version":3,"file":"getMarkdownToLexical.js","names":["createHeadlessEditor","$convertFromMarkdownString","getMarkdownToLexical","allNodes","allTransformers","markdownToLexical","markdown","headlessEditor","nodes","update","discrete","editorJSON","getEditorState","toJSON"],"sources":["../../../../../src/features/blocks/client/markdown/getMarkdownToLexical.ts"],"sourcesContent":["import type { Klass, LexicalNode, LexicalNodeReplacement, SerializedEditorState } from 'lexical'\n\nimport { createHeadlessEditor } from '@lexical/headless'\n\nimport {\n  $convertFromMarkdownString,\n  type Transformer,\n} from '../../../../packages/@lexical/markdown/index.js'\n\nexport function getMarkdownToLexical(\n  allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>,\n  allTransformers: Transformer[],\n): (args: { markdown: string }) => SerializedEditorState {\n  const markdownToLexical = ({ markdown }: { markdown: string }): SerializedEditorState => {\n    const headlessEditor = createHeadlessEditor({\n      nodes: allNodes,\n    })\n\n    headlessEditor.update(\n      () => {\n        $convertFromMarkdownString(markdown, allTransformers)\n      },\n      { discrete: true },\n    )\n\n    const editorJSON = headlessEditor.getEditorState().toJSON()\n\n    return editorJSON\n  }\n  return markdownToLexical\n}\n"],"mappings":"AAEA,SAASA,oBAAoB,QAAQ;AAErC,SACEC,0BAA0B,QAErB;AAEP,OAAO,SAASC,qBACdC,QAA4D,EAC5DC,eAA8B;EAE9B,MAAMC,iBAAA,GAAoBA,CAAC;IAAEC;EAAQ,CAAwB;IAC3D,MAAMC,cAAA,GAAiBP,oBAAA,CAAqB;MAC1CQ,KAAA,EAAOL;IACT;IAEAI,cAAA,CAAeE,MAAM,CACnB;MACER,0BAAA,CAA2BK,QAAA,EAAUF,eAAA;IACvC,GACA;MAAEM,QAAA,EAAU;IAAK;IAGnB,MAAMC,UAAA,GAAaJ,cAAA,CAAeK,cAAc,GAAGC,MAAM;IAEzD,OAAOF,UAAA;EACT;EACA,OAAON,iBAAA;AACT","ignoreList":[]}