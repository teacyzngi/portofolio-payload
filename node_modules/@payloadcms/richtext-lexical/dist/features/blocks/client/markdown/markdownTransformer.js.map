{"version":3,"file":"markdownTransformer.js","names":["$parseSerializedNode","extractPropsFromJSXPropsString","propsToJSXString","linesFromStartToContentAndPropsString","$createBlockNode","$isBlockNode","BlockNode","$createInlineBlockNode","$isInlineBlockNode","InlineBlockNode","getLexicalToMarkdown","getMarkdownToLexical","createTagRegexes","tagName","escapedTagName","replace","regExpEnd","RegExp","regExpStart","getBlockMarkdownTransformers","blocks","inlineBlocks","length","transformers","block","transformer","getMarkdownTransformerForBlock","concat","isInlineBlock","jsx","regex","slug","toReturn","push","allNodes","allTransformers","type","dependencies","export","node","getFields","blockType","toLowerCase","nodeFields","lexicalToMarkdown","exportResult","fields","hasProps","props","Object","keys","children","getEndIndex","match","endlineLastCharIndex","isEndOptional","lines","getTextContent","regexpEndRegex","startLineIndex","startMatch","trimChildren","importRegExp","customStartRegex","regExp","content","propsString","index","import","markdownToLexical","blockFields","closeMatch","htmlToLexical","openMatch","inlineBlockNode","sanitizedChildren","includes","child","split","sanitizedChild","doNotTrimChildren","handleImportAfterStartMatch","customEndRegex","undefined","rootNode","optional","afterEndLine","beforeStartLine","unsanitizedContent","endLineIndex","endsWith","slice","startsWith","prevNodes","nextNodes","markdown","root","firstPrevNode","append","lastChild","getChildren","linesInBetween","line","childrenString","join","trim"],"sources":["../../../../../src/features/blocks/client/markdown/markdownTransformer.ts"],"sourcesContent":["import type { ClientBlock } from 'payload'\n\nimport {\n  $parseSerializedNode,\n  type ElementNode,\n  type Klass,\n  type LexicalNode,\n  type LexicalNodeReplacement,\n  type SerializedLexicalNode,\n} from 'lexical'\n\nimport type { Transformer } from '../../../../packages/@lexical/markdown/index.js'\nimport type {\n  MultilineElementTransformer,\n  TextMatchTransformer,\n} from '../../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { extractPropsFromJSXPropsString } from '../../../../utilities/jsx/extractPropsFromJSXPropsString.js'\nimport { propsToJSXString } from '../../../../utilities/jsx/jsx.js'\nimport { linesFromStartToContentAndPropsString } from '../../server/markdown/linesFromMatchToContentAndPropsString.js'\nimport { $createBlockNode, $isBlockNode, BlockNode } from '../nodes/BlocksNode.js'\nimport {\n  $createInlineBlockNode,\n  $isInlineBlockNode,\n  InlineBlockNode,\n} from '../nodes/InlineBlocksNode.js'\nimport { getLexicalToMarkdown } from './getLexicalToMarkdown.js'\nimport { getMarkdownToLexical } from './getMarkdownToLexical.js'\n\nfunction createTagRegexes(tagName: string) {\n  const escapedTagName = tagName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n  return {\n    regExpEnd: new RegExp(`</(${escapedTagName})\\\\s*>|<${escapedTagName}[^>]*?/>`, 'i'),\n    regExpStart: new RegExp(`<(${escapedTagName})([^>]*?)\\\\s*(/?)>`, 'i'),\n  }\n}\nexport const getBlockMarkdownTransformers = ({\n  blocks,\n  inlineBlocks,\n}: {\n  blocks: ClientBlock[]\n  inlineBlocks: ClientBlock[]\n}): ((props: {\n  allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n  allTransformers: Transformer[]\n}) => MultilineElementTransformer | TextMatchTransformer)[] => {\n  if (!blocks?.length && !inlineBlocks?.length) {\n    return []\n  }\n  let transformers: ((props: {\n    allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n    allTransformers: Transformer[]\n  }) => MultilineElementTransformer | TextMatchTransformer)[] = []\n\n  if (blocks?.length) {\n    for (const block of blocks) {\n      const transformer = getMarkdownTransformerForBlock(block, false)\n\n      if (transformer) {\n        transformers = transformers.concat(transformer)\n      }\n    }\n  }\n\n  if (inlineBlocks?.length) {\n    for (const block of inlineBlocks) {\n      const transformer = getMarkdownTransformerForBlock(block, true)\n\n      if (transformer) {\n        transformers = transformers.concat(transformer)\n      }\n    }\n  }\n\n  return transformers\n}\n\nfunction getMarkdownTransformerForBlock(\n  block: ClientBlock,\n  isInlineBlock: boolean,\n): Array<\n  (props: {\n    allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n    allTransformers: Transformer[]\n  }) => MultilineElementTransformer | TextMatchTransformer\n> | null {\n  if (!block.jsx) {\n    return null\n  }\n  const regex = createTagRegexes(block.slug)\n  const toReturn: Array<\n    (props: {\n      allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n      allTransformers: Transformer[]\n    }) => MultilineElementTransformer | TextMatchTransformer\n  > = []\n\n  if (isInlineBlock) {\n    toReturn.push(({ allNodes, allTransformers }) => ({\n      type: 'text-match',\n      dependencies: [InlineBlockNode],\n      export: (node) => {\n        if (!$isInlineBlockNode(node)) {\n          return null\n        }\n\n        if (node.getFields()?.blockType?.toLowerCase() !== block.slug.toLowerCase()) {\n          return null\n        }\n\n        const nodeFields = node.getFields()\n        const lexicalToMarkdown = getLexicalToMarkdown(allNodes, allTransformers)\n\n        const exportResult = block.jsx!.export({\n          fields: nodeFields,\n          lexicalToMarkdown,\n        })\n        if (exportResult === false) {\n          return null\n        }\n        if (typeof exportResult === 'string') {\n          return exportResult\n        }\n\n        const hasProps = exportResult.props && Object.keys(exportResult.props)?.length > 0\n        const props = exportResult.props ?? {}\n\n        if (exportResult?.children?.length) {\n          return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}>${exportResult.children}</${nodeFields.blockType}>`\n        }\n\n        return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}/>`\n      },\n      getEndIndex: (node, match) => {\n        const { endlineLastCharIndex } = linesFromStartToContentAndPropsString({\n          isEndOptional: false,\n          lines: [node.getTextContent()],\n          regexpEndRegex: regex.regExpEnd,\n          startLineIndex: 0,\n          startMatch: match,\n          trimChildren: false,\n        })\n\n        return endlineLastCharIndex\n      },\n      importRegExp: block.jsx?.customStartRegex ?? regex.regExpStart,\n      regExp: /___ignoreignoreignore___/g,\n      replace(node, match) {\n        const { content, propsString } = linesFromStartToContentAndPropsString({\n          isEndOptional: false,\n          lines: [node.getTextContent()],\n          regexpEndRegex: regex.regExpEnd,\n          startLineIndex: 0,\n          startMatch: {\n            ...match,\n            index: 0,\n          },\n          trimChildren: false,\n        })\n\n        if (!block?.jsx?.import) {\n          // No multiline transformer handled this line successfully\n          return\n        }\n\n        const markdownToLexical = getMarkdownToLexical(allNodes, allTransformers)\n\n        const blockFields = block.jsx.import({\n          children: content,\n          closeMatch: null,\n          htmlToLexical: null, // TODO\n          markdownToLexical,\n          openMatch: match,\n          props: propsString\n            ? extractPropsFromJSXPropsString({\n                propsString,\n              })\n            : {},\n        })\n        if (blockFields === false) {\n          return\n        }\n\n        const inlineBlockNode = $createInlineBlockNode({\n          blockType: block.slug,\n          ...(blockFields as any),\n        })\n\n        node.replace(inlineBlockNode)\n      },\n    }))\n\n    return toReturn\n  }\n\n  toReturn.push(({ allNodes, allTransformers }) => ({\n    dependencies: [BlockNode],\n    export: (node) => {\n      if (!$isBlockNode(node)) {\n        return null\n      }\n\n      if (node.getFields()?.blockType?.toLowerCase() !== block.slug.toLowerCase()) {\n        return null\n      }\n\n      const nodeFields = node.getFields()\n      const lexicalToMarkdown = getLexicalToMarkdown(allNodes, allTransformers)\n\n      const exportResult = block.jsx!.export({\n        fields: nodeFields,\n        lexicalToMarkdown,\n      })\n      if (exportResult === false) {\n        return null\n      }\n      if (typeof exportResult === 'string') {\n        return exportResult\n      }\n\n      const hasProps = exportResult.props && Object.keys(exportResult.props)?.length > 0\n      const props = exportResult.props ?? {}\n\n      if (exportResult?.children?.length) {\n        const children = exportResult.children\n        let sanitizedChildren = ''\n\n        // Ensure it has a leftpad of at least 2 spaces. The data is saved without those spaces, so we can just blindly add it to every child\n        if (children.includes('\\n')) {\n          for (const child of children.split('\\n')) {\n            let sanitizedChild = ''\n            if (!block?.jsx?.doNotTrimChildren && child !== '') {\n              sanitizedChild = '  '\n            }\n            sanitizedChild += child + '\\n'\n\n            sanitizedChildren += sanitizedChild\n          }\n        } else {\n          sanitizedChildren = (block?.jsx?.doNotTrimChildren ? '' : '  ') + children + '\\n'\n        }\n\n        return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}>\\n${sanitizedChildren}</${nodeFields.blockType}>`\n      }\n\n      return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}/>`\n    },\n    handleImportAfterStartMatch: block.jsx?.customEndRegex\n      ? undefined\n      : ({ lines, rootNode, startLineIndex, startMatch, transformer }) => {\n          const regexpEndRegex: RegExp | undefined =\n            typeof transformer.regExpEnd === 'object' && 'regExp' in transformer.regExpEnd\n              ? transformer.regExpEnd.regExp\n              : transformer.regExpEnd\n\n          const isEndOptional =\n            transformer.regExpEnd &&\n            typeof transformer.regExpEnd === 'object' &&\n            'optional' in transformer.regExpEnd\n              ? transformer.regExpEnd.optional\n              : !transformer.regExpEnd\n\n          const {\n            afterEndLine,\n            beforeStartLine,\n            content: unsanitizedContent,\n            endLineIndex,\n            propsString,\n          } = linesFromStartToContentAndPropsString({\n            isEndOptional,\n            lines,\n            regexpEndRegex,\n            startLineIndex,\n            startMatch,\n            trimChildren: false,\n          })\n\n          let content = ''\n\n          if (block?.jsx?.doNotTrimChildren) {\n            content = unsanitizedContent.endsWith('\\n')\n              ? unsanitizedContent.slice(0, -1)\n              : unsanitizedContent\n          } else {\n            // Ensure it has a leftpad of at least 2 spaces. The data is saved without those spaces, so we can just blindly add it to every child\n            if (unsanitizedContent.includes('\\n')) {\n              const split = unsanitizedContent.split('\\n')\n              let index = 0\n              for (const child of split) {\n                index++\n\n                if (child.startsWith('  ')) {\n                  content += child.slice(2)\n                } else {\n                  // If one child is misaligned, skip aligning completely, unless it's just empty\n                  if (child === '') {\n                    content += child\n                  } else {\n                    content = unsanitizedContent.endsWith('\\n')\n                      ? unsanitizedContent.slice(0, -1)\n                      : unsanitizedContent\n                    break\n                  }\n                }\n\n                content += index === split.length ? '' : '\\n'\n              }\n            } else {\n              content =\n                (!unsanitizedContent.startsWith('  ')\n                  ? unsanitizedContent\n                  : unsanitizedContent.slice(2)) + '\\n'\n            }\n          }\n\n          if (!block?.jsx?.import) {\n            // No multiline transformer handled this line successfully\n            return [false, startLineIndex]\n          }\n\n          const markdownToLexical = getMarkdownToLexical(allNodes, allTransformers)\n\n          const blockFields = block.jsx.import({\n            children: content,\n            closeMatch: null,\n            htmlToLexical: null, // TODO\n            markdownToLexical,\n            openMatch: startMatch,\n            props: propsString\n              ? extractPropsFromJSXPropsString({\n                  propsString,\n                })\n              : {},\n          })\n          if (blockFields === false) {\n            return [false, startLineIndex]\n          }\n\n          const node = $createBlockNode({\n            blockType: block.slug,\n            ...blockFields,\n          } as any)\n\n          if (node) {\n            // Now handle beforeStartLine and afterEndLine. If those are not empty, we need to add them as text nodes before and after the block node.\n            // However, those themselves can contain other markdown matches, so we need to parse them as well.\n            // Example where this is needed: \"Hello <InlineCode>inline code</InlineCode> test.\"\n            let prevNodes: null | SerializedLexicalNode[] = null\n            let nextNodes: null | SerializedLexicalNode[] = null\n            // TODO: Might not need this prevNodes and nextNodes handling if inline nodes are handled by textmatch transformers\n\n            if (beforeStartLine?.length) {\n              prevNodes = markdownToLexical({ markdown: beforeStartLine })?.root?.children ?? []\n\n              const firstPrevNode = prevNodes?.[0]\n              if (firstPrevNode) {\n                rootNode.append($parseSerializedNode(firstPrevNode))\n              }\n            }\n\n            rootNode.append(node)\n\n            if (afterEndLine?.length) {\n              nextNodes = markdownToLexical({ markdown: afterEndLine })?.root?.children\n              const lastChild = rootNode.getChildren()[rootNode.getChildren().length - 1]\n\n              const children = ($parseSerializedNode(nextNodes[0]!) as ElementNode)?.getChildren()\n              if (children?.length) {\n                for (const child of children) {\n                  ;(lastChild as ElementNode).append(child)\n                }\n              }\n            }\n          }\n\n          return [true, endLineIndex]\n        },\n    regExpEnd: block.jsx?.customEndRegex ?? regex.regExpEnd,\n    regExpStart: block.jsx?.customStartRegex ?? regex.regExpStart,\n    // This replace is ONLY run for ``` code blocks (so any blocks with custom start and end regexes). For others, we use the special JSX handling above:\n    type: 'multiline-element',\n    replace: (rootNode, children, openMatch, closeMatch, linesInBetween) => {\n      if (block?.jsx?.import) {\n        if (!linesInBetween) {\n          // convert children to linesInBetween\n          let line = ''\n          if (children) {\n            for (const child of children) {\n              line += child.getTextContent()\n            }\n          }\n\n          linesInBetween = [line]\n        }\n\n        let childrenString = ''\n        if (block?.jsx?.doNotTrimChildren) {\n          childrenString = linesInBetween.join('\\n')\n        } else {\n          childrenString = linesInBetween.join('\\n').trim()\n        }\n\n        const propsString = openMatch[1]?.trim()\n\n        const markdownToLexical = getMarkdownToLexical(allNodes, allTransformers)\n\n        const blockFields = block.jsx.import({\n          children: childrenString,\n          closeMatch: closeMatch as RegExpMatchArray,\n          htmlToLexical: null, // TODO\n          markdownToLexical,\n          openMatch: openMatch as RegExpMatchArray,\n          props: propsString\n            ? extractPropsFromJSXPropsString({\n                propsString,\n              })\n            : {},\n        })\n        if (blockFields === false) {\n          return false\n        }\n\n        const node = $createBlockNode({\n          blockType: block.slug,\n          ...blockFields,\n        } as any)\n\n        if (node) {\n          rootNode.append(node)\n        }\n\n        return\n      }\n      return false // Run next transformer\n    },\n  }))\n\n  return toReturn\n}\n"],"mappings":"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","ignoreList":[]}