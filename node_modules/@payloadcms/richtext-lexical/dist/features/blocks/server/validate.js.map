{"version":3,"file":"validate.js","names":["fieldSchemasToFormState","blockValidationHOC","blocks","node","validation","blockFieldData","fields","options","id","collectionSlug","data","operation","preferences","req","block","find","slug","blockType","result","documentData","fieldSchemaMap","undefined","initialBlockData","permissions","renderAllFields","schemaPath","errorPathsSet","Set","fieldKey","fieldState","errorPaths","length","errorPath","add","Array","from","join"],"sources":["../../../../src/features/blocks/server/validate.ts"],"sourcesContent":["import type { Block } from 'payload'\n\nimport { fieldSchemasToFormState } from '@payloadcms/ui/forms/fieldSchemasToFormState'\n\nimport type { NodeValidation } from '../../typesServer.js'\nimport type { BlockFields, SerializedBlockNode } from './nodes/BlocksNode.js'\nimport type { SerializedInlineBlockNode } from './nodes/InlineBlocksNode.js'\n\n/**\n * Runs validation for blocks. This function will determine if the rich text field itself is valid. It does not handle\n * block field error paths - this is done by the `beforeChangeTraverseFields` call in the `beforeChange` hook, called from the\n * rich text adapter.\n */\nexport const blockValidationHOC = (\n  blocks: Block[],\n): NodeValidation<SerializedBlockNode | SerializedInlineBlockNode> => {\n  return async ({ node, validation }) => {\n    const blockFieldData = node.fields ?? ({} as BlockFields)\n\n    const {\n      options: { id, collectionSlug, data, operation, preferences, req },\n    } = validation\n\n    // find block\n    const block = blocks.find((block) => block.slug === blockFieldData.blockType)\n\n    // validate block\n    if (!block) {\n      return `Block ${blockFieldData.blockType} not found`\n    }\n\n    /**\n     * Run fieldSchemasToFormState as that properly validates block and block sub-fields\n     */\n\n    const result = await fieldSchemasToFormState({\n      id,\n      collectionSlug,\n      data: blockFieldData,\n      documentData: data,\n      fields: block.fields,\n      fieldSchemaMap: undefined,\n      initialBlockData: blockFieldData,\n      operation: operation === 'create' || operation === 'update' ? operation : 'update',\n      permissions: {},\n      preferences,\n      renderAllFields: false,\n      req,\n      schemaPath: '',\n    })\n\n    const errorPathsSet = new Set<string>()\n    for (const fieldKey in result) {\n      const fieldState = result[fieldKey]\n      if (fieldState?.errorPaths?.length) {\n        for (const errorPath of fieldState.errorPaths) {\n          errorPathsSet.add(errorPath)\n        }\n      }\n    }\n    const errorPaths = Array.from(errorPathsSet)\n\n    if (errorPaths.length) {\n      return 'The following fields are invalid: ' + errorPaths.join(', ')\n    }\n\n    return true\n  }\n}\n"],"mappings":"AAEA,SAASA,uBAAuB,QAAQ;AAMxC;;;;;AAKA,OAAO,MAAMC,kBAAA,GACXC,MAAA;EAEA,OAAO,OAAO;IAAEC,IAAI;IAAEC;EAAU,CAAE;IAChC,MAAMC,cAAA,GAAiBF,IAAA,CAAKG,MAAM,IAAK,CAAC;IAExC,MAAM;MACJC,OAAA,EAAS;QAAEC,EAAE;QAAEC,cAAc;QAAEC,IAAI;QAAEC,SAAS;QAAEC,WAAW;QAAEC;MAAG;IAAE,CACnE,GAAGT,UAAA;IAEJ;IACA,MAAMU,KAAA,GAAQZ,MAAA,CAAOa,IAAI,CAAED,KAAA,IAAUA,KAAA,CAAME,IAAI,KAAKX,cAAA,CAAeY,SAAS;IAE5E;IACA,IAAI,CAACH,KAAA,EAAO;MACV,OAAO,SAAST,cAAA,CAAeY,SAAS,YAAY;IACtD;IAEA;;;IAIA,MAAMC,MAAA,GAAS,MAAMlB,uBAAA,CAAwB;MAC3CQ,EAAA;MACAC,cAAA;MACAC,IAAA,EAAML,cAAA;MACNc,YAAA,EAAcT,IAAA;MACdJ,MAAA,EAAQQ,KAAA,CAAMR,MAAM;MACpBc,cAAA,EAAgBC,SAAA;MAChBC,gBAAA,EAAkBjB,cAAA;MAClBM,SAAA,EAAWA,SAAA,KAAc,YAAYA,SAAA,KAAc,WAAWA,SAAA,GAAY;MAC1EY,WAAA,EAAa,CAAC;MACdX,WAAA;MACAY,eAAA,EAAiB;MACjBX,GAAA;MACAY,UAAA,EAAY;IACd;IAEA,MAAMC,aAAA,GAAgB,IAAIC,GAAA;IAC1B,KAAK,MAAMC,QAAA,IAAYV,MAAA,EAAQ;MAC7B,MAAMW,UAAA,GAAaX,MAAM,CAACU,QAAA,CAAS;MACnC,IAAIC,UAAA,EAAYC,UAAA,EAAYC,MAAA,EAAQ;QAClC,KAAK,MAAMC,SAAA,IAAaH,UAAA,CAAWC,UAAU,EAAE;UAC7CJ,aAAA,CAAcO,GAAG,CAACD,SAAA;QACpB;MACF;IACF;IACA,MAAMF,UAAA,GAAaI,KAAA,CAAMC,IAAI,CAACT,aAAA;IAE9B,IAAII,UAAA,CAAWC,MAAM,EAAE;MACrB,OAAO,uCAAuCD,UAAA,CAAWM,IAAI,CAAC;IAChE;IAEA,OAAO;EACT;AACF","ignoreList":[]}