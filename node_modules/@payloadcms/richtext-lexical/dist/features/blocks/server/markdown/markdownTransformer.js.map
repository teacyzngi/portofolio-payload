{"version":3,"file":"markdownTransformer.js","names":["$parseSerializedNode","getEnabledNodesFromServerNodes","extractPropsFromJSXPropsString","propsToJSXString","getLexicalToMarkdown","getMarkdownToLexical","$createServerBlockNode","$isServerBlockNode","ServerBlockNode","$createServerInlineBlockNode","$isServerInlineBlockNode","ServerInlineBlockNode","linesFromStartToContentAndPropsString","createTagRegexes","tagName","escapedTagName","replace","openingTag","closingTag","optionalWhitespace","mandatoryClosingBracket","startPattern","endPattern","regExpEnd","RegExp","regExpStart","getBlockMarkdownTransformers","blocks","inlineBlocks","length","transformers","block","transformer","getMarkdownTransformerForBlock","concat","isInlineBlock","jsx","regex","slug","toReturn","push","allNodes","allTransformers","type","dependencies","export","node","getFields","blockType","toLowerCase","nodeFields","lexicalToMarkdown","nodes","exportResult","fields","hasProps","props","Object","keys","children","getEndIndex","match","endlineLastCharIndex","isEndOptional","lines","getTextContent","regexpEndRegex","startLineIndex","startMatch","trimChildren","importRegExp","customStartRegex","regExp","content","propsString","index","import","markdownToLexical","blockFields","closeMatch","htmlToLexical","openMatch","inlineBlockNode","sanitizedChildren","includes","child","split","sanitizedChild","doNotTrimChildren","handleImportAfterStartMatch","customEndRegex","undefined","rootNode","optional","afterEndLine","beforeStartLine","unsanitizedContent","endLineIndex","endsWith","slice","startsWith","prevNodes","nextNodes","markdown","root","firstPrevNode","append","lastChild","getChildren","linesInBetween","line","childrenString","join","trim"],"sources":["../../../../../src/features/blocks/server/markdown/markdownTransformer.ts"],"sourcesContent":["import type { ElementNode, SerializedLexicalNode } from 'lexical'\nimport type { Block } from 'payload'\n\nimport { $parseSerializedNode } from 'lexical'\n\nimport type { NodeWithHooks } from '../../../typesServer.js'\n\nimport { getEnabledNodesFromServerNodes } from '../../../../lexical/nodes/index.js'\nimport {\n  type MultilineElementTransformer,\n  type TextMatchTransformer,\n  type Transformer,\n} from '../../../../packages/@lexical/markdown/index.js'\nimport { extractPropsFromJSXPropsString } from '../../../../utilities/jsx/extractPropsFromJSXPropsString.js'\nimport { propsToJSXString } from '../../../../utilities/jsx/jsx.js'\nimport { getLexicalToMarkdown } from '../../client/markdown/getLexicalToMarkdown.js'\nimport { getMarkdownToLexical } from '../../client/markdown/getMarkdownToLexical.js'\nimport { $createServerBlockNode, $isServerBlockNode, ServerBlockNode } from '../nodes/BlocksNode.js'\nimport {\n  $createServerInlineBlockNode,\n  $isServerInlineBlockNode,\n  ServerInlineBlockNode,\n} from '../nodes/InlineBlocksNode.js'\nimport { linesFromStartToContentAndPropsString } from './linesFromMatchToContentAndPropsString.js'\n\nexport function createTagRegexes(tagName: string) {\n  const escapedTagName = tagName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n\n  // Regex components\n  const openingTag = `<${escapedTagName}`\n  const closingTag = `</${escapedTagName}`\n  const optionalWhitespace = `\\\\s*`\n  const mandatoryClosingBracket = `>`\n\n  // Assembled regex patterns\n  const startPattern = `${openingTag}(?=\\\\s|>|$)` // Only match the tag name\n  const endPattern = `${closingTag}${optionalWhitespace}${mandatoryClosingBracket}`\n\n  return {\n    regExpEnd: new RegExp(endPattern, 'i'),\n    regExpStart: new RegExp(startPattern, 'i'),\n  }\n}\nexport const getBlockMarkdownTransformers = ({\n  blocks,\n  inlineBlocks,\n}: {\n  blocks: Block[]\n  inlineBlocks: Block[]\n}): ((props: {\n  allNodes: Array<NodeWithHooks>\n  allTransformers: Transformer[]\n}) => MultilineElementTransformer | TextMatchTransformer)[] => {\n  if (!blocks?.length && !inlineBlocks?.length) {\n    return []\n  }\n\n  let transformers: ((props: {\n    allNodes: Array<NodeWithHooks>\n    allTransformers: Transformer[]\n  }) => MultilineElementTransformer | TextMatchTransformer)[] = []\n\n  if (blocks?.length) {\n    for (const block of blocks) {\n      const transformer = getMarkdownTransformerForBlock(block, false)\n\n      if (transformer) {\n        transformers = transformers.concat(transformer)\n      }\n    }\n  }\n\n  if (inlineBlocks?.length) {\n    for (const block of inlineBlocks) {\n      const transformer = getMarkdownTransformerForBlock(block, true)\n\n      if (transformer) {\n        transformers = transformers.concat(transformer)\n      }\n    }\n  }\n\n  return transformers\n}\n\nfunction getMarkdownTransformerForBlock(\n  block: Block,\n  isInlineBlock: boolean,\n): Array<\n  (props: {\n    allNodes: Array<NodeWithHooks>\n    allTransformers: Transformer[]\n  }) => MultilineElementTransformer | TextMatchTransformer\n> | null {\n  if (!block.jsx) {\n    return null\n  }\n\n  const regex = createTagRegexes(block.slug)\n  const toReturn: Array<\n    (props: {\n      allNodes: Array<NodeWithHooks>\n      allTransformers: Transformer[]\n    }) => MultilineElementTransformer | TextMatchTransformer\n  > = []\n\n  if (isInlineBlock) {\n    toReturn.push(({ allNodes, allTransformers }) => ({\n      type: 'text-match',\n      dependencies: [ServerInlineBlockNode],\n      export: (node) => {\n        if (!$isServerInlineBlockNode(node)) {\n          return null\n        }\n\n        if (node.getFields()?.blockType?.toLowerCase() !== block.slug.toLowerCase()) {\n          return null\n        }\n\n        const nodeFields = node.getFields()\n        const lexicalToMarkdown = getLexicalToMarkdown(\n          getEnabledNodesFromServerNodes({\n            nodes: allNodes,\n          }),\n          allTransformers,\n        )\n\n        const exportResult = block.jsx!.export({\n          fields: nodeFields,\n          lexicalToMarkdown,\n        })\n        if (exportResult === false) {\n          return null\n        }\n        if (typeof exportResult === 'string') {\n          return exportResult\n        }\n\n        const hasProps = exportResult.props && Object.keys(exportResult.props)?.length > 0\n        const props = exportResult.props ?? {}\n\n        if (exportResult?.children?.length) {\n          return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}>${exportResult.children}</${nodeFields.blockType}>`\n        }\n\n        return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}/>`\n      },\n      getEndIndex: (node, match) => {\n        const { endlineLastCharIndex } = linesFromStartToContentAndPropsString({\n          isEndOptional: false,\n          lines: [node.getTextContent()],\n          regexpEndRegex: regex.regExpEnd,\n          startLineIndex: 0,\n          startMatch: match,\n          trimChildren: false,\n        })\n\n        return endlineLastCharIndex\n      },\n      importRegExp: block.jsx?.customStartRegex ?? regex.regExpStart,\n      regExp: /___ignoreignoreignore___/g,\n      replace(node, match) {\n        const { content, propsString } = linesFromStartToContentAndPropsString({\n          isEndOptional: false,\n          lines: [node.getTextContent()],\n          regexpEndRegex: regex.regExpEnd,\n          startLineIndex: 0,\n          startMatch: {\n            ...match,\n            index: 0,\n          },\n          trimChildren: false,\n        })\n\n        if (!block?.jsx?.import) {\n          // No multiline transformer handled this line successfully\n          return\n        }\n\n        const markdownToLexical = getMarkdownToLexical(\n          getEnabledNodesFromServerNodes({\n            nodes: allNodes,\n          }),\n          allTransformers,\n        )\n\n        const blockFields = block.jsx.import({\n          children: content,\n          closeMatch: null,\n          htmlToLexical: null, // TODO\n          markdownToLexical,\n          openMatch: match,\n          props: propsString\n            ? extractPropsFromJSXPropsString({\n                propsString,\n              })\n            : {},\n        })\n        if (blockFields === false) {\n          return\n        }\n\n        const inlineBlockNode = $createServerInlineBlockNode({\n          blockType: block.slug,\n          ...(blockFields as any),\n        })\n\n        node.replace(inlineBlockNode)\n      },\n    }))\n\n    return toReturn\n  }\n\n  toReturn.push(({ allNodes, allTransformers }) => ({\n    dependencies: [ServerBlockNode],\n    export: (node) => {\n      if (!$isServerBlockNode(node)) {\n        return null\n      }\n\n      if (node.getFields()?.blockType?.toLowerCase() !== block.slug.toLowerCase()) {\n        return null\n      }\n\n      const nodeFields = node.getFields()\n      const lexicalToMarkdown = getLexicalToMarkdown(\n        getEnabledNodesFromServerNodes({\n          nodes: allNodes,\n        }),\n        allTransformers,\n      )\n\n      const exportResult = block.jsx!.export({\n        fields: nodeFields,\n        lexicalToMarkdown,\n      })\n      if (exportResult === false) {\n        return null\n      }\n      if (typeof exportResult === 'string') {\n        return exportResult\n      }\n\n      const hasProps = exportResult.props && Object.keys(exportResult.props)?.length > 0\n      const props = exportResult.props ?? {}\n\n      if (exportResult?.children?.length) {\n        const children = exportResult.children\n        let sanitizedChildren = ''\n\n        // Ensure it has a leftpad of at least 2 spaces. The data is saved without those spaces, so we can just blindly add it to every child\n        if (children.includes('\\n')) {\n          for (const child of children.split('\\n')) {\n            let sanitizedChild = ''\n            if (!block?.jsx?.doNotTrimChildren && child !== '') {\n              sanitizedChild = '  '\n            }\n            sanitizedChild += child + '\\n'\n\n            sanitizedChildren += sanitizedChild\n          }\n        } else {\n          sanitizedChildren = (block?.jsx?.doNotTrimChildren ? '' : '  ') + children + '\\n'\n        }\n\n        return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}>\\n${sanitizedChildren}</${nodeFields.blockType}>`\n      }\n\n      return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}/>`\n    },\n    handleImportAfterStartMatch: block.jsx?.customEndRegex\n      ? undefined\n      : ({ lines, rootNode, startLineIndex, startMatch, transformer }) => {\n          const regexpEndRegex: RegExp | undefined =\n            typeof transformer.regExpEnd === 'object' && 'regExp' in transformer.regExpEnd\n              ? transformer.regExpEnd.regExp\n              : transformer.regExpEnd\n\n          const isEndOptional =\n            transformer.regExpEnd &&\n            typeof transformer.regExpEnd === 'object' &&\n            'optional' in transformer.regExpEnd\n              ? transformer.regExpEnd.optional\n              : !transformer.regExpEnd\n\n          const {\n            afterEndLine,\n            beforeStartLine,\n            content: unsanitizedContent,\n            endLineIndex,\n            propsString,\n          } = linesFromStartToContentAndPropsString({\n            isEndOptional,\n            lines,\n            regexpEndRegex,\n            startLineIndex,\n            startMatch,\n            trimChildren: false,\n          })\n\n          let content = ''\n\n          if (block?.jsx?.doNotTrimChildren) {\n            content = unsanitizedContent.endsWith('\\n')\n              ? unsanitizedContent.slice(0, -1)\n              : unsanitizedContent\n          } else {\n            // Ensure it has a leftpad of at least 2 spaces. The data is saved without those spaces, so we can just blindly add it to every child\n            if (unsanitizedContent.includes('\\n')) {\n              const split = unsanitizedContent.split('\\n')\n              let index = 0\n              for (const child of split) {\n                index++\n\n                if (child.startsWith('  ')) {\n                  content += child.slice(2)\n                } else {\n                  // If one child is misaligned, skip aligning completely, unless it's just empty\n                  if (child === '') {\n                    content += child\n                  } else {\n                    content = unsanitizedContent.endsWith('\\n')\n                      ? unsanitizedContent.slice(0, -1)\n                      : unsanitizedContent\n                    break\n                  }\n                }\n\n                content += index === split.length ? '' : '\\n'\n              }\n            } else {\n              content =\n                (!unsanitizedContent.startsWith('  ')\n                  ? unsanitizedContent\n                  : unsanitizedContent.slice(2)) + '\\n'\n            }\n          }\n\n          if (!block?.jsx?.import) {\n            // No multiline transformer handled this line successfully\n            return [false, startLineIndex]\n          }\n\n          const markdownToLexical = getMarkdownToLexical(\n            getEnabledNodesFromServerNodes({\n              nodes: allNodes,\n            }),\n            allTransformers,\n          )\n\n          const blockFields = block.jsx.import({\n            children: content,\n            closeMatch: null,\n            htmlToLexical: null, // TODO\n            markdownToLexical,\n            openMatch: startMatch,\n            props: propsString\n              ? extractPropsFromJSXPropsString({\n                  propsString,\n                })\n              : {},\n          })\n          if (blockFields === false) {\n            return [false, startLineIndex]\n          }\n\n          const node = $createServerBlockNode({\n            blockType: block.slug,\n            ...blockFields,\n          } as any)\n\n          if (node) {\n            // Now handle beforeStartLine and afterEndLine. If those are not empty, we need to add them as text nodes before and after the block node.\n            // However, those themselves can contain other markdown matches, so we need to parse them as well.\n            // Example where this is needed: \"Hello <InlineCode>inline code</InlineCode> test.\"\n            let prevNodes: null | SerializedLexicalNode[] = null\n            let nextNodes: null | SerializedLexicalNode[] = null\n            // TODO: Might not need this prevNodes and nextNodes handling if inline nodes are handled by textmatch transformers\n\n            if (beforeStartLine?.length) {\n              prevNodes = markdownToLexical({ markdown: beforeStartLine })?.root?.children ?? []\n\n              const firstPrevNode = prevNodes?.[0]\n              if (firstPrevNode) {\n                rootNode.append($parseSerializedNode(firstPrevNode))\n              }\n            }\n\n            rootNode.append(node)\n\n            if (afterEndLine?.length) {\n              nextNodes = markdownToLexical({ markdown: afterEndLine })?.root?.children\n              const lastChild = rootNode.getChildren()[rootNode.getChildren().length - 1]\n\n              const children = ($parseSerializedNode(nextNodes[0]!) as ElementNode)?.getChildren()\n              if (children?.length) {\n                for (const child of children) {\n                  ;(lastChild as ElementNode).append(child)\n                }\n              }\n            }\n          }\n\n          return [true, endLineIndex]\n        },\n    regExpEnd: block.jsx?.customEndRegex ?? regex.regExpEnd,\n    regExpStart: block.jsx?.customStartRegex ?? regex.regExpStart,\n    // This replace is ONLY run for ``` code blocks (so any blocks with custom start and end regexes). For others, we use the special JSX handling above:\n    type: 'multiline-element',\n    replace: (rootNode, children, openMatch, closeMatch, linesInBetween) => {\n      if (block?.jsx?.import) {\n        if (!linesInBetween) {\n          // convert children to linesInBetween\n          let line = ''\n          if (children) {\n            for (const child of children) {\n              line += child.getTextContent()\n            }\n          }\n\n          linesInBetween = [line]\n        }\n\n        let childrenString = ''\n        if (block?.jsx?.doNotTrimChildren) {\n          childrenString = linesInBetween.join('\\n')\n        } else {\n          childrenString = linesInBetween.join('\\n').trim()\n        }\n\n        const propsString = openMatch[1]?.trim()\n\n        const markdownToLexical = getMarkdownToLexical(\n          getEnabledNodesFromServerNodes({\n            nodes: allNodes,\n          }),\n          allTransformers,\n        )\n\n        const blockFields = block.jsx.import({\n          children: childrenString,\n          closeMatch: closeMatch as RegExpMatchArray,\n          htmlToLexical: null, // TODO\n          markdownToLexical,\n          openMatch: openMatch as RegExpMatchArray,\n          props: propsString\n            ? extractPropsFromJSXPropsString({\n                propsString,\n              })\n            : {},\n        })\n        if (blockFields === false) {\n          return false\n        }\n\n        const node = $createServerBlockNode({\n          blockType: block.slug,\n          ...blockFields,\n        } as any)\n\n        if (node) {\n          rootNode.append(node)\n        }\n\n        return\n      }\n      return false // Run next transformer\n    },\n  }))\n\n  return toReturn\n}\n"],"mappings":"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","ignoreList":[]}