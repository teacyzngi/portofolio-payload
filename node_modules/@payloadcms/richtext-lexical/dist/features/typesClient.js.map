{"version":3,"file":"typesClient.js","names":[],"sources":["../../src/features/typesClient.ts"],"sourcesContent":["import type {\n  Klass,\n  LexicalEditor,\n  LexicalNode,\n  LexicalNodeReplacement,\n  TextFormatType,\n} from 'lexical'\nimport type { ClientConfig, RichTextFieldClient } from 'payload'\nimport type React from 'react'\nimport type { JSX } from 'react'\n\nimport type { ClientEditorConfig } from '../lexical/config/types.js'\nimport type { SlashMenuGroup } from '../lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/types.js'\nimport type { Transformer } from '../packages/@lexical/markdown/index.js'\nimport type { FeatureClientSchemaMap } from '../types.js'\nimport type { ToolbarGroup } from './toolbars/types.js'\n\nexport type FeatureProviderProviderClient<\n  UnSanitizedClientFeatureProps = undefined,\n  ClientFeatureProps = UnSanitizedClientFeatureProps,\n> = (props: BaseClientFeatureProps<ClientFeatureProps>) => FeatureProviderClient<ClientFeatureProps>\n\n/**\n * No dependencies => Features need to be sorted on the server first, then sent to client in right order\n */\nexport type FeatureProviderClient<\n  UnSanitizedClientFeatureProps = undefined,\n  ClientFeatureProps = UnSanitizedClientFeatureProps,\n> = {\n  /**\n   * Return props, to make it easy to retrieve passed in props to this Feature for the client if anyone wants to\n   */\n  clientFeatureProps: BaseClientFeatureProps<UnSanitizedClientFeatureProps>\n  feature:\n    | ((props: {\n        config: ClientConfig\n        featureClientImportMap: Record<string, any>\n        featureClientSchemaMap: FeatureClientSchemaMap\n        /** unSanitizedEditorConfig.features, but mapped */\n        featureProviderMap: ClientFeatureProviderMap\n        field?: RichTextFieldClient\n        // other resolved features, which have been loaded before this one. All features declared in 'dependencies' should be available here\n        resolvedFeatures: ResolvedClientFeatureMap\n        schemaPath: string\n        // unSanitized EditorConfig,\n        unSanitizedEditorConfig: ClientEditorConfig\n      }) => ClientFeature<ClientFeatureProps>)\n    | ClientFeature<ClientFeatureProps>\n}\n\nexport type PluginComponent<ClientFeatureProps = any> = React.FC<{\n  clientProps: ClientFeatureProps\n}>\nexport type PluginComponentWithAnchor<ClientFeatureProps = any> = React.FC<{\n  anchorElem: HTMLElement\n  clientProps: ClientFeatureProps\n}>\n\n/**\n * Plugins are react components which get added to the editor. You can use them to interact with lexical, e.g. to create a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n */\nexport type SanitizedPlugin =\n  | {\n      clientProps: any\n      // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n      Component: PluginComponent\n      key: string\n      position: 'bottom' // Determines at which position the Component will be added.\n    }\n  | {\n      clientProps: any\n      // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n      Component: PluginComponent\n      key: string\n      position: 'normal' // Determines at which position the Component will be added.\n    }\n  | {\n      clientProps: any\n      // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n      Component: PluginComponent\n      key: string\n      position: 'top' // Determines at which position the Component will be added.\n    }\n  | {\n      clientProps: any\n      // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n      Component: PluginComponentWithAnchor\n      desktopOnly?: boolean\n      key: string\n      position: 'floatingAnchorElem' // Determines at which position the Component will be added.\n    }\n  | {\n      clientProps: any\n      Component: PluginComponent\n      key: string\n      position: 'aboveContainer'\n    }\n  | {\n      clientProps: any\n      Component: PluginComponent\n      key: string\n      position: 'belowContainer'\n    }\n\nexport type ClientFeature<ClientFeatureProps> = {\n  /**\n   * The text formats which are enabled by this feature.\n   */\n  enableFormats?: TextFormatType[]\n  markdownTransformers?: (\n    | ((props: {\n        allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n        allTransformers: Transformer[]\n      }) => Transformer)\n    | Transformer\n  )[]\n  nodes?: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n  /**\n   * Plugins are react components which get added to the editor. You can use them to interact with lexical, e.g. to create a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n   */\n  plugins?: Array<\n    | {\n        // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n        Component: PluginComponent<ClientFeatureProps>\n        position: 'aboveContainer' // Determines at which position the Component will be added.\n      }\n    | {\n        // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n        Component: PluginComponent<ClientFeatureProps>\n        position: 'bottom' // Determines at which position the Component will be added.\n      }\n    | {\n        // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n        Component: PluginComponent<ClientFeatureProps>\n        position: 'normal' // Determines at which position the Component will be added.\n      }\n    | {\n        // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n        Component: PluginComponent<ClientFeatureProps>\n        position: 'top' // Determines at which position the Component will be added.\n      }\n    | {\n        // plugins are anything which is not directly part of the editor. Like, creating a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n        Component: PluginComponentWithAnchor<ClientFeatureProps>\n        position: 'floatingAnchorElem' // Determines at which position the Component will be added.\n      }\n    | {\n        Component: PluginComponent<ClientFeatureProps>\n        position: 'belowContainer' // Determines at which position the Component will be added.\n      }\n  >\n  /**\n   * Client Features can register their own providers, which will be nested below the EditorConfigProvider\n   */\n  providers?: Array<React.FC<{ children: JSX.Element }>>\n  /**\n   * Return props, to make it easy to retrieve passed in props to this Feature for the client if anyone wants to\n   */\n  sanitizedClientFeatureProps?: BaseClientFeatureProps<ClientFeatureProps>\n  slashMenu?: {\n    /**\n     * Dynamic groups allow you to add different groups depending on the query string (so, the text after the slash).\n     * Thus, to re-calculate the available groups, this function will be called every time you type after the /.\n     *\n     * The groups provided by dynamicGroups will be merged with the static groups provided by the groups property.\n     */\n    dynamicGroups?: ({\n      editor,\n      queryString,\n    }: {\n      editor: LexicalEditor\n      queryString: string\n    }) => SlashMenuGroup[]\n    /**\n     * Static array of groups together with the items in them. These will always be present.\n     * While typing after the /, they will be filtered by the query string and the keywords, key and display name of the items.\n     */\n    groups?: SlashMenuGroup[]\n  }\n  /**\n   * An opt-in, classic fixed toolbar which stays at the top of the editor\n   */\n  toolbarFixed?: {\n    groups: ToolbarGroup[]\n  }\n  /**\n   * The default, floating toolbar which appears when you select text.\n   */\n  toolbarInline?: {\n    /**\n     * Array of toolbar groups / sections. Each section can contain multiple toolbar items.\n     */\n    groups: ToolbarGroup[]\n  }\n}\n\nexport type BaseClientFeatureProps<ClientFeatureProps> = ClientFeatureProps extends undefined\n  ? {\n      featureKey: string\n      order: number\n    }\n  : {\n      featureKey: string\n      order: number\n    } & ClientFeatureProps\n\nexport type ResolvedClientFeature<ClientFeatureProps> = {\n  key: string\n  order: number\n} & ClientFeature<ClientFeatureProps>\n\nexport type ResolvedClientFeatureMap = Map<string, ResolvedClientFeature<any>>\n\nexport type ClientFeatureProviderMap = Map<string, FeatureProviderClient<any, any>>\n\nexport type SanitizedClientFeatures = {\n  /** The keys of all enabled features */\n  enabledFeatures: string[]\n  enabledFormats: TextFormatType[]\n  markdownTransformers: Transformer[]\n\n  /**\n   * Plugins are react components which get added to the editor. You can use them to interact with lexical, e.g. to create a command which creates a node, or opens a modal, or some other more \"outside\" functionality\n   */\n  plugins?: Array<SanitizedPlugin>\n  slashMenu: {\n    /**\n     * Dynamic groups allow you to add different groups depending on the query string (so, the text after the slash).\n     * Thus, to re-calculate the available groups, this function will be called every time you type after the /.\n     *\n     * The groups provided by dynamicGroups will be merged with the static groups provided by the groups property.\n     */\n    dynamicGroups: Array<\n      ({ editor, queryString }: { editor: LexicalEditor; queryString: string }) => SlashMenuGroup[]\n    >\n    /**\n     * Static array of groups together with the items in them. These will always be present.\n     * While typing after the /, they will be filtered by the query string and the keywords, key and display name of the items.\n     */\n    groups: SlashMenuGroup[]\n  }\n} & Required<\n  Pick<ResolvedClientFeature<unknown>, 'nodes' | 'providers' | 'toolbarFixed' | 'toolbarInline'>\n>\n"],"mappings":"AAuNA","ignoreList":[]}