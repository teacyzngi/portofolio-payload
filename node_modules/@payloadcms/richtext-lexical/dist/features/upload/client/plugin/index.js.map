{"version":3,"file":"index.js","names":["c","_c","useLexicalComposerContext","$dfsIterator","$insertNodeToNearestRoot","mergeRegister","useBulkUpload","useEffectEvent","useModal","ObjectID","$createRangeSelection","$getPreviousSelection","$getSelection","$isParagraphNode","$isRangeSelection","$setSelection","COMMAND_PRIORITY_EDITOR","COMMAND_PRIORITY_LOW","createCommand","DROP_COMMAND","getDOMSelectionFromTarget","isHTMLElement","PASTE_COMMAND","React","useEffect","useEnabledRelationships","UploadDrawer","$createUploadNode","$isUploadNode","UploadNode","canDropImage","event","target","closest","parentElement","getDragSelection","range","domSelection","document","caretRangeFromPoint","clientX","clientY","rangeParent","collapse","rangeOffset","getRangeAt","Error","INSERT_UPLOAD_COMMAND","UploadPlugin","t0","$","clientProps","editor","t1","disabledCollections","t2","enabledCollections","t3","collectionSlugsBlacklist","collectionSlugsWhitelist","uploads","enabledCollectionSlugs","drawerSlug","bulkUploadDrawerSlug","setCollectionSlug","setInitialForms","setOnCancel","setOnSuccess","setSelectableCollections","isModalOpen","openModal","t4","t5","files","length","initialForms","map","_temp","update","_temp2","newDocs","newDocsMap","Map","_temp3","dfsNode_0","node_0","dfsNode","node","nodeData_0","getData","nodeData","pending","newDoc","get","formID","replace","data","id","default","toHexString","fields","relationTo","collectionSlug","value","doc","openBulkUpload","hasNodes","registerNodeTransform","node_1","nodeData_1","upload","transformedImage","src","startsWith","mimeMatch","match","mimeType","base64Data","byteCharacters","atob","byteNumbers","Array","i","charCodeAt","byteArray","Uint8Array","file_0","File","split","type","file","res","fetch","blob","inferredFileName","pop","file_1","registerCommand","payload","selection","uploadNode","focus","focusNode","getNode","__first","remove","ClipboardEvent","clipboardData","types","includes","files_0","from","forEach","file_2","push","alt","selection_0","file_3","pendingUploadNode","URL","createObjectURL","focus_0","focusNode_0","event_0","DragEvent","dt","dataTransfer","files_1","file_4","preventDefault","stopPropagation","selection_1","undefined","applyDOMRange","file_5","pendingUploadNode_0","focus_1","focusNode_1","t6","t7","_jsx"],"sources":["../../../../../src/features/upload/client/plugin/index.tsx"],"sourcesContent":["'use client'\nimport type { LexicalCommand } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { $dfsIterator, $insertNodeToNearestRoot, mergeRegister } from '@lexical/utils'\nimport { useBulkUpload, useEffectEvent, useModal } from '@payloadcms/ui'\nimport ObjectID from 'bson-objectid'\nimport {\n  $createRangeSelection,\n  $getPreviousSelection,\n  $getSelection,\n  $isParagraphNode,\n  $isRangeSelection,\n  $setSelection,\n  COMMAND_PRIORITY_EDITOR,\n  COMMAND_PRIORITY_LOW,\n  createCommand,\n  DROP_COMMAND,\n  getDOMSelectionFromTarget,\n  isHTMLElement,\n  PASTE_COMMAND,\n} from 'lexical'\nimport React, { useEffect } from 'react'\n\nimport type { PluginComponent } from '../../../typesClient.js'\nimport type { Internal_UploadData, UploadData } from '../../server/nodes/UploadNode.js'\nimport type { UploadFeaturePropsClient } from '../index.js'\n\nimport { useEnabledRelationships } from '../../../relationship/client/utils/useEnabledRelationships.js'\nimport { UploadDrawer } from '../drawer/index.js'\nimport { $createUploadNode, $isUploadNode, UploadNode } from '../nodes/UploadNode.js'\n\nexport type InsertUploadPayload = Readonly<Omit<UploadData, 'id'> & Partial<Pick<UploadData, 'id'>>>\n\ndeclare global {\n  interface DragEvent {\n    rangeOffset?: number\n    rangeParent?: Node\n  }\n}\n\nfunction canDropImage(event: DragEvent): boolean {\n  const target = event.target\n  return !!(\n    isHTMLElement(target) &&\n    !target.closest('code, span.editor-image') &&\n    isHTMLElement(target.parentElement) &&\n    target.parentElement.closest('div.ContentEditable__root')\n  )\n}\n\nfunction getDragSelection(event: DragEvent): null | Range | undefined {\n  // Source: https://github.com/AlessioGr/lexical/blob/main/packages/lexical-playground/src/plugins/ImagesPlugin/index.tsx\n  let range\n  const domSelection = getDOMSelectionFromTarget(event.target)\n  if (document.caretRangeFromPoint) {\n    range = document.caretRangeFromPoint(event.clientX, event.clientY)\n  } else if (event.rangeParent && domSelection !== null) {\n    domSelection.collapse(event.rangeParent, event.rangeOffset || 0)\n    range = domSelection.getRangeAt(0)\n  } else {\n    throw Error(`Cannot get the selection when dragging`)\n  }\n\n  return range\n}\n\nexport const INSERT_UPLOAD_COMMAND: LexicalCommand<InsertUploadPayload> =\n  createCommand('INSERT_UPLOAD_COMMAND')\n\ntype FileToUpload = {\n  alt?: string\n  file: File\n  /**\n   * Bulk Upload Form ID that should be created, which can then be matched\n   * against the node formID if the upload is successful\n   */\n  formID: string\n}\n\nexport const UploadPlugin: PluginComponent<UploadFeaturePropsClient> = ({ clientProps }) => {\n  const [editor] = useLexicalComposerContext()\n\n  const { enabledCollectionSlugs } = useEnabledRelationships({\n    collectionSlugsBlacklist: clientProps?.disabledCollections,\n    collectionSlugsWhitelist: clientProps?.enabledCollections,\n    uploads: true,\n  })\n\n  const {\n    drawerSlug: bulkUploadDrawerSlug,\n    setCollectionSlug,\n    setInitialForms,\n    setOnCancel,\n    setOnSuccess,\n    setSelectableCollections,\n  } = useBulkUpload()\n\n  const { isModalOpen, openModal } = useModal()\n\n  const openBulkUpload = useEffectEvent(({ files }: { files: FileToUpload[] }) => {\n    if (files?.length === 0) {\n      return\n    }\n\n    setInitialForms((initialForms) => [\n      ...(initialForms ?? []),\n      ...files.map((file) => ({\n        file: file.file,\n        formID: file.formID,\n      })),\n    ])\n\n    if (!isModalOpen(bulkUploadDrawerSlug)) {\n      if (!enabledCollectionSlugs.length || !enabledCollectionSlugs[0]) {\n        return\n      }\n\n      setCollectionSlug(enabledCollectionSlugs[0])\n      setSelectableCollections(enabledCollectionSlugs)\n\n      setOnCancel(() => {\n        // Remove all the pending upload nodes that were added but not uploaded\n        editor.update(() => {\n          for (const dfsNode of $dfsIterator()) {\n            const node = dfsNode.node\n\n            if ($isUploadNode(node)) {\n              const nodeData = node.getData()\n              if ((nodeData as Internal_UploadData)?.pending) {\n                node.remove()\n              }\n            }\n          }\n        })\n      })\n\n      setOnSuccess((newDocs) => {\n        const newDocsMap = new Map(newDocs.map((doc) => [doc.formID, doc]))\n        editor.update(() => {\n          for (const dfsNode of $dfsIterator()) {\n            const node = dfsNode.node\n            if ($isUploadNode(node)) {\n              const nodeData: Internal_UploadData = node.getData()\n\n              if (nodeData?.pending) {\n                const newDoc = newDocsMap.get(nodeData.pending?.formID)\n                if (newDoc) {\n                  node.replace(\n                    $createUploadNode({\n                      data: {\n                        id: new ObjectID.default().toHexString(),\n                        fields: {},\n                        relationTo: newDoc.collectionSlug,\n                        value: newDoc.doc.id,\n                      } as UploadData,\n                    }),\n                  )\n                }\n              }\n            }\n          }\n        })\n      })\n\n      openModal(bulkUploadDrawerSlug)\n    }\n  })\n\n  useEffect(() => {\n    if (!editor.hasNodes([UploadNode])) {\n      throw new Error('UploadPlugin: UploadNode not registered on editor')\n    }\n\n    return mergeRegister(\n      /**\n       * Handle auto-uploading files if you copy & paste an image dom element from the clipboard\n       */\n      editor.registerNodeTransform(UploadNode, (node) => {\n        const nodeData: Internal_UploadData = node.getData()\n        if (!nodeData?.pending) {\n          return\n        }\n\n        async function upload() {\n          let transformedImage: FileToUpload | null = null\n\n          const src = nodeData?.pending?.src\n          const formID = nodeData?.pending?.formID as string\n\n          if (src?.startsWith('data:')) {\n            // It's a base64-encoded image\n            const mimeMatch = src.match(/data:(image\\/[a-zA-Z]+);base64,/)\n            const mimeType = mimeMatch ? mimeMatch[1] : 'image/png' // Default to PNG if MIME type not found\n            const base64Data = src.replace(/^data:image\\/[a-zA-Z]+;base64,/, '')\n            const byteCharacters = atob(base64Data)\n            const byteNumbers = new Array(byteCharacters.length)\n            for (let i = 0; i < byteCharacters.length; i++) {\n              byteNumbers[i] = byteCharacters.charCodeAt(i)\n            }\n            const byteArray = new Uint8Array(byteNumbers)\n            const file = new File([byteArray], 'pasted-image.' + mimeType?.split('/')[1], {\n              type: mimeType,\n            })\n            transformedImage = { alt: undefined, file, formID }\n          } else if (src?.startsWith('http') || src?.startsWith('https')) {\n            // It's an image URL\n            const res = await fetch(src)\n            const blob = await res.blob()\n            const inferredFileName =\n              src.split('/').pop() || 'pasted-image' + blob.type.split('/')[1]\n            const file = new File([blob], inferredFileName, {\n              type: blob.type,\n            })\n\n            transformedImage = { alt: undefined, file, formID }\n          }\n\n          if (!transformedImage) {\n            return\n          }\n\n          openBulkUpload({ files: [transformedImage] })\n        }\n        void upload()\n      }),\n      editor.registerCommand<InsertUploadPayload>(\n        INSERT_UPLOAD_COMMAND,\n        (payload: InsertUploadPayload) => {\n          editor.update(() => {\n            const selection = $getSelection() || $getPreviousSelection()\n\n            if ($isRangeSelection(selection)) {\n              const uploadNode = $createUploadNode({\n                data: {\n                  id: payload.id,\n                  fields: payload.fields,\n                  relationTo: payload.relationTo,\n                  value: payload.value,\n                },\n              })\n              // we need to get the focus node before inserting the block node, as $insertNodeToNearestRoot can change the focus node\n              const { focus } = selection\n              const focusNode = focus.getNode()\n              // Insert upload node BEFORE potentially removing focusNode, as $insertNodeToNearestRoot errors if the focusNode doesn't exist\n              $insertNodeToNearestRoot(uploadNode)\n\n              // Delete the node it it's an empty paragraph\n              if ($isParagraphNode(focusNode) && !focusNode.__first) {\n                focusNode.remove()\n              }\n            }\n          })\n\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR,\n      ),\n      editor.registerCommand(\n        PASTE_COMMAND,\n        (event) => {\n          // Pending UploadNodes are automatically created when importDOM is called. However, if you paste a file from your computer\n          // directly, importDOM won't be called, as it's not a HTML dom element. So we need to handle that case here.\n\n          if (!(event instanceof ClipboardEvent)) {\n            return false\n          }\n          const clipboardData = event.clipboardData\n\n          if (!clipboardData?.types?.length || clipboardData?.types?.includes('text/html')) {\n            // HTML is handled through importDOM => registerNodeTransform for pending UploadNode\n            return false\n          }\n\n          const files: FileToUpload[] = []\n          if (clipboardData?.files?.length) {\n            Array.from(clipboardData.files).forEach((file) => {\n              files.push({\n                alt: '',\n                file,\n                formID: new ObjectID.default().toHexString(),\n              })\n            })\n          }\n\n          if (files.length) {\n            // Insert a pending UploadNode for each image\n            editor.update(() => {\n              const selection = $getSelection() || $getPreviousSelection()\n\n              if ($isRangeSelection(selection)) {\n                for (const file of files) {\n                  const pendingUploadNode = new UploadNode({\n                    data: {\n                      pending: {\n                        formID: file.formID,\n                        src: URL.createObjectURL(file.file),\n                      },\n                    } as Internal_UploadData,\n                  })\n                  // we need to get the focus node before inserting the upload node, as $insertNodeToNearestRoot can change the focus node\n                  const { focus } = selection\n                  const focusNode = focus.getNode()\n                  // Insert upload node BEFORE potentially removing focusNode, as $insertNodeToNearestRoot errors if the focusNode doesn't exist\n                  $insertNodeToNearestRoot(pendingUploadNode)\n\n                  // Delete the node it it's an empty paragraph\n                  if ($isParagraphNode(focusNode) && !focusNode.__first) {\n                    focusNode.remove()\n                  }\n                }\n              }\n            })\n\n            // Open the bulk drawer - the node transform will not open it for us, as it does not handle blob/file uploads\n            openBulkUpload({ files })\n\n            return true\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      // Handle drag & drop of files from the desktop into the editor\n      editor.registerCommand(\n        DROP_COMMAND,\n        (event) => {\n          if (!(event instanceof DragEvent)) {\n            return false\n          }\n\n          const dt = event.dataTransfer\n\n          if (!dt?.types?.length) {\n            return false\n          }\n\n          const files: FileToUpload[] = []\n          if (dt?.files?.length) {\n            Array.from(dt.files).forEach((file) => {\n              files.push({\n                alt: '',\n                file,\n                formID: new ObjectID.default().toHexString(),\n              })\n            })\n          }\n\n          if (files.length) {\n            // Prevent the default browser drop handling, which would open the file in the browser\n            event.preventDefault()\n            event.stopPropagation()\n\n            // Insert a PendingUploadNode for each image\n            editor.update(() => {\n              if (canDropImage(event)) {\n                const range = getDragSelection(event)\n                const selection = $createRangeSelection()\n                if (range !== null && range !== undefined) {\n                  selection.applyDOMRange(range)\n                }\n                $setSelection(selection)\n\n                for (const file of files) {\n                  const pendingUploadNode = new UploadNode({\n                    data: {\n                      pending: {\n                        formID: file.formID,\n                        src: URL.createObjectURL(file.file),\n                      },\n                    } as Internal_UploadData,\n                  })\n                  // we need to get the focus node before inserting the upload node, as $insertNodeToNearestRoot can change the focus node\n                  const { focus } = selection\n                  const focusNode = focus.getNode()\n                  // Insert upload node BEFORE potentially removing focusNode, as $insertNodeToNearestRoot errors if the focusNode doesn't exist\n                  $insertNodeToNearestRoot(pendingUploadNode)\n\n                  // Delete the node it it's an empty paragraph\n                  if ($isParagraphNode(focusNode) && !focusNode.__first) {\n                    focusNode.remove()\n                  }\n                }\n              }\n            })\n\n            // Open the bulk drawer - the node transform will not open it for us, as it does not handle blob/file uploads\n            openBulkUpload({ files })\n\n            return true\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor])\n\n  return <UploadDrawer enabledCollectionSlugs={enabledCollectionSlugs} />\n}\n"],"mappings":"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","ignoreList":[]}