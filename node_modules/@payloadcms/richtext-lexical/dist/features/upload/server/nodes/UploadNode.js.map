{"version":3,"file":"UploadNode.js","names":["DecoratorBlockNode","ObjectID","$applyNodeReplacement","$convertUploadElement","UploadServerNode","__data","constructor","data","format","key","clone","node","__format","__key","getType","importDOM","img","conversion","domNode","$createUploadServerNode","priority","importJSON","serializedNode","version","value","id","default","toHexString","importedData","fields","pending","relationTo","setFormat","isInline","decorate","exportDOM","element","document","createElement","setAttribute","String","formID","src","exportJSON","getData","type","getLatest","setData","writable","getWritable","updateDOM","$isUploadServerNode"],"sources":["../../../../../src/features/upload/server/nodes/UploadNode.tsx"],"sourcesContent":["import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMExportOutput,\n  ElementFormatType,\n  LexicalNode,\n  NodeKey,\n} from 'lexical'\nimport type {\n  CollectionSlug,\n  DataFromCollectionSlug,\n  JsonObject,\n  TypedUploadCollection,\n  UploadCollectionSlug,\n} from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport ObjectID from 'bson-objectid'\nimport { $applyNodeReplacement } from 'lexical'\n\nimport type { StronglyTypedLeafNode } from '../../../../nodeTypes.js'\n\nimport { $convertUploadElement } from './conversions.js'\n\nexport type UploadData<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  [TCollectionSlug in CollectionSlug]: {\n    fields: TUploadExtraFieldsData\n    /**\n     * Every lexical node that has sub-fields needs to have a unique ID. This is the ID of this upload node, not the ID of the linked upload document\n     */\n    id: string\n    relationTo: TCollectionSlug\n    /**\n     * Value can be just the document ID, or the full, populated document\n     */\n    value: DataFromCollectionSlug<TCollectionSlug> | number | string\n  }\n}[CollectionSlug]\n\n/**\n * Internal use only - UploadData type that can contain a pending state\n * @internal\n */\nexport type Internal_UploadData<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  pending?: {\n    /**\n     * ID that corresponds to the bulk upload form ID\n     */\n    formID: string\n    /**\n     * src value of the image dom element\n     */\n    src: string\n  }\n} & UploadData<TUploadExtraFieldsData>\n\n/**\n * UploadDataImproved is a more precise type, and will replace UploadData in Payload v4.\n * This type is for internal use only as it will be deprecated in the future.\n * @internal\n *\n * @todo Replace UploadData with UploadDataImproved in 4.0\n */\nexport type UploadDataImproved<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  [TCollectionSlug in UploadCollectionSlug]: {\n    fields: TUploadExtraFieldsData\n    /**\n     * Every lexical node that has sub-fields needs to have a unique ID. This is the ID of this upload node, not the ID of the linked upload document\n     */\n    id: string\n    relationTo: TCollectionSlug\n    /**\n     * Value can be just the document ID, or the full, populated document\n     */\n    value: number | string | TypedUploadCollection[TCollectionSlug]\n  }\n}[UploadCollectionSlug]\n\nexport type SerializedUploadNode = StronglyTypedLeafNode<SerializedDecoratorBlockNode, 'upload'> &\n  UploadData\n\nexport class UploadServerNode extends DecoratorBlockNode {\n  __data: UploadData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: UploadData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static override clone(node: UploadServerNode): UploadServerNode {\n    return new this({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'upload'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLImageElement> {\n    return {\n      img: (node) => ({\n        conversion: (domNode) => $convertUploadElement(domNode, $createUploadServerNode),\n        priority: 0,\n      }),\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedUploadNode): UploadServerNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n    if (serializedNode.version === 2 && !serializedNode?.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const importedData: Internal_UploadData = {\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n      pending: (serializedNode as Internal_UploadData).pending,\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n\n    const node = $createUploadServerNode({ data: importedData })\n    node.setFormat(serializedNode.format)\n\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  override decorate(): JSX.Element {\n    return null as unknown as JSX.Element\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('img')\n    const data = this.__data as Internal_UploadData\n    if (data.pending) {\n      element.setAttribute('data-lexical-pending-upload-form-id', String(data?.pending?.formID))\n      element.setAttribute('src', data?.pending?.src || '')\n    } else {\n      element.setAttribute('data-lexical-upload-id', String(data?.value))\n      element.setAttribute('data-lexical-upload-relation-to', data?.relationTo)\n    }\n\n    return { element }\n  }\n\n  override exportJSON(): SerializedUploadNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'upload',\n      version: 3,\n    }\n  }\n\n  getData(): UploadData {\n    return this.getLatest().__data\n  }\n\n  setData(data: UploadData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n\n  override updateDOM(): false {\n    return false\n  }\n}\n\nexport function $createUploadServerNode({\n  data,\n}: {\n  data: Omit<UploadData, 'id'> & Partial<Pick<UploadData, 'id'>>\n}): UploadServerNode {\n  if (!data?.id) {\n    data.id = new ObjectID.default().toHexString()\n  }\n  return $applyNodeReplacement(new UploadServerNode({ data: data as UploadData }))\n}\n\nexport function $isUploadServerNode(\n  node: LexicalNode | null | undefined,\n): node is UploadServerNode {\n  return node instanceof UploadServerNode\n}\n"],"mappings":"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","ignoreList":[]}