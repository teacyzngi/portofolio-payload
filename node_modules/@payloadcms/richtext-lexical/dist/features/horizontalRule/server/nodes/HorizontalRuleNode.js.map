{"version":3,"file":"HorizontalRuleNode.js","names":["addClassNamesToElement","$applyNodeReplacement","createCommand","DecoratorNode","INSERT_HORIZONTAL_RULE_COMMAND","HorizontalRuleServerNode","clone","node","__key","getType","importDOM","hr","conversion","$convertHorizontalRuleElement","priority","importJSON","serializedNode","$createHorizontalRuleServerNode","createDOM","config","element","document","createElement","theme","decorate","exportDOM","exportJSON","type","version","getTextContent","isInline","updateDOM","$isHorizontalRuleServerNode"],"sources":["../../../../../src/features/horizontalRule/server/nodes/HorizontalRuleNode.tsx"],"sourcesContent":["import type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalCommand,\n  LexicalNode,\n  SerializedLexicalNode,\n} from 'lexical'\nimport type * as React from 'react'\n\nimport { addClassNamesToElement } from '@lexical/utils'\nimport { $applyNodeReplacement, createCommand, DecoratorNode } from 'lexical'\n\nimport type { StronglyTypedLeafNode } from '../../../../nodeTypes.js'\n\n/**\n * Serialized representation of a horizontal rule node. Serialized = converted to JSON. This is what is stored in the database / in the lexical editor state.\n */\nexport type SerializedHorizontalRuleNode = StronglyTypedLeafNode<\n  SerializedLexicalNode,\n  'horizontalrule'\n>\n\nexport const INSERT_HORIZONTAL_RULE_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_HORIZONTAL_RULE_COMMAND',\n)\n\n/**\n * This node is a DecoratorNode. DecoratorNodes allow you to render React components in the editor.\n *\n * They need both createDom and decorate functions. createDom => outside of the html. decorate => React Component inside of the html.\n *\n * If we used DecoratorBlockNode instead, we would only need a decorate method\n */\nexport class HorizontalRuleServerNode extends DecoratorNode<null | React.ReactElement> {\n  static override clone(node: HorizontalRuleServerNode): HorizontalRuleServerNode {\n    return new this(node.__key)\n  }\n\n  static override getType(): string {\n    return 'horizontalrule'\n  }\n\n  /**\n   * Defines what happens if you copy an hr element from another page and paste it into the lexical editor\n   *\n   * This also determines the behavior of lexical's internal HTML -> Lexical converter\n   */\n  static override importDOM(): DOMConversionMap | null {\n    return {\n      hr: () => ({\n        conversion: $convertHorizontalRuleElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  /**\n   * The data for this node is stored serialized as JSON. This is the \"load function\" of that node: it takes the saved data and converts it into a node.\n   */\n  static override importJSON(\n    serializedNode: SerializedHorizontalRuleNode,\n  ): HorizontalRuleServerNode {\n    return $createHorizontalRuleServerNode()\n  }\n\n  /**\n   * Determines how the hr element is rendered in the lexical editor. This is only the \"initial\" / \"outer\" HTML element.\n   */\n  override createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('hr')\n    addClassNamesToElement(element, config.theme.hr)\n    return element\n  }\n\n  override decorate(): null | React.ReactElement {\n    return null\n  }\n\n  /**\n   * Opposite of importDOM, this function defines what happens when you copy an hr element from the lexical editor and paste it into another page.\n   *\n   * This also determines the behavior of lexical's internal Lexical -> HTML converter\n   */\n  override exportDOM(): DOMExportOutput {\n    return { element: document.createElement('hr') }\n  }\n  /**\n   * Opposite of importJSON. This determines what data is saved in the database / in the lexical editor state.\n   */\n  override exportJSON(): SerializedLexicalNode {\n    return {\n      type: 'horizontalrule',\n      version: 1,\n    }\n  }\n\n  override getTextContent(): string {\n    return '\\n'\n  }\n\n  override isInline(): false {\n    return false\n  }\n\n  override updateDOM(): boolean {\n    return false\n  }\n}\n\nfunction $convertHorizontalRuleElement(): DOMConversionOutput {\n  return { node: $createHorizontalRuleServerNode() }\n}\n\nexport function $createHorizontalRuleServerNode(): HorizontalRuleServerNode {\n  return $applyNodeReplacement(new HorizontalRuleServerNode())\n}\n\nexport function $isHorizontalRuleServerNode(\n  node: LexicalNode | null | undefined,\n): node is HorizontalRuleServerNode {\n  return node instanceof HorizontalRuleServerNode\n}\n"],"mappings":"AAWA,SAASA,sBAAsB,QAAQ;AACvC,SAASC,qBAAqB,EAAEC,aAAa,EAAEC,aAAa,QAAQ;AAYpE,OAAO,MAAMC,8BAAA,GAAuDF,aAAA,CAClE;AAGF;;;;;;;AAOA,OAAO,MAAMG,wBAAA,SAAiCF,aAAA;EAC5C,OAAgBG,MAAMC,IAA8B,EAA4B;IAC9E,OAAO,IAAI,IAAI,CAACA,IAAA,CAAKC,KAAK;EAC5B;EAEA,OAAgBC,QAAA,EAAkB;IAChC,OAAO;EACT;EAEA;;;;;EAKA,OAAgBC,UAAA,EAAqC;IACnD,OAAO;MACLC,EAAA,EAAIA,CAAA,MAAO;QACTC,UAAA,EAAYC,6BAAA;QACZC,QAAA,EAAU;MACZ;IACF;EACF;EAEA;;;EAGA,OAAgBC,WACdC,cAA4C,EAClB;IAC1B,OAAOC,+BAAA;EACT;EAEA;;;EAGAC,SAASA,CAAUC,MAAoB,EAAe;IACpD,MAAMC,OAAA,GAAUC,QAAA,CAASC,aAAa,CAAC;IACvCtB,sBAAA,CAAuBoB,OAAA,EAASD,MAAA,CAAOI,KAAK,CAACZ,EAAE;IAC/C,OAAOS,OAAA;EACT;EAESI,SAAA,EAAsC;IAC7C,OAAO;EACT;EAEA;;;;;EAKAC,SAASA,CAAA,EAA6B;IACpC,OAAO;MAAEL,OAAA,EAASC,QAAA,CAASC,aAAa,CAAC;IAAM;EACjD;EACA;;;EAGAI,UAASA,CAAA,EAAoC;IAC3C,OAAO;MACLC,IAAA,EAAM;MACNC,OAAA,EAAS;IACX;EACF;EAESC,eAAA,EAAyB;IAChC,OAAO;EACT;EAESC,SAAA,EAAkB;IACzB,OAAO;EACT;EAESC,UAAA,EAAqB;IAC5B,OAAO;EACT;AACF;AAEA,SAASlB,8BAAA;EACP,OAAO;IAAEN,IAAA,EAAMU,+BAAA;EAAkC;AACnD;AAEA,OAAO,SAASA,gCAAA;EACd,OAAOhB,qBAAA,CAAsB,IAAII,wBAAA;AACnC;AAEA,OAAO,SAAS2B,4BACdzB,IAAoC;EAEpC,OAAOA,IAAA,YAAgBF,wBAAA;AACzB","ignoreList":[]}