{"version":3,"file":"payloadPopulateFn.js","names":["createLocalReq","populate","getPayloadPopulateFn","currentDepth","depth","draft","overrideAccess","payload","req","showHiddenFields","reqToUse","undefined","Error","populateFn","id","collectionSlug","select","dataContainer","data","key","value"],"sources":["../../../../src/features/converters/utilities/payloadPopulateFn.ts"],"sourcesContent":["import { createLocalReq, type Payload, type PayloadRequest, type TypedLocale } from 'payload'\n\nimport type { HTMLPopulateFn } from '../lexicalToHtml/async/types.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\n\nexport const getPayloadPopulateFn: (\n  args: {\n    currentDepth: number\n    depth: number\n    draft?: boolean\n    locale?: TypedLocale\n\n    overrideAccess?: boolean\n    showHiddenFields?: boolean\n  } & (\n    | {\n        /**\n         * This payload property will only be used if req is undefined. If localization is enabled, you must pass `req` instead.\n         */\n        payload: Payload\n        /**\n         * When the converter is called, req CAN be passed in depending on where it's run.\n         * If this is undefined and config is passed through, lexical will create a new req object for you.\n         */\n        req?: never\n      }\n    | {\n        /**\n         * This payload property will only be used if req is undefined. If localization is enabled, you must pass `req` instead.\n         */\n        payload?: never\n        /**\n         * When the converter is called, req CAN be passed in depending on where it's run.\n         * If this is undefined and config is passed through, lexical will create a new req object for you.\n         */\n        req: PayloadRequest\n      }\n  ),\n) => Promise<HTMLPopulateFn> = async ({\n  currentDepth,\n  depth,\n  draft,\n  overrideAccess,\n  payload,\n  req,\n  showHiddenFields,\n}) => {\n  let reqToUse: PayloadRequest | undefined = req\n  if (req === undefined && payload) {\n    reqToUse = await createLocalReq({}, payload)\n  }\n\n  if (!reqToUse) {\n    throw new Error('No req or payload provided')\n  }\n\n  const populateFn: HTMLPopulateFn = async ({ id, collectionSlug, select }) => {\n    const dataContainer: {\n      value?: any\n    } = {}\n\n    await populate({\n      id,\n      collectionSlug,\n      currentDepth,\n      data: dataContainer,\n      depth,\n      draft: draft ?? false,\n      key: 'value',\n      overrideAccess: overrideAccess ?? true,\n      req: reqToUse,\n      select,\n      showHiddenFields: showHiddenFields ?? false,\n    })\n\n    return dataContainer.value\n  }\n\n  return populateFn\n}\n"],"mappings":"AAAA,SAASA,cAAc,QAA6D;AAIpF,SAASC,QAAQ,QAAQ;AAEzB,OAAO,MAAMC,oBAAA,GAiCkB,MAAAA,CAAO;EACpCC,YAAY;EACZC,KAAK;EACLC,KAAK;EACLC,cAAc;EACdC,OAAO;EACPC,GAAG;EACHC;AAAgB,CACjB;EACC,IAAIC,QAAA,GAAuCF,GAAA;EAC3C,IAAIA,GAAA,KAAQG,SAAA,IAAaJ,OAAA,EAAS;IAChCG,QAAA,GAAW,MAAMV,cAAA,CAAe,CAAC,GAAGO,OAAA;EACtC;EAEA,IAAI,CAACG,QAAA,EAAU;IACb,MAAM,IAAIE,KAAA,CAAM;EAClB;EAEA,MAAMC,UAAA,GAA6B,MAAAA,CAAO;IAAEC,EAAE;IAAEC,cAAc;IAAEC;EAAM,CAAE;IACtE,MAAMC,aAAA,GAEF,CAAC;IAEL,MAAMhB,QAAA,CAAS;MACba,EAAA;MACAC,cAAA;MACAZ,YAAA;MACAe,IAAA,EAAMD,aAAA;MACNb,KAAA;MACAC,KAAA,EAAOA,KAAA,IAAS;MAChBc,GAAA,EAAK;MACLb,cAAA,EAAgBA,cAAA,IAAkB;MAClCE,GAAA,EAAKE,QAAA;MACLM,MAAA;MACAP,gBAAA,EAAkBA,gBAAA,IAAoB;IACxC;IAEA,OAAOQ,aAAA,CAAcG,KAAK;EAC5B;EAEA,OAAOP,UAAA;AACT","ignoreList":[]}