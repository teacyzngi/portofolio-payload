{"version":3,"file":"findConverterForNode.js","names":["findConverterForNode","converters","node","converterForNode","type","blocks","fields","blockType","inlineBlocks"],"sources":["../../../../../src/features/converters/lexicalToPlaintext/shared/findConverterForNode.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\nimport type { SerializedBlockNode, SerializedInlineBlockNode } from '../../../../nodeTypes.js'\nimport type { PlaintextConverter, PlaintextConverters } from '../sync/types.js'\n\nexport function findConverterForNode<\n  TConverters extends PlaintextConverters,\n  TConverter extends PlaintextConverter<any>,\n>({\n  converters,\n\n  node,\n}: {\n  converters: TConverters\n  node: SerializedLexicalNode\n}): TConverter | undefined {\n  let converterForNode: TConverter | undefined\n  if (node.type === 'block') {\n    converterForNode = converters?.blocks?.[\n      (node as SerializedBlockNode)?.fields?.blockType\n    ] as TConverter\n  } else if (node.type === 'inlineBlock') {\n    converterForNode = converters?.inlineBlocks?.[\n      (node as SerializedInlineBlockNode)?.fields?.blockType\n    ] as TConverter\n  } else {\n    converterForNode = converters[node.type] as TConverter\n  }\n\n  return converterForNode\n}\n"],"mappings":"AAKA,OAAO,SAASA,qBAGd;EACAC,UAAU;EAEVC;AAAI,CAIL;EACC,IAAIC,gBAAA;EACJ,IAAID,IAAA,CAAKE,IAAI,KAAK,SAAS;IACzBD,gBAAA,GAAmBF,UAAA,EAAYI,MAAA,GAC5BH,IAAA,EAA8BI,MAAA,EAAQC,SAAA,CACxC;EACH,OAAO,IAAIL,IAAA,CAAKE,IAAI,KAAK,eAAe;IACtCD,gBAAA,GAAmBF,UAAA,EAAYO,YAAA,GAC5BN,IAAA,EAAoCI,MAAA,EAAQC,SAAA,CAC9C;EACH,OAAO;IACLJ,gBAAA,GAAmBF,UAAU,CAACC,IAAA,CAAKE,IAAI,CAAC;EAC1C;EAEA,OAAOD,gBAAA;AACT","ignoreList":[]}