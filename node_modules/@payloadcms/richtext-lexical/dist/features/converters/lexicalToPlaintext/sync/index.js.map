{"version":3,"file":"index.js","names":["hasText","findConverterForNode","convertLexicalToPlaintext","converters","data","plaintext","convertLexicalNodesToPlaintext","nodes","root","children","parent","join","plainTextArray","i","node","converter","converted","childIndex","nodesToPlaintext","args","push","error","console","type","length","text","filter","Boolean"],"sources":["../../../../../src/features/converters/lexicalToPlaintext/sync/index.ts"],"sourcesContent":["/* eslint-disable no-console */\nimport type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\n\nimport type { SerializedLexicalNodeWithParent } from '../shared/types.js'\nimport type { PlaintextConverters } from './types.js'\n\nimport { hasText } from '../../../../validate/hasText.js'\nimport { findConverterForNode } from '../shared/findConverterForNode.js'\n\nexport type ConvertLexicalToPlaintextArgs = {\n  /**\n   * A map of node types to their corresponding plaintext converter functions.\n   * This is optional - if not provided, the following heuristic will be used:\n   *\n   * - If the node has a `text` property, it will be used as the plaintext.\n   * - If the node has a `children` property, the children will be recursively converted to plaintext.\n   * - If the node has neither, it will be ignored.\n   **/\n  converters?: PlaintextConverters\n  data: SerializedEditorState\n}\n\nexport function convertLexicalToPlaintext({\n  converters,\n  data,\n}: ConvertLexicalToPlaintextArgs): string {\n  if (hasText(data)) {\n    const plaintext = convertLexicalNodesToPlaintext({\n      converters: converters ?? {},\n      nodes: data?.root?.children,\n      parent: data?.root,\n    }).join('')\n\n    return plaintext\n  }\n  return ''\n}\n\nexport function convertLexicalNodesToPlaintext({\n  converters,\n  nodes,\n  parent,\n}: {\n  converters: PlaintextConverters\n  nodes: SerializedLexicalNode[]\n  parent: SerializedLexicalNodeWithParent\n}): string[] {\n  const plainTextArray: string[] = []\n\n  let i = -1\n  for (const node of nodes) {\n    i++\n\n    const converter = findConverterForNode({\n      converters,\n      node,\n    })\n\n    if (converter) {\n      try {\n        const converted =\n          typeof converter === 'function'\n            ? converter({\n                childIndex: i,\n                converters,\n                node,\n                nodesToPlaintext: (args) => {\n                  return convertLexicalNodesToPlaintext({\n                    converters: args.converters ?? converters,\n                    nodes: args.nodes,\n                    parent: args.parent ?? {\n                      ...node,\n                      parent,\n                    },\n                  })\n                },\n                parent,\n              })\n            : converter\n\n        if (converted && typeof converted === 'string') {\n          plainTextArray.push(converted)\n        }\n      } catch (error) {\n        console.error('Error converting lexical node to plaintext:', error, 'node:', node)\n      }\n    } else {\n      // Default plaintext converter heuristic\n      if (\n        node.type === 'paragraph' ||\n        node.type === 'heading' ||\n        node.type === 'list' ||\n        node.type === 'table'\n      ) {\n        if (plainTextArray?.length) {\n          // Only add a new line if there is already text in the array\n          plainTextArray.push('\\n\\n')\n        }\n      } else if (node.type === 'listitem' || node.type === 'tablerow') {\n        if (plainTextArray?.length) {\n          // Only add a new line if there is already text in the array\n          plainTextArray.push('\\n')\n        }\n      } else if (node.type === 'tablecell') {\n        if (plainTextArray?.length) {\n          plainTextArray.push(' | ')\n        }\n      } else if (node.type === 'linebreak') {\n        plainTextArray.push('\\n')\n      } else if (node.type === 'tab') {\n        plainTextArray.push('\\t')\n      } else if ('text' in node && node.text) {\n        plainTextArray.push(node.text as string)\n      }\n\n      if ('children' in node && node.children) {\n        plainTextArray.push(\n          ...convertLexicalNodesToPlaintext({\n            converters,\n            nodes: node.children as SerializedLexicalNode[],\n            parent: node,\n          }),\n        )\n      }\n    }\n  }\n\n  return plainTextArray.filter(Boolean)\n}\n"],"mappings":"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","ignoreList":[]}