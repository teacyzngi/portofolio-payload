{"version":3,"file":"index.js","names":["createLocalReq","hasText","convertLexicalToHTML","converters","currentDepth","data","depth","draft","overrideAccess","payload","req","showHiddenFields","undefined","config","defaultDepth","convertLexicalNodesToHTML","lexicalNodes","root","children","parent","unknownConverter","find","converter","nodeTypes","includes","htmlArray","Promise","all","map","node","i","converterForNode","type","childIndex","error","console","join"],"sources":["../../../../../src/features/converters/lexicalToHtml_deprecated/converter/index.ts"],"sourcesContent":["import type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\nimport type { Payload, PayloadRequest } from 'payload'\n\nimport { createLocalReq } from 'payload'\n\nimport type { HTMLConverter, SerializedLexicalNodeWithParent } from './types.js'\n\nimport { hasText } from '../../../../validate/hasText.js'\n\n/**\n * @deprecated - will be removed in 4.0\n */\nexport type ConvertLexicalToHTMLArgs = {\n  converters: HTMLConverter[]\n  currentDepth?: number\n  data: SerializedEditorState\n  depth?: number\n  draft?: boolean // default false\n  overrideAccess?: boolean // default false\n  showHiddenFields?: boolean // default false\n} & (\n  | {\n      /**\n       * This payload property will only be used if req is undefined.\n       */\n      payload?: never\n      /**\n       * When the converter is called, req CAN be passed in depending on where it's run.\n       * If this is undefined and config is passed through, lexical will create a new req object for you. If this is null or\n       * config is undefined, lexical will not create a new req object for you and local API / server-side-only\n       * functionality will be disabled.\n       */\n      req: PayloadRequest\n    }\n  | {\n      /**\n       * This payload property will only be used if req is undefined.\n       */\n      payload?: Payload\n      /**\n       * When the converter is called, req CAN be passed in depending on where it's run.\n       * If this is undefined and config is passed through, lexical will create a new req object for you. If this is null or\n       * config is undefined, lexical will not create a new req object for you and local API / server-side-only\n       * functionality will be disabled.\n       */\n      req?: null | undefined\n    }\n)\n\n/**\n * @deprecated - will be removed in 4.0. Use the function exported from `@payloadcms/richtext-lexical/html` instead.\n * @example\n * ```ts\n * // old (deprecated)\n * import { convertLexicalToHTML } from '@payloadcms/richtext-lexical'\n * // new (recommended)\n * import { convertLexicalToHTML } from '@payloadcms/richtext-lexical/html'\n * ```\n * For more details, you can refer to https://payloadcms.com/docs/rich-text/converting-html to see all the\n * ways to convert lexical to HTML.\n */\nexport async function convertLexicalToHTML({\n  converters,\n  currentDepth,\n  data,\n  depth,\n  draft,\n  overrideAccess,\n  payload,\n  req,\n  showHiddenFields,\n}: ConvertLexicalToHTMLArgs): Promise<string> {\n  if (hasText(data)) {\n    if (req === undefined && payload) {\n      req = await createLocalReq({}, payload)\n    }\n\n    if (!currentDepth) {\n      currentDepth = 0\n    }\n\n    if (!depth) {\n      depth = req?.payload?.config?.defaultDepth\n    }\n\n    return await convertLexicalNodesToHTML({\n      converters,\n      currentDepth,\n      depth: depth!,\n      draft: draft === undefined ? false : draft,\n      lexicalNodes: data?.root?.children,\n      overrideAccess: overrideAccess === undefined ? false : overrideAccess,\n      parent: data?.root,\n      req: req!,\n      showHiddenFields: showHiddenFields === undefined ? false : showHiddenFields,\n    })\n  }\n  return ''\n}\n\n/**\n * @deprecated - will be removed in 4.0\n */\nexport async function convertLexicalNodesToHTML({\n  converters,\n  currentDepth,\n  depth,\n  draft,\n  lexicalNodes,\n  overrideAccess,\n  parent,\n  req,\n  showHiddenFields,\n}: {\n  converters: HTMLConverter[]\n  currentDepth: number\n  depth: number\n  draft: boolean\n  lexicalNodes: SerializedLexicalNode[]\n  overrideAccess: boolean\n  parent: SerializedLexicalNodeWithParent\n  /**\n   * When the converter is called, req CAN be passed in depending on where it's run.\n   */\n  req: null | PayloadRequest\n  showHiddenFields: boolean\n}): Promise<string> {\n  const unknownConverter = converters.find((converter) => converter.nodeTypes.includes('unknown'))\n\n  const htmlArray = await Promise.all(\n    lexicalNodes.map(async (node, i) => {\n      const converterForNode = converters.find((converter) =>\n        converter.nodeTypes.includes(node.type),\n      )\n      try {\n        if (!converterForNode) {\n          if (unknownConverter) {\n            return await unknownConverter.converter({\n              childIndex: i,\n              converters,\n              currentDepth,\n              depth,\n              draft,\n              node,\n              overrideAccess,\n              parent,\n              req,\n              showHiddenFields,\n            })\n          }\n          return '<span>unknown node</span>'\n        }\n        return await converterForNode.converter({\n          childIndex: i,\n          converters,\n          currentDepth,\n          depth,\n          draft,\n          node,\n          overrideAccess,\n          parent,\n          req,\n          showHiddenFields,\n        })\n      } catch (error) {\n        console.error('Error converting lexical node to HTML:', error, 'node:', node)\n        return ''\n      }\n    }),\n  )\n\n  return htmlArray.join('') || ''\n}\n"],"mappings":"AAGA,SAASA,cAAc,QAAQ;AAI/B,SAASC,OAAO,QAAQ;AA0CxB;;;;;;;;;;;;AAYA,OAAO,eAAeC,qBAAqB;EACzCC,UAAU;EACVC,YAAY;EACZC,IAAI;EACJC,KAAK;EACLC,KAAK;EACLC,cAAc;EACdC,OAAO;EACPC,GAAG;EACHC;AAAgB,CACS;EACzB,IAAIV,OAAA,CAAQI,IAAA,GAAO;IACjB,IAAIK,GAAA,KAAQE,SAAA,IAAaH,OAAA,EAAS;MAChCC,GAAA,GAAM,MAAMV,cAAA,CAAe,CAAC,GAAGS,OAAA;IACjC;IAEA,IAAI,CAACL,YAAA,EAAc;MACjBA,YAAA,GAAe;IACjB;IAEA,IAAI,CAACE,KAAA,EAAO;MACVA,KAAA,GAAQI,GAAA,EAAKD,OAAA,EAASI,MAAA,EAAQC,YAAA;IAChC;IAEA,OAAO,MAAMC,yBAAA,CAA0B;MACrCZ,UAAA;MACAC,YAAA;MACAE,KAAA,EAAOA,KAAA;MACPC,KAAA,EAAOA,KAAA,KAAUK,SAAA,GAAY,QAAQL,KAAA;MACrCS,YAAA,EAAcX,IAAA,EAAMY,IAAA,EAAMC,QAAA;MAC1BV,cAAA,EAAgBA,cAAA,KAAmBI,SAAA,GAAY,QAAQJ,cAAA;MACvDW,MAAA,EAAQd,IAAA,EAAMY,IAAA;MACdP,GAAA,EAAKA,GAAA;MACLC,gBAAA,EAAkBA,gBAAA,KAAqBC,SAAA,GAAY,QAAQD;IAC7D;EACF;EACA,OAAO;AACT;AAEA;;;AAGA,OAAO,eAAeI,0BAA0B;EAC9CZ,UAAU;EACVC,YAAY;EACZE,KAAK;EACLC,KAAK;EACLS,YAAY;EACZR,cAAc;EACdW,MAAM;EACNT,GAAG;EACHC;AAAgB,CAcjB;EACC,MAAMS,gBAAA,GAAmBjB,UAAA,CAAWkB,IAAI,CAAEC,SAAA,IAAcA,SAAA,CAAUC,SAAS,CAACC,QAAQ,CAAC;EAErF,MAAMC,SAAA,GAAY,MAAMC,OAAA,CAAQC,GAAG,CACjCX,YAAA,CAAaY,GAAG,CAAC,OAAOC,IAAA,EAAMC,CAAA;IAC5B,MAAMC,gBAAA,GAAmB5B,UAAA,CAAWkB,IAAI,CAAEC,SAAA,IACxCA,SAAA,CAAUC,SAAS,CAACC,QAAQ,CAACK,IAAA,CAAKG,IAAI;IAExC,IAAI;MACF,IAAI,CAACD,gBAAA,EAAkB;QACrB,IAAIX,gBAAA,EAAkB;UACpB,OAAO,MAAMA,gBAAA,CAAiBE,SAAS,CAAC;YACtCW,UAAA,EAAYH,CAAA;YACZ3B,UAAA;YACAC,YAAA;YACAE,KAAA;YACAC,KAAA;YACAsB,IAAA;YACArB,cAAA;YACAW,MAAA;YACAT,GAAA;YACAC;UACF;QACF;QACA,OAAO;MACT;MACA,OAAO,MAAMoB,gBAAA,CAAiBT,SAAS,CAAC;QACtCW,UAAA,EAAYH,CAAA;QACZ3B,UAAA;QACAC,YAAA;QACAE,KAAA;QACAC,KAAA;QACAsB,IAAA;QACArB,cAAA;QACAW,MAAA;QACAT,GAAA;QACAC;MACF;IACF,EAAE,OAAOuB,KAAA,EAAO;MACdC,OAAA,CAAQD,KAAK,CAAC,0CAA0CA,KAAA,EAAO,SAASL,IAAA;MACxE,OAAO;IACT;EACF;EAGF,OAAOJ,SAAA,CAAUW,IAAI,CAAC,OAAO;AAC/B","ignoreList":[]}