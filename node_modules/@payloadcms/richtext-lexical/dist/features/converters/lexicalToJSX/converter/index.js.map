{"version":3,"file":"index.js","names":["jsx","_jsx","Fragment","_Fragment","React","hasText","convertLexicalToJSX","converters","data","disableIndent","disableTextAlign","convertLexicalNodesToJSX","nodes","root","children","parent","unknownConverter","unknown","jsxArray","map","node","i","converterForNode","type","blocks","fields","blockType","console","error","inlineBlocks","reactNode","converted","childIndex","nodesToJSX","args","style","Array","isArray","includes","format","textAlign","indent","paddingInlineStart","Number","isValidElement","newStyle","props","cloneElement","key","filter","Boolean"],"sources":["../../../../../src/features/converters/lexicalToJSX/converter/index.tsx"],"sourcesContent":["/* eslint-disable no-console */\nimport type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\n\nimport React from 'react'\n\nimport type { SerializedBlockNode, SerializedInlineBlockNode } from '../../../../nodeTypes.js'\nimport type { JSXConverter, JSXConverters, SerializedLexicalNodeWithParent } from './types.js'\n\nimport { hasText } from '../../../../validate/hasText.js'\n\nexport type ConvertLexicalToJSXArgs = {\n  converters: JSXConverters\n  data: SerializedEditorState\n  disableIndent?: boolean | string[]\n  disableTextAlign?: boolean | string[]\n}\n\nexport function convertLexicalToJSX({\n  converters,\n  data,\n  disableIndent,\n  disableTextAlign,\n}: ConvertLexicalToJSXArgs): React.ReactNode {\n  if (hasText(data)) {\n    return convertLexicalNodesToJSX({\n      converters,\n      disableIndent,\n      disableTextAlign,\n      nodes: data?.root?.children,\n      parent: data?.root,\n    })\n  }\n  return <></>\n}\n\nexport function convertLexicalNodesToJSX({\n  converters,\n  disableIndent,\n  disableTextAlign,\n  nodes,\n  parent,\n}: {\n  converters: JSXConverters\n  disableIndent?: boolean | string[]\n  disableTextAlign?: boolean | string[]\n  nodes: SerializedLexicalNode[]\n  parent: SerializedLexicalNodeWithParent\n}): React.ReactNode[] {\n  const unknownConverter: JSXConverter<any> = converters.unknown as JSXConverter<any>\n\n  const jsxArray: React.ReactNode[] = nodes.map((node, i) => {\n    let converterForNode: JSXConverter<any> | undefined\n    if (node.type === 'block') {\n      converterForNode = converters?.blocks?.[(node as SerializedBlockNode)?.fields?.blockType]\n      if (!converterForNode && !unknownConverter) {\n        console.error(\n          `Lexical => JSX converter: Blocks converter: found ${(node as SerializedBlockNode)?.fields?.blockType} block, but no converter is provided`,\n        )\n      }\n    } else if (node.type === 'inlineBlock') {\n      converterForNode =\n        converters?.inlineBlocks?.[(node as SerializedInlineBlockNode)?.fields?.blockType]\n      if (!converterForNode && !unknownConverter) {\n        console.error(\n          `Lexical => JSX converter: Inline Blocks converter: found ${(node as SerializedInlineBlockNode)?.fields?.blockType} inline block, but no converter is provided`,\n        )\n      }\n    } else {\n      converterForNode = converters[node.type] as JSXConverter<any>\n    }\n\n    try {\n      if (!converterForNode && unknownConverter) {\n        converterForNode = unknownConverter\n      }\n\n      let reactNode: React.ReactNode\n      if (converterForNode) {\n        const converted =\n          typeof converterForNode === 'function'\n            ? converterForNode({\n                childIndex: i,\n                converters,\n                node,\n                nodesToJSX: (args) => {\n                  return convertLexicalNodesToJSX({\n                    converters: args.converters ?? converters,\n                    disableIndent: args.disableIndent ?? disableIndent,\n                    disableTextAlign: args.disableTextAlign ?? disableTextAlign,\n                    nodes: args.nodes,\n                    parent: args.parent ?? {\n                      ...node,\n                      parent,\n                    },\n                  })\n                },\n                parent,\n              })\n            : converterForNode\n        reactNode = converted\n      } else {\n        reactNode = <span key={i}>unknown node</span>\n      }\n\n      const style: React.CSSProperties = {}\n\n      // Check if disableTextAlign is not true and does not include node type\n      if (\n        !disableTextAlign &&\n        (!Array.isArray(disableTextAlign) || !disableTextAlign?.includes(node.type))\n      ) {\n        if ('format' in node && node.format) {\n          switch (node.format) {\n            case 'center':\n              style.textAlign = 'center'\n              break\n            case 'end':\n              style.textAlign = 'right'\n              break\n            case 'justify':\n              style.textAlign = 'justify'\n              break\n            case 'left':\n              //style.textAlign = 'left'\n              // Do nothing, as left is the default\n              break\n            case 'right':\n              style.textAlign = 'right'\n              break\n            case 'start':\n              style.textAlign = 'left'\n              break\n          }\n        }\n      }\n\n      if (\n        !disableIndent &&\n        (!Array.isArray(disableIndent) || !disableIndent?.includes(node.type))\n      ) {\n        if ('indent' in node && node.indent && node.type !== 'listitem') {\n          // the unit should be px. Do not change it to rem, em, or something else.\n          // The quantity should be 40px. Do not change it either.\n          // See rationale in\n          // https://github.com/payloadcms/payload/issues/13130#issuecomment-3058348085\n          style.paddingInlineStart = `${Number(node.indent) * 40}px`\n        }\n      }\n\n      if (React.isValidElement(reactNode)) {\n        // Inject style into reactNode\n        if (style.textAlign || style.paddingInlineStart) {\n          const newStyle = {\n            ...style,\n            // @ts-expect-error type better later\n            ...(reactNode?.props?.style ?? {}),\n            // reactNode style comes after, thus a textAlign specified in the converter has priority over the one we inject here\n          }\n\n          return React.cloneElement(reactNode, {\n            key: i,\n            // @ts-expect-error type better later\n            style: newStyle,\n          })\n        }\n        return React.cloneElement(reactNode, {\n          key: i,\n        })\n      }\n\n      return reactNode\n    } catch (error) {\n      console.error('Error converting lexical node to JSX:', error, 'node:', node)\n      return null\n    }\n  })\n\n  return jsxArray.filter(Boolean)\n}\n"],"mappings":"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","ignoreList":[]}