{"version":3,"file":"index.js","names":["createHeadlessEditor","getEnabledNodes","$convertToMarkdownString","convertLexicalToMarkdown","data","editorConfig","headlessEditor","nodes","update","setEditorState","parseEditorState","discrete","markdown","getEditorState","read","features","markdownTransformers"],"sources":["../../../../src/features/converters/lexicalToMarkdown/index.ts"],"sourcesContent":["import type { SerializedEditorState } from 'lexical'\n\nimport { createHeadlessEditor } from '@lexical/headless'\n\nimport type { SanitizedServerEditorConfig } from '../../../lexical/config/types.js'\n\nimport { getEnabledNodes } from '../../../lexical/nodes/index.js'\nimport { $convertToMarkdownString } from '../../../packages/@lexical/markdown/index.js'\n\nexport const convertLexicalToMarkdown = ({\n  data,\n  editorConfig,\n}: {\n  data: SerializedEditorState\n  editorConfig: SanitizedServerEditorConfig\n}): string => {\n  const headlessEditor = createHeadlessEditor({\n    nodes: getEnabledNodes({\n      editorConfig,\n    }),\n  })\n\n  headlessEditor.update(\n    () => {\n      headlessEditor.setEditorState(headlessEditor.parseEditorState(data))\n    },\n    { discrete: true },\n  )\n\n  let markdown: string = ''\n  headlessEditor.getEditorState().read(() => {\n    markdown = $convertToMarkdownString(editorConfig?.features?.markdownTransformers)\n  })\n\n  return markdown\n}\n"],"mappings":"AAEA,SAASA,oBAAoB,QAAQ;AAIrC,SAASC,eAAe,QAAQ;AAChC,SAASC,wBAAwB,QAAQ;AAEzC,OAAO,MAAMC,wBAAA,GAA2BA,CAAC;EACvCC,IAAI;EACJC;AAAY,CAIb;EACC,MAAMC,cAAA,GAAiBN,oBAAA,CAAqB;IAC1CO,KAAA,EAAON,eAAA,CAAgB;MACrBI;IACF;EACF;EAEAC,cAAA,CAAeE,MAAM,CACnB;IACEF,cAAA,CAAeG,cAAc,CAACH,cAAA,CAAeI,gBAAgB,CAACN,IAAA;EAChE,GACA;IAAEO,QAAA,EAAU;EAAK;EAGnB,IAAIC,QAAA,GAAmB;EACvBN,cAAA,CAAeO,cAAc,GAAGC,IAAI,CAAC;IACnCF,QAAA,GAAWV,wBAAA,CAAyBG,YAAA,EAAcU,QAAA,EAAUC,oBAAA;EAC9D;EAEA,OAAOJ,QAAA;AACT","ignoreList":[]}