{"version":3,"file":"index.js","names":["createHeadlessEditor","getEnabledNodes","$convertFromMarkdownString","convertMarkdownToLexical","editorConfig","markdown","headlessEditor","nodes","update","features","markdownTransformers","discrete","editorJSON","getEditorState","toJSON"],"sources":["../../../../src/features/converters/markdownToLexical/index.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\nimport { createHeadlessEditor } from '@lexical/headless'\n\nimport type { SanitizedServerEditorConfig } from '../../../lexical/config/types.js'\nimport type { DefaultNodeTypes, TypedEditorState } from '../../../nodeTypes.js'\n\nimport { getEnabledNodes } from '../../../lexical/nodes/index.js'\nimport { $convertFromMarkdownString } from '../../../packages/@lexical/markdown/index.js'\n\nexport const convertMarkdownToLexical = <\n  TNodeTypes extends SerializedLexicalNode = DefaultNodeTypes,\n>({\n  editorConfig,\n  markdown,\n}: {\n  editorConfig: SanitizedServerEditorConfig\n  markdown: string\n}): TypedEditorState<TNodeTypes> => {\n  const headlessEditor = createHeadlessEditor({\n    nodes: getEnabledNodes({\n      editorConfig,\n    }),\n  })\n\n  headlessEditor.update(\n    () => {\n      $convertFromMarkdownString(markdown, editorConfig.features.markdownTransformers)\n    },\n    { discrete: true },\n  )\n\n  const editorJSON = headlessEditor.getEditorState().toJSON()\n\n  return editorJSON as TypedEditorState<TNodeTypes>\n}\n"],"mappings":"AAEA,SAASA,oBAAoB,QAAQ;AAKrC,SAASC,eAAe,QAAQ;AAChC,SAASC,0BAA0B,QAAQ;AAE3C,OAAO,MAAMC,wBAAA,GAA2BA,CAEtC;EACAC,YAAY;EACZC;AAAQ,CAIT;EACC,MAAMC,cAAA,GAAiBN,oBAAA,CAAqB;IAC1CO,KAAA,EAAON,eAAA,CAAgB;MACrBG;IACF;EACF;EAEAE,cAAA,CAAeE,MAAM,CACnB;IACEN,0BAAA,CAA2BG,QAAA,EAAUD,YAAA,CAAaK,QAAQ,CAACC,oBAAoB;EACjF,GACA;IAAEC,QAAA,EAAU;EAAK;EAGnB,MAAMC,UAAA,GAAaN,cAAA,CAAeO,cAAc,GAAGC,MAAM;EAEzD,OAAOF,UAAA;AACT","ignoreList":[]}