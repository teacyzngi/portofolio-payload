{"version":3,"file":"types.js","names":[],"sources":["../../../../../src/features/converters/lexicalToHtml/sync/types.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\nimport type {\n  DefaultNodeTypes,\n  SerializedBlockNode,\n  SerializedInlineBlockNode,\n} from '../../../../nodeTypes.js'\nimport type { SerializedLexicalNodeWithParent } from '../shared/types.js'\n\nexport type HTMLConverter<T extends { [key: string]: any; type?: string } = SerializedLexicalNode> =\n\n    | ((args: {\n        childIndex: number\n        converters: HTMLConverters\n        node: T\n        nodesToHTML: (args: {\n          converters?: HTMLConverters\n          disableIndent?: boolean | string[]\n          disableTextAlign?: boolean | string[]\n          nodes: SerializedLexicalNode[]\n          parent?: SerializedLexicalNodeWithParent\n        }) => string[]\n        parent: SerializedLexicalNodeWithParent\n        providedCSSString: string\n        providedStyleTag: string\n      }) => string)\n    | string\n\nexport type HTMLConverters<\n  T extends { [key: string]: any; type?: string } =\n    | DefaultNodeTypes\n    | SerializedBlockNode<{ blockName?: null | string; blockType: string }> // need these to ensure types for blocks and inlineBlocks work if no generics are provided\n    | SerializedInlineBlockNode<{ blockName?: null | string; blockType: string }>, // need these to ensure types for blocks and inlineBlocks work if no generics are provided\n> = {\n  [key: string]:\n    | {\n        [blockSlug: string]: HTMLConverter<any>\n      }\n    | HTMLConverter<any>\n    | undefined\n} & {\n  [nodeType in Exclude<NonNullable<T['type']>, 'block' | 'inlineBlock'>]?: HTMLConverter<\n    Extract<T, { type: nodeType }>\n  >\n} & {\n  blocks?: {\n    [K in Extract<\n      Extract<T, { type: 'block' }> extends SerializedBlockNode<infer B>\n        ? B extends { blockType: string }\n          ? B['blockType']\n          : never\n        : never,\n      string\n    >]?: HTMLConverter<\n      Extract<T, { type: 'block' }> extends SerializedBlockNode<infer B>\n        ? SerializedBlockNode<Extract<B, { blockType: K }>>\n        : SerializedBlockNode\n    >\n  }\n  inlineBlocks?: {\n    [K in Extract<\n      Extract<T, { type: 'inlineBlock' }> extends SerializedInlineBlockNode<infer B>\n        ? B extends { blockType: string }\n          ? B['blockType']\n          : never\n        : never,\n      string\n    >]?: HTMLConverter<\n      Extract<T, { type: 'inlineBlock' }> extends SerializedInlineBlockNode<infer B>\n        ? SerializedInlineBlockNode<Extract<B, { blockType: K }>>\n        : SerializedInlineBlockNode\n    >\n  }\n  unknown?: HTMLConverter<SerializedLexicalNode>\n}\n\nexport type HTMLConvertersFunction<\n  T extends { [key: string]: any; type?: string } =\n    | DefaultNodeTypes\n    | SerializedBlockNode<{ blockName?: null | string }>\n    | SerializedInlineBlockNode<{ blockName?: null | string; blockType: string }>,\n> = (args: { defaultConverters: HTMLConverters<DefaultNodeTypes> }) => HTMLConverters<T>\n"],"mappings":"AA4EA","ignoreList":[]}