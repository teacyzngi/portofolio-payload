{"version":3,"file":"types.js","names":[],"sources":["../../../../../src/features/converters/lexicalToHtml/async/types.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\nimport type { SelectType, TypeWithID } from 'payload'\n\nimport type {\n  DefaultNodeTypes,\n  SerializedBlockNode,\n  SerializedInlineBlockNode,\n} from '../../../../nodeTypes.js'\nimport type { SerializedLexicalNodeWithParent } from '../shared/types.js'\nexport type HTMLPopulateArguments = {\n  collectionSlug: string\n  id: number | string\n  select?: SelectType\n}\n\nexport type HTMLPopulateFn = <TData extends object = TypeWithID>(\n  args: HTMLPopulateArguments,\n) => Promise<TData | undefined>\n\nexport type HTMLConverterAsync<\n  T extends { [key: string]: any; type?: string } = SerializedLexicalNode,\n> =\n  | ((args: {\n      childIndex: number\n      converters: HTMLConvertersAsync\n      node: T\n      nodesToHTML: (args: {\n        converters?: HTMLConvertersAsync\n        disableIndent?: boolean | string[]\n        disableTextAlign?: boolean | string[]\n        nodes: SerializedLexicalNode[]\n        parent?: SerializedLexicalNodeWithParent\n      }) => Promise<string[]>\n      parent: SerializedLexicalNodeWithParent\n      populate?: HTMLPopulateFn\n      providedCSSString: string\n      providedStyleTag: string\n    }) => Promise<string> | string)\n  | string\n\nexport type HTMLConvertersAsync<\n  T extends { [key: string]: any; type?: string } =\n    | DefaultNodeTypes\n    | SerializedBlockNode<{ blockName?: null | string; blockType: string }> // need these to ensure types for blocks and inlineBlocks work if no generics are provided\n    | SerializedInlineBlockNode<{ blockName?: null | string; blockType: string }>, // need these to ensure types for blocks and inlineBlocks work if no generics are provided\n> = {\n  [key: string]:\n    | {\n        [blockSlug: string]: HTMLConverterAsync<any>\n      }\n    | HTMLConverterAsync<any>\n    | undefined\n} & {\n  [nodeType in Exclude<NonNullable<T['type']>, 'block' | 'inlineBlock'>]?: HTMLConverterAsync<\n    Extract<T, { type: nodeType }>\n  >\n} & {\n  blocks?: {\n    [K in Extract<\n      Extract<T, { type: 'block' }> extends SerializedBlockNode<infer B>\n        ? B extends { blockType: string }\n          ? B['blockType']\n          : never\n        : never,\n      string\n    >]?: HTMLConverterAsync<\n      Extract<T, { type: 'block' }> extends SerializedBlockNode<infer B>\n        ? SerializedBlockNode<Extract<B, { blockType: K }>>\n        : SerializedBlockNode\n    >\n  }\n  inlineBlocks?: {\n    [K in Extract<\n      Extract<T, { type: 'inlineBlock' }> extends SerializedInlineBlockNode<infer B>\n        ? B extends { blockType: string }\n          ? B['blockType']\n          : never\n        : never,\n      string\n    >]?: HTMLConverterAsync<\n      Extract<T, { type: 'inlineBlock' }> extends SerializedInlineBlockNode<infer B>\n        ? SerializedInlineBlockNode<Extract<B, { blockType: K }>>\n        : SerializedInlineBlockNode\n    >\n  }\n  unknown?: HTMLConverterAsync<SerializedLexicalNode>\n}\n\nexport type HTMLConvertersFunctionAsync<\n  T extends { [key: string]: any; type?: string } =\n    | DefaultNodeTypes\n    | SerializedBlockNode<{ blockName?: null | string }>\n    | SerializedInlineBlockNode<{ blockName?: null | string; blockType: string }>,\n> = (args: { defaultConverters: HTMLConvertersAsync<DefaultNodeTypes> }) => HTMLConvertersAsync<T>\n"],"mappings":"AAwFA","ignoreList":[]}