{"version":3,"file":"index.js","names":["hasText","findConverterForNode","defaultHTMLConvertersAsync","convertLexicalToHTMLAsync","className","converters","data","disableContainer","disableIndent","disableTextAlign","populate","finalConverters","defaultConverters","html","convertLexicalNodesToHTMLAsync","nodes","root","children","parent","join","unknownConverter","unknown","htmlArray","i","node","converterForNode","providedCSSString","providedStyleTag","nodeHTML","converted","childIndex","nodesToHTML","args","push","error","console","filter","Boolean"],"sources":["../../../../../src/features/converters/lexicalToHtml/async/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-console */\nimport type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\n\nimport type { SerializedLexicalNodeWithParent } from '../shared/types.js'\nimport type {\n  HTMLConverterAsync,\n  HTMLConvertersAsync,\n  HTMLConvertersFunctionAsync,\n  HTMLPopulateFn,\n} from './types.js'\n\nimport { hasText } from '../../../../validate/hasText.js'\nimport { findConverterForNode } from '../shared/findConverterForNode.js'\nimport { defaultHTMLConvertersAsync } from './defaultConverters.js'\n\nexport type ConvertLexicalToHTMLAsyncArgs = {\n  /**\n   * Override class names for the container.\n   */\n  className?: string\n  converters?: HTMLConvertersAsync | HTMLConvertersFunctionAsync\n  data: SerializedEditorState\n  /**\n   * If true, removes the container div wrapper.\n   */\n  disableContainer?: boolean\n  /**\n   * If true, disables indentation globally. If an array, disables for specific node `type` values.\n   */\n  disableIndent?: boolean | string[]\n  /**\n   * If true, disables text alignment globally. If an array, disables for specific node `type` values.\n   */\n  disableTextAlign?: boolean | string[]\n  populate?: HTMLPopulateFn\n}\n\nexport async function convertLexicalToHTMLAsync({\n  className,\n  converters,\n  data,\n  disableContainer,\n  disableIndent,\n  disableTextAlign,\n  populate,\n}: ConvertLexicalToHTMLAsyncArgs): Promise<string> {\n  if (hasText(data)) {\n    let finalConverters: HTMLConvertersAsync = {}\n    if (converters) {\n      if (typeof converters === 'function') {\n        finalConverters = converters({ defaultConverters: defaultHTMLConvertersAsync })\n      } else {\n        finalConverters = converters\n      }\n    } else {\n      finalConverters = defaultHTMLConvertersAsync\n    }\n\n    const html = (\n      await convertLexicalNodesToHTMLAsync({\n        converters: finalConverters,\n        disableIndent,\n        disableTextAlign,\n        nodes: data?.root?.children,\n        parent: data?.root,\n        populate,\n      })\n    ).join('')\n\n    if (disableContainer) {\n      return html\n    } else {\n      return `<div class=\"${className ?? 'payload-richtext'}\">${html}</div>`\n    }\n  }\n  if (disableContainer) {\n    return ''\n  } else {\n    return `<div class=\"${className ?? 'payload-richtext'}\"></div>`\n  }\n}\n\nexport async function convertLexicalNodesToHTMLAsync({\n  converters,\n  disableIndent,\n  disableTextAlign,\n  nodes,\n  parent,\n  populate,\n}: {\n  converters: HTMLConvertersAsync\n  disableIndent?: boolean | string[]\n  disableTextAlign?: boolean | string[]\n  nodes: SerializedLexicalNode[]\n  parent: SerializedLexicalNodeWithParent\n  populate?: HTMLPopulateFn\n}): Promise<string[]> {\n  const unknownConverter: HTMLConverterAsync<any> = converters.unknown as HTMLConverterAsync<any>\n\n  const htmlArray: string[] = []\n\n  let i = -1\n  for (const node of nodes) {\n    i++\n    const { converterForNode, providedCSSString, providedStyleTag } = findConverterForNode({\n      converters,\n      disableIndent,\n      disableTextAlign,\n      node,\n      unknownConverter,\n    })\n\n    try {\n      let nodeHTML: string\n\n      if (converterForNode) {\n        const converted =\n          typeof converterForNode === 'function'\n            ? await converterForNode({\n                childIndex: i,\n                converters,\n                node,\n                populate,\n\n                nodesToHTML: async (args) => {\n                  return await convertLexicalNodesToHTMLAsync({\n                    converters: args.converters ?? converters,\n                    disableIndent: args.disableIndent ?? disableIndent,\n                    disableTextAlign: args.disableTextAlign ?? disableTextAlign,\n                    nodes: args.nodes,\n                    parent: args.parent ?? {\n                      ...node,\n                      parent,\n                    },\n                    populate,\n                  })\n                },\n                parent,\n                providedCSSString,\n                providedStyleTag,\n              })\n            : converterForNode\n        nodeHTML = converted\n      } else {\n        nodeHTML = '<span>unknown node</span>'\n      }\n\n      htmlArray.push(nodeHTML)\n    } catch (error) {\n      console.error('Error converting lexical node to HTML:', error, 'node:', node)\n      htmlArray.push('')\n    }\n  }\n\n  return htmlArray.filter(Boolean)\n}\n"],"mappings":"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","ignoreList":[]}