{"version":3,"file":"textState.js","names":["useLexicalComposerContext","$forEachSelectedTextNode","$getNodeByKey","$getState","$setState","createState","TextNode","useEffect","registerTextStates","state","stateMap","Map","stateKey","stateValues","stateConfig","parse","value","Object","keys","includes","undefined","set","setTextState","editor","update","textNode","stateMapEntry","get","Error","StatePlugin","registerMutationListener","mutatedNodes","getEditorState","read","nodeKey","mutation","node","dom","getElementByKey","mergedStyles","create","forEach","stateEntry","stateValue","dataset","css","assign","style","cssText"],"sources":["../../../src/features/textState/textState.ts"],"sourcesContent":["import type { LexicalEditor, StateConfig } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $forEachSelectedTextNode } from '@lexical/selection'\nimport { $getNodeByKey, $getState, $setState, createState, TextNode } from 'lexical'\nimport { useEffect } from 'react'\n\nimport { type StateValues, type TextStateFeatureProps } from './feature.server.js'\n\nexport type StateMap = Map<\n  string,\n  {\n    stateConfig: StateConfig<string, string | undefined>\n    stateValues: StateValues\n  }\n>\n\nexport function registerTextStates(state: TextStateFeatureProps['state']) {\n  const stateMap: StateMap = new Map()\n\n  for (const stateKey in state) {\n    const stateValues = state[stateKey]!\n    const stateConfig = createState(stateKey, {\n      parse: (value) =>\n        typeof value === 'string' && Object.keys(stateValues).includes(value) ? value : undefined,\n    })\n    stateMap.set(stateKey, { stateConfig, stateValues })\n  }\n  return stateMap\n}\n\nexport function setTextState(\n  editor: LexicalEditor,\n  stateMap: StateMap,\n  stateKey: string,\n  value: string | undefined,\n) {\n  editor.update(() => {\n    $forEachSelectedTextNode((textNode) => {\n      const stateMapEntry = stateMap.get(stateKey)\n      if (!stateMapEntry) {\n        throw new Error(`State config for ${stateKey} not found`)\n      }\n      $setState(textNode, stateMapEntry.stateConfig, value)\n    })\n  })\n}\n\nexport function StatePlugin({ stateMap }: { stateMap: StateMap }) {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerMutationListener(TextNode, (mutatedNodes) => {\n      editor.getEditorState().read(() => {\n        for (const [nodeKey, mutation] of mutatedNodes) {\n          if (mutation === 'destroyed') {\n            continue\n          }\n          const node = $getNodeByKey(nodeKey)\n          const dom = editor.getElementByKey(nodeKey)\n          if (!node || !dom) {\n            continue\n          }\n\n          const mergedStyles: Record<string, string> = Object.create(null)\n          // Examples:\n          // stateKey: 'color'\n          // stateValue: 'bg-red'\n          stateMap.forEach((stateEntry, stateKey) => {\n            const stateValue = $getState(node, stateEntry.stateConfig)\n            if (!stateValue) {\n              // clear the previous dataset value for this key\n              delete dom.dataset[stateKey]\n              return\n            } // skip - nothing else to do\n\n            dom.dataset[stateKey] = stateValue\n\n            const css = stateEntry.stateValues[stateValue]?.css\n            if (css) {\n              // merge existing styles with the new ones\n              Object.assign(mergedStyles, css)\n            }\n          })\n\n          // wipe previous inline styles once, then set the merged ones\n          dom.style.cssText = ''\n          Object.assign(dom.style, mergedStyles)\n        }\n      })\n    })\n  }, [editor])\n\n  return null\n}\n"],"mappings":"AAEA,SAASA,yBAAyB,QAAQ;AAC1C,SAASC,wBAAwB,QAAQ;AACzC,SAASC,aAAa,EAAEC,SAAS,EAAEC,SAAS,EAAEC,WAAW,EAAEC,QAAQ,QAAQ;AAC3E,SAASC,SAAS,QAAQ;AAY1B,OAAO,SAASC,mBAAmBC,KAAqC;EACtE,MAAMC,QAAA,GAAqB,IAAIC,GAAA;EAE/B,KAAK,MAAMC,QAAA,IAAYH,KAAA,EAAO;IAC5B,MAAMI,WAAA,GAAcJ,KAAK,CAACG,QAAA,CAAS;IACnC,MAAME,WAAA,GAAcT,WAAA,CAAYO,QAAA,EAAU;MACxCG,KAAA,EAAQC,KAAA,IACN,OAAOA,KAAA,KAAU,YAAYC,MAAA,CAAOC,IAAI,CAACL,WAAA,EAAaM,QAAQ,CAACH,KAAA,IAASA,KAAA,GAAQI;IACpF;IACAV,QAAA,CAASW,GAAG,CAACT,QAAA,EAAU;MAAEE,WAAA;MAAaD;IAAY;EACpD;EACA,OAAOH,QAAA;AACT;AAEA,OAAO,SAASY,aACdC,MAAqB,EACrBb,QAAkB,EAClBE,QAAgB,EAChBI,KAAyB;EAEzBO,MAAA,CAAOC,MAAM,CAAC;IACZvB,wBAAA,CAA0BwB,QAAA;MACxB,MAAMC,aAAA,GAAgBhB,QAAA,CAASiB,GAAG,CAACf,QAAA;MACnC,IAAI,CAACc,aAAA,EAAe;QAClB,MAAM,IAAIE,KAAA,CAAM,oBAAoBhB,QAAA,YAAoB;MAC1D;MACAR,SAAA,CAAUqB,QAAA,EAAUC,aAAA,CAAcZ,WAAW,EAAEE,KAAA;IACjD;EACF;AACF;AAEA,OAAO,SAASa,YAAY;EAAEnB;AAAQ,CAA0B;EAC9D,MAAM,CAACa,MAAA,CAAO,GAAGvB,yBAAA;EAEjBO,SAAA,CAAU;IACR,OAAOgB,MAAA,CAAOO,wBAAwB,CAACxB,QAAA,EAAWyB,YAAA;MAChDR,MAAA,CAAOS,cAAc,GAAGC,IAAI,CAAC;QAC3B,KAAK,MAAM,CAACC,OAAA,EAASC,QAAA,CAAS,IAAIJ,YAAA,EAAc;UAC9C,IAAII,QAAA,KAAa,aAAa;YAC5B;UACF;UACA,MAAMC,IAAA,GAAOlC,aAAA,CAAcgC,OAAA;UAC3B,MAAMG,GAAA,GAAMd,MAAA,CAAOe,eAAe,CAACJ,OAAA;UACnC,IAAI,CAACE,IAAA,IAAQ,CAACC,GAAA,EAAK;YACjB;UACF;UAEA,MAAME,YAAA,GAAuCtB,MAAA,CAAOuB,MAAM,CAAC;UAC3D;UACA;UACA;UACA9B,QAAA,CAAS+B,OAAO,CAAC,CAACC,UAAA,EAAY9B,QAAA;YAC5B,MAAM+B,UAAA,GAAaxC,SAAA,CAAUiC,IAAA,EAAMM,UAAA,CAAW5B,WAAW;YACzD,IAAI,CAAC6B,UAAA,EAAY;cACf;cACA,OAAON,GAAA,CAAIO,OAAO,CAAChC,QAAA,CAAS;cAC5B;YACF,EAAE;YAEFyB,GAAA,CAAIO,OAAO,CAAChC,QAAA,CAAS,GAAG+B,UAAA;YAExB,MAAME,GAAA,GAAMH,UAAA,CAAW7B,WAAW,CAAC8B,UAAA,CAAW,EAAEE,GAAA;YAChD,IAAIA,GAAA,EAAK;cACP;cACA5B,MAAA,CAAO6B,MAAM,CAACP,YAAA,EAAcM,GAAA;YAC9B;UACF;UAEA;UACAR,GAAA,CAAIU,KAAK,CAACC,OAAO,GAAG;UACpB/B,MAAA,CAAO6B,MAAM,CAACT,GAAA,CAAIU,KAAK,EAAER,YAAA;QAC3B;MACF;IACF;EACF,GAAG,CAAChB,MAAA,CAAO;EAEX,OAAO;AACT","ignoreList":[]}