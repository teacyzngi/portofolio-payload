{"version":3,"sources":["../../src/schema/buildWhereInputType.ts"],"sourcesContent":["import type { Field, FieldAffectingData } from 'payload'\n\nimport { GraphQLInputObjectType, GraphQLList } from 'graphql'\nimport { flattenTopLevelFields } from 'payload'\nimport { fieldAffectsData, fieldHasSubFields, fieldIsPresentationalOnly } from 'payload/shared'\n\nimport { formatName } from '../utilities/formatName.js'\nimport { fieldToSchemaMap } from './fieldToWhereInputSchemaMap.js'\nimport { withOperators } from './withOperators.js'\n\ntype Args = {\n  fields: Field[]\n  name: string\n  parentName: string\n}\n\n/** This does as the function name suggests. It builds a where GraphQL input type\n * for all the fields which are passed to the function.\n * Each field has different operators which may be valid for a where input type.\n * For example, a text field may have a \"contains\" operator, but a number field\n * may not.\n *\n * buildWhereInputType is similar to buildObjectType and operates\n * on a field basis with a few distinct differences.\n *\n * 1. Everything needs to be a GraphQLInputObjectType or scalar / enum\n * 2. Relationships, groups, repeaters and flex content are not\n *    directly searchable. Instead, we need to build a chained pathname\n *    using dot notation so MongoDB can properly search nested paths.\n */\nexport const buildWhereInputType = ({ name, fields, parentName }: Args): GraphQLInputObjectType => {\n  // This is the function that builds nested paths for all\n  // field types with nested paths.\n\n  const idField = flattenTopLevelFields(fields).find(\n    (field) => fieldAffectsData(field) && field.name === 'id',\n  )\n\n  const fieldTypes = fields.reduce((schema, field) => {\n    if (!fieldIsPresentationalOnly(field) && !field.hidden) {\n      const getFieldSchema = fieldToSchemaMap({\n        parentName,\n      })[field.type]\n\n      if (getFieldSchema) {\n        const fieldSchema = getFieldSchema(field)\n\n        if (fieldHasSubFields(field) || field.type === 'tabs') {\n          return {\n            ...schema,\n            ...fieldSchema.reduce(\n              (subFields, subField) => ({\n                ...subFields,\n                [formatName(subField.key)]: subField.type,\n              }),\n              {},\n            ),\n          }\n        }\n\n        return {\n          ...schema,\n          [formatName(field.name)]: fieldSchema,\n        }\n      }\n    }\n\n    return schema\n  }, {})\n\n  if (!idField) {\n    fieldTypes.id = {\n      type: withOperators({ name: 'id', type: 'text' } as FieldAffectingData, parentName),\n    }\n  }\n\n  const fieldName = formatName(name)\n\n  const recursiveFields = {\n    AND: {\n      type: new GraphQLList(\n        new GraphQLInputObjectType({\n          name: `${fieldName}_where_and`,\n          fields: () => ({\n            ...fieldTypes,\n            ...recursiveFields,\n          }),\n        }),\n      ),\n    },\n    OR: {\n      type: new GraphQLList(\n        new GraphQLInputObjectType({\n          name: `${fieldName}_where_or`,\n          fields: () => ({\n            ...fieldTypes,\n            ...recursiveFields,\n          }),\n        }),\n      ),\n    },\n  }\n\n  return new GraphQLInputObjectType({\n    name: `${fieldName}_where`,\n    fields: {\n      ...fieldTypes,\n      ...recursiveFields,\n    },\n  })\n}\n"],"names":["GraphQLInputObjectType","GraphQLList","flattenTopLevelFields","fieldAffectsData","fieldHasSubFields","fieldIsPresentationalOnly","formatName","fieldToSchemaMap","withOperators","buildWhereInputType","name","fields","parentName","idField","find","field","fieldTypes","reduce","schema","hidden","getFieldSchema","type","fieldSchema","subFields","subField","key","id","fieldName","recursiveFields","AND","OR"],"mappings":"AAEA,SAASA,sBAAsB,EAAEC,WAAW,QAAQ,UAAS;AAC7D,SAASC,qBAAqB,QAAQ,UAAS;AAC/C,SAASC,gBAAgB,EAAEC,iBAAiB,EAAEC,yBAAyB,QAAQ,iBAAgB;AAE/F,SAASC,UAAU,QAAQ,6BAA4B;AACvD,SAASC,gBAAgB,QAAQ,kCAAiC;AAClE,SAASC,aAAa,QAAQ,qBAAoB;AAQlD;;;;;;;;;;;;;CAaC,GACD,OAAO,MAAMC,sBAAsB,CAAC,EAAEC,IAAI,EAAEC,MAAM,EAAEC,UAAU,EAAQ;IACpE,wDAAwD;IACxD,iCAAiC;IAEjC,MAAMC,UAAUX,sBAAsBS,QAAQG,IAAI,CAChD,CAACC,QAAUZ,iBAAiBY,UAAUA,MAAML,IAAI,KAAK;IAGvD,MAAMM,aAAaL,OAAOM,MAAM,CAAC,CAACC,QAAQH;QACxC,IAAI,CAACV,0BAA0BU,UAAU,CAACA,MAAMI,MAAM,EAAE;YACtD,MAAMC,iBAAiBb,iBAAiB;gBACtCK;YACF,EAAE,CAACG,MAAMM,IAAI,CAAC;YAEd,IAAID,gBAAgB;gBAClB,MAAME,cAAcF,eAAeL;gBAEnC,IAAIX,kBAAkBW,UAAUA,MAAMM,IAAI,KAAK,QAAQ;oBACrD,OAAO;wBACL,GAAGH,MAAM;wBACT,GAAGI,YAAYL,MAAM,CACnB,CAACM,WAAWC,WAAc,CAAA;gCACxB,GAAGD,SAAS;gCACZ,CAACjB,WAAWkB,SAASC,GAAG,EAAE,EAAED,SAASH,IAAI;4BAC3C,CAAA,GACA,CAAC,EACF;oBACH;gBACF;gBAEA,OAAO;oBACL,GAAGH,MAAM;oBACT,CAACZ,WAAWS,MAAML,IAAI,EAAE,EAAEY;gBAC5B;YACF;QACF;QAEA,OAAOJ;IACT,GAAG,CAAC;IAEJ,IAAI,CAACL,SAAS;QACZG,WAAWU,EAAE,GAAG;YACdL,MAAMb,cAAc;gBAAEE,MAAM;gBAAMW,MAAM;YAAO,GAAyBT;QAC1E;IACF;IAEA,MAAMe,YAAYrB,WAAWI;IAE7B,MAAMkB,kBAAkB;QACtBC,KAAK;YACHR,MAAM,IAAIpB,YACR,IAAID,uBAAuB;gBACzBU,MAAM,GAAGiB,UAAU,UAAU,CAAC;gBAC9BhB,QAAQ,IAAO,CAAA;wBACb,GAAGK,UAAU;wBACb,GAAGY,eAAe;oBACpB,CAAA;YACF;QAEJ;QACAE,IAAI;YACFT,MAAM,IAAIpB,YACR,IAAID,uBAAuB;gBACzBU,MAAM,GAAGiB,UAAU,SAAS,CAAC;gBAC7BhB,QAAQ,IAAO,CAAA;wBACb,GAAGK,UAAU;wBACb,GAAGY,eAAe;oBACpB,CAAA;YACF;QAEJ;IACF;IAEA,OAAO,IAAI5B,uBAAuB;QAChCU,MAAM,GAAGiB,UAAU,MAAM,CAAC;QAC1BhB,QAAQ;YACN,GAAGK,UAAU;YACb,GAAGY,eAAe;QACpB;IACF;AACF,EAAC"}