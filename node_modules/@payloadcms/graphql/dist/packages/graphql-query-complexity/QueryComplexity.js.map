{"version":3,"sources":["../../../src/packages/graphql-query-complexity/QueryComplexity.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n/**\n * Created by Ivo Mei√üner on 28.07.17.\n */\n\nimport type {\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  GraphQLCompositeType,\n  GraphQLDirective,\n  GraphQLField,\n  GraphQLFieldMap,\n  GraphQLNamedType,\n  GraphQLSchema,\n  GraphQLUnionType,\n  InlineFragmentNode,\n  OperationDefinitionNode,\n} from 'graphql'\n\nimport {\n  getNamedType,\n  GraphQLError,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  isAbstractType,\n  isCompositeType,\n  Kind,\n  TypeInfo,\n  ValidationContext,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql'\nimport {\n  getArgumentValues,\n  getDirectiveValues,\n  getVariableValues,\n} from 'graphql/execution/values.js'\n\nexport type ComplexityEstimatorArgs = {\n  args: { [key: string]: any }\n  childComplexity: number\n  context?: Record<string, any>\n  field: GraphQLField<any, any>\n  node: FieldNode\n  type: GraphQLCompositeType\n}\n\nexport type ComplexityEstimator = (options: ComplexityEstimatorArgs) => number | void\n\n// Complexity can be anything that is supported by the configured estimators\nexport type Complexity = any\n\n// Map of complexities for possible types (of Union, Interface types)\ntype ComplexityMap = {\n  [typeName: string]: number\n}\n\nexport interface QueryComplexityOptions {\n  // Pass request context to the estimators via estimationContext\n  context?: Record<string, any>\n\n  // The query variables. This is needed because the variables are not available\n  // Optional function to create a custom error\n  createError?: (max: number, actual: number) => GraphQLError\n\n  // An array of complexity estimators to use for estimating the complexity\n  estimators: Array<ComplexityEstimator>\n\n  // Optional callback function to retrieve the determined query complexity\n  // Will be invoked whether the query is rejected or not\n  // The maximum allowed query complexity, queries above this threshold will be rejected\n  maximumComplexity: number\n\n  // This can be used for logging or to implement rate limiting\n  onComplete?: (complexity: number) => void\n\n  // specify operation name only when pass multi-operation documents\n  operationName?: string\n\n  // in the visitor of the graphql-js library\n  variables?: Record<string, any>\n}\n\nfunction queryComplexityMessage(max: number, actual: number): string {\n  return `The query exceeds the maximum complexity of ${max}. ` + `Actual complexity is ${actual}`\n}\n\nexport function getComplexity(options: {\n  context?: Record<string, any>\n  estimators: ComplexityEstimator[]\n  operationName?: string\n  query: DocumentNode\n  schema: GraphQLSchema\n  variables?: Record<string, any>\n}): number {\n  const typeInfo = new TypeInfo(options.schema)\n\n  const errors: GraphQLError[] = []\n  const context = new ValidationContext(options.schema, options.query, typeInfo, (error) =>\n    errors.push(error),\n  )\n  const visitor = new QueryComplexity(context, {\n    // Maximum complexity does not matter since we're only interested in the calculated complexity.\n    context: options.context,\n    estimators: options.estimators,\n    maximumComplexity: Infinity,\n    operationName: options.operationName,\n    variables: options.variables,\n  })\n\n  visit(options.query, visitWithTypeInfo(typeInfo, visitor))\n\n  // Throw first error if any\n  if (errors.length) {\n    throw errors.pop()\n  }\n\n  return visitor.complexity\n}\n\nexport class QueryComplexity {\n  complexity: number\n  context: ValidationContext\n  estimators: Array<ComplexityEstimator>\n  includeDirectiveDef: GraphQLDirective\n  OperationDefinition: Record<string, any>\n  options: QueryComplexityOptions\n  requestContext?: Record<string, any>\n  skipDirectiveDef: GraphQLDirective\n  variableValues: Record<string, any>\n\n  constructor(context: ValidationContext, options: QueryComplexityOptions) {\n    if (!(typeof options.maximumComplexity === 'number' && options.maximumComplexity > 0)) {\n      throw new Error('Maximum query complexity must be a positive number')\n    }\n\n    this.context = context\n    this.complexity = 0\n    this.options = options\n\n    this.includeDirectiveDef = this.context.getSchema().getDirective('include')\n    this.skipDirectiveDef = this.context.getSchema().getDirective('skip')\n    this.estimators = options.estimators\n    this.variableValues = {}\n    this.requestContext = options.context\n\n    this.OperationDefinition = {\n      enter: this.onOperationDefinitionEnter,\n      leave: this.onOperationDefinitionLeave,\n    }\n  }\n\n  createError(): GraphQLError {\n    if (typeof this.options.createError === 'function') {\n      return this.options.createError(this.options.maximumComplexity, this.complexity)\n    }\n    return new GraphQLError(queryComplexityMessage(this.options.maximumComplexity, this.complexity))\n  }\n\n  nodeComplexity(\n    node: FieldNode | FragmentDefinitionNode | InlineFragmentNode | OperationDefinitionNode,\n    typeDef: GraphQLInterfaceType | GraphQLObjectType | GraphQLUnionType,\n  ): number {\n    if (node.selectionSet) {\n      let fields: GraphQLFieldMap<any, any> = {}\n      if (typeDef instanceof GraphQLObjectType || typeDef instanceof GraphQLInterfaceType) {\n        fields = typeDef.getFields()\n      }\n\n      // Determine all possible types of the current node\n      let possibleTypeNames: string[]\n      if (isAbstractType(typeDef)) {\n        possibleTypeNames = this.context\n          .getSchema()\n          .getPossibleTypes(typeDef)\n          .map((t) => t.name)\n      } else {\n        possibleTypeNames = [typeDef.name]\n      }\n\n      // Collect complexities for all possible types individually\n      const selectionSetComplexities: ComplexityMap = node.selectionSet.selections.reduce(\n        (\n          complexities: ComplexityMap,\n          childNode: FieldNode | FragmentSpreadNode | InlineFragmentNode,\n        ): ComplexityMap => {\n          // let nodeComplexity = 0;\n          let innerComplexities = complexities\n\n          let includeNode = true\n          let skipNode = false\n\n          for (const directive of childNode.directives ?? []) {\n            const directiveName = directive.name.value\n            switch (directiveName) {\n              case 'include': {\n                const values = getDirectiveValues(\n                  this.includeDirectiveDef,\n                  childNode,\n                  this.variableValues || {},\n                )\n                if (typeof values.if === 'boolean') {\n                  includeNode = values.if\n                }\n                break\n              }\n              case 'skip': {\n                const values = getDirectiveValues(\n                  this.skipDirectiveDef,\n                  childNode,\n                  this.variableValues || {},\n                )\n                if (typeof values.if === 'boolean') {\n                  skipNode = values.if\n                }\n                break\n              }\n            }\n          }\n\n          if (!includeNode || skipNode) {\n            return complexities\n          }\n\n          switch (childNode.kind) {\n            case Kind.FIELD: {\n              const field = fields[childNode.name.value]\n              // Invalid field, should be caught by other validation rules\n              if (!field) {\n                break\n              }\n              const fieldType = getNamedType(field.type)\n\n              // Get arguments\n              let args: { [key: string]: any }\n              try {\n                args = getArgumentValues(field, childNode, this.variableValues || {})\n              } catch (e) {\n                this.context.reportError(e)\n                return complexities\n              }\n\n              // Check if we have child complexity\n              let childComplexity = 0\n              if (isCompositeType(fieldType)) {\n                childComplexity = this.nodeComplexity(childNode, fieldType)\n              }\n\n              // Run estimators one after another and return first valid complexity\n              // score\n              const estimatorArgs: ComplexityEstimatorArgs = {\n                type: typeDef,\n                args,\n                childComplexity,\n                context: this.requestContext,\n                field,\n                node: childNode,\n              }\n              const validScore = this.estimators.find((estimator) => {\n                const tmpComplexity = estimator(estimatorArgs)\n\n                if (typeof tmpComplexity === 'number' && !isNaN(tmpComplexity)) {\n                  innerComplexities = addComplexities(\n                    tmpComplexity,\n                    complexities,\n                    possibleTypeNames,\n                  )\n                  return true\n                }\n\n                return false\n              })\n              if (!validScore) {\n                this.context.reportError(\n                  new GraphQLError(\n                    `No complexity could be calculated for field ${typeDef.name}.${field.name}. ` +\n                      'At least one complexity estimator has to return a complexity score.',\n                  ),\n                )\n                return complexities\n              }\n              break\n            }\n            case Kind.FRAGMENT_SPREAD: {\n              const fragment = this.context.getFragment(childNode.name.value)\n              // Unknown fragment, should be caught by other validation rules\n              if (!fragment) {\n                break\n              }\n              const fragmentType = this.context\n                .getSchema()\n                .getType(fragment.typeCondition.name.value)\n              // Invalid fragment type, ignore. Should be caught by other validation rules\n              if (!isCompositeType(fragmentType)) {\n                break\n              }\n              const nodeComplexity = this.nodeComplexity(fragment, fragmentType)\n              if (isAbstractType(fragmentType)) {\n                // Add fragment complexity for all possible types\n                innerComplexities = addComplexities(\n                  nodeComplexity,\n                  complexities,\n                  this.context\n                    .getSchema()\n                    .getPossibleTypes(fragmentType)\n                    .map((t) => t.name),\n                )\n              } else {\n                // Add complexity for object type\n                innerComplexities = addComplexities(nodeComplexity, complexities, [\n                  fragmentType.name,\n                ])\n              }\n              break\n            }\n            case Kind.INLINE_FRAGMENT: {\n              let inlineFragmentType: GraphQLNamedType = typeDef\n              if (childNode.typeCondition && childNode.typeCondition.name) {\n                inlineFragmentType = this.context\n                  .getSchema()\n                  .getType(childNode.typeCondition.name.value)\n                if (!isCompositeType(inlineFragmentType)) {\n                  break\n                }\n              }\n\n              const nodeComplexity = this.nodeComplexity(childNode, inlineFragmentType)\n              if (isAbstractType(inlineFragmentType)) {\n                // Add fragment complexity for all possible types\n                innerComplexities = addComplexities(\n                  nodeComplexity,\n                  complexities,\n                  this.context\n                    .getSchema()\n                    .getPossibleTypes(inlineFragmentType)\n                    .map((t) => t.name),\n                )\n              } else {\n                // Add complexity for object type\n                innerComplexities = addComplexities(nodeComplexity, complexities, [\n                  inlineFragmentType.name,\n                ])\n              }\n              break\n            }\n            default: {\n              innerComplexities = addComplexities(\n                this.nodeComplexity(childNode, typeDef),\n                complexities,\n                possibleTypeNames,\n              )\n              break\n            }\n          }\n\n          return innerComplexities\n        },\n        {},\n      )\n      // Only return max complexity of all possible types\n      if (!selectionSetComplexities) {\n        return NaN\n      }\n      return Math.max(...Object.values(selectionSetComplexities), 0)\n    }\n    return 0\n  }\n\n  onOperationDefinitionEnter(operation: OperationDefinitionNode): void {\n    if (\n      typeof this.options.operationName === 'string' &&\n      this.options.operationName !== operation.name.value\n    ) {\n      return\n    }\n\n    // Get variable values from variables that are passed from options, merged\n    // with default values defined in the operation\n    const { coerced, errors } = getVariableValues(\n      this.context.getSchema(),\n      // We have to create a new array here because input argument is not readonly in graphql ~14.6.0\n      operation.variableDefinitions ? [...operation.variableDefinitions] : [],\n      this.options.variables ?? {},\n    )\n    if (errors && errors.length) {\n      // We have input validation errors, report errors and abort\n      errors.forEach((error) => this.context.reportError(error))\n      return\n    }\n    this.variableValues = coerced\n\n    switch (operation.operation) {\n      case 'mutation':\n        this.complexity += this.nodeComplexity(\n          operation,\n          this.context.getSchema().getMutationType(),\n        )\n        break\n      case 'query':\n        this.complexity += this.nodeComplexity(operation, this.context.getSchema().getQueryType())\n        break\n      case 'subscription':\n        this.complexity += this.nodeComplexity(\n          operation,\n          this.context.getSchema().getSubscriptionType(),\n        )\n        break\n      default:\n        throw new Error(\n          `Query complexity could not be calculated for operation of type ${operation.operation}`,\n        )\n    }\n  }\n\n  onOperationDefinitionLeave(operation: OperationDefinitionNode): GraphQLError | void {\n    if (\n      typeof this.options.operationName === 'string' &&\n      this.options.operationName !== operation.name.value\n    ) {\n      return\n    }\n\n    if (this.options.onComplete) {\n      this.options.onComplete(this.complexity)\n    }\n\n    if (this.complexity > this.options.maximumComplexity) {\n      return this.context.reportError(this.createError())\n    }\n  }\n}\n\n/**\n * Adds a complexity to the complexity map for all possible types\n * @param complexity\n * @param complexityMap\n * @param possibleTypes\n */\nfunction addComplexities(\n  complexity: number,\n  complexityMap: ComplexityMap,\n  possibleTypes: string[],\n): ComplexityMap {\n  for (const type of possibleTypes) {\n    if (Object.prototype.hasOwnProperty.call(complexityMap, type)) {\n      complexityMap[type] += complexity\n    } else {\n      complexityMap[type] = complexity\n    }\n  }\n  return complexityMap\n}\n"],"names":["getNamedType","GraphQLError","GraphQLInterfaceType","GraphQLObjectType","isAbstractType","isCompositeType","Kind","TypeInfo","ValidationContext","visit","visitWithTypeInfo","getArgumentValues","getDirectiveValues","getVariableValues","queryComplexityMessage","max","actual","getComplexity","options","typeInfo","schema","errors","context","query","error","push","visitor","QueryComplexity","estimators","maximumComplexity","Infinity","operationName","variables","length","pop","complexity","includeDirectiveDef","OperationDefinition","requestContext","skipDirectiveDef","variableValues","constructor","Error","getSchema","getDirective","enter","onOperationDefinitionEnter","leave","onOperationDefinitionLeave","createError","nodeComplexity","node","typeDef","selectionSet","fields","getFields","possibleTypeNames","getPossibleTypes","map","t","name","selectionSetComplexities","selections","reduce","complexities","childNode","innerComplexities","includeNode","skipNode","directive","directives","directiveName","value","values","if","kind","FIELD","field","fieldType","type","args","e","reportError","childComplexity","estimatorArgs","validScore","find","estimator","tmpComplexity","isNaN","addComplexities","FRAGMENT_SPREAD","fragment","getFragment","fragmentType","getType","typeCondition","INLINE_FRAGMENT","inlineFragmentType","NaN","Math","Object","operation","coerced","variableDefinitions","forEach","getMutationType","getQueryType","getSubscriptionType","onComplete","complexityMap","possibleTypes","prototype","hasOwnProperty","call"],"mappings":"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"}