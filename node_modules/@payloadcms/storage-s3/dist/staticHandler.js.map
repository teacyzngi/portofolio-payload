{"version":3,"sources":["../src/staticHandler.ts"],"sourcesContent":["import type { StaticHandler } from '@payloadcms/plugin-cloud-storage/types'\nimport type { CollectionConfig, PayloadRequest } from 'payload'\nimport type { Readable } from 'stream'\n\nimport * as AWS from '@aws-sdk/client-s3'\nimport { GetObjectCommand } from '@aws-sdk/client-s3'\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'\nimport { getFilePrefix } from '@payloadcms/plugin-cloud-storage/utilities'\nimport path from 'path'\n\nexport type SignedDownloadsConfig =\n  | {\n      /** @default 7200 */\n      expiresIn?: number\n      shouldUseSignedURL?(args: {\n        collection: CollectionConfig\n        filename: string\n        req: PayloadRequest\n      }): boolean | Promise<boolean>\n    }\n  | boolean\n\ninterface Args {\n  bucket: string\n  collection: CollectionConfig\n  getStorageClient: () => AWS.S3\n  signedDownloads?: SignedDownloadsConfig\n}\n\nconst isNodeReadableStream = (body: AWS.GetObjectOutput['Body']): body is Readable => {\n  return (\n    typeof body === 'object' &&\n    body !== null &&\n    'pipe' in body &&\n    typeof body.pipe === 'function' &&\n    'destroy' in body &&\n    typeof body.destroy === 'function'\n  )\n}\n\nconst abortRequestAndDestroyStream = ({\n  abortController,\n  object,\n}: {\n  abortController: AbortController\n  object?: AWS.GetObjectOutput\n}) => {\n  try {\n    abortController.abort()\n  } catch {\n    /* noop */\n  }\n  if (object?.Body && isNodeReadableStream(object.Body)) {\n    object.Body.destroy()\n  }\n}\n\nexport const getHandler = ({\n  bucket,\n  collection,\n  getStorageClient,\n  signedDownloads,\n}: Args): StaticHandler => {\n  return async (req, { headers: incomingHeaders, params: { clientUploadContext, filename } }) => {\n    let object: AWS.GetObjectOutput | undefined = undefined\n    let streamed = false\n\n    const abortController = new AbortController()\n    if (req.signal) {\n      req.signal.addEventListener('abort', () => {\n        abortRequestAndDestroyStream({ abortController, object })\n      })\n    }\n\n    try {\n      const prefix = await getFilePrefix({ clientUploadContext, collection, filename, req })\n\n      const key = path.posix.join(prefix, filename)\n\n      if (signedDownloads && !clientUploadContext) {\n        let useSignedURL = true\n        if (\n          typeof signedDownloads === 'object' &&\n          typeof signedDownloads.shouldUseSignedURL === 'function'\n        ) {\n          useSignedURL = await signedDownloads.shouldUseSignedURL({ collection, filename, req })\n        }\n\n        if (useSignedURL) {\n          const command = new GetObjectCommand({ Bucket: bucket, Key: key })\n          const signedUrl = await getSignedUrl(\n            // @ts-expect-error mismatch versions\n            getStorageClient(),\n            command,\n            typeof signedDownloads === 'object' ? signedDownloads : { expiresIn: 7200 },\n          )\n          return Response.redirect(signedUrl, 302)\n        }\n      }\n\n      object = await getStorageClient().getObject(\n        {\n          Bucket: bucket,\n          Key: key,\n        },\n        { abortSignal: abortController.signal },\n      )\n\n      if (!object.Body) {\n        return new Response(null, { status: 404, statusText: 'Not Found' })\n      }\n\n      let headers = new Headers(incomingHeaders)\n\n      // Only include Content-Length when itâ€™s present and strictly numeric.\n      // This prevents \"Parse Error: Invalid character in Content-Length\" when providers (e.g., MinIO)\n      // return undefined or a non-numeric value.\n      const contentLength = String(object.ContentLength);\n      if (contentLength && !isNaN(Number(contentLength))) {\n        headers.append('Content-Length', contentLength);\n      }\n\n      headers.append('Content-Type', String(object.ContentType))\n      headers.append('Accept-Ranges', String(object.AcceptRanges))\n      headers.append('ETag', String(object.ETag))\n\n      const etagFromHeaders = req.headers.get('etag') || req.headers.get('if-none-match')\n      const objectEtag = object.ETag\n\n      if (\n        collection.upload &&\n        typeof collection.upload === 'object' &&\n        typeof collection.upload.modifyResponseHeaders === 'function'\n      ) {\n        headers = collection.upload.modifyResponseHeaders({ headers }) || headers\n      }\n\n      if (etagFromHeaders && etagFromHeaders === objectEtag) {\n        return new Response(null, {\n          headers,\n          status: 304,\n        })\n      }\n\n      if (!isNodeReadableStream(object.Body)) {\n        req.payload.logger.error({\n          key,\n          msg: 'S3 object body is not a readable stream',\n        })\n        return new Response('Internal Server Error', { status: 500 })\n      }\n\n      const stream = object.Body\n      stream.on('error', (err) => {\n        req.payload.logger.error({\n          err,\n          key,\n          msg: 'Error while streaming S3 object (aborting)',\n        })\n        abortRequestAndDestroyStream({ abortController, object })\n      })\n\n      streamed = true\n      return new Response(stream, { headers, status: 200 })\n    } catch (err) {\n      if (err instanceof AWS.NoSuchKey) {\n        return new Response(null, { status: 404, statusText: 'Not Found' })\n      }\n      req.payload.logger.error(err)\n      return new Response('Internal Server Error', { status: 500 })\n    } finally {\n      if (!streamed) {\n        abortRequestAndDestroyStream({ abortController, object })\n      }\n    }\n  }\n}\n"],"names":["AWS","GetObjectCommand","getSignedUrl","getFilePrefix","path","isNodeReadableStream","body","pipe","destroy","abortRequestAndDestroyStream","abortController","object","abort","Body","getHandler","bucket","collection","getStorageClient","signedDownloads","req","headers","incomingHeaders","params","clientUploadContext","filename","undefined","streamed","AbortController","signal","addEventListener","prefix","key","posix","join","useSignedURL","shouldUseSignedURL","command","Bucket","Key","signedUrl","expiresIn","Response","redirect","getObject","abortSignal","status","statusText","Headers","contentLength","String","ContentLength","isNaN","Number","append","ContentType","AcceptRanges","ETag","etagFromHeaders","get","objectEtag","upload","modifyResponseHeaders","payload","logger","error","msg","stream","on","err","NoSuchKey"],"mappings":"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"}