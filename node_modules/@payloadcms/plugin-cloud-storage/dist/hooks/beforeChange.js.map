{"version":3,"sources":["../../src/hooks/beforeChange.ts"],"sourcesContent":["import type { CollectionBeforeChangeHook, CollectionConfig, FileData, TypeWithID } from 'payload'\n\nimport type { GeneratedAdapter } from '../types.js'\n\nimport { getIncomingFiles } from '../utilities/getIncomingFiles.js'\n\ninterface Args {\n  adapter: GeneratedAdapter\n  collection: CollectionConfig\n}\n\nexport const getBeforeChangeHook =\n  ({ adapter, collection }: Args): CollectionBeforeChangeHook<FileData & TypeWithID> =>\n  async ({ data, originalDoc, req }) => {\n    try {\n      const files = getIncomingFiles({ data, req })\n\n      if (files.length > 0) {\n        // If there is an original doc,\n        // And we have new files,\n        // We need to delete the old files before uploading new\n        if (originalDoc) {\n          let filesToDelete: string[] = []\n\n          if (typeof originalDoc?.filename === 'string') {\n            filesToDelete.push(originalDoc.filename)\n          }\n\n          if (typeof originalDoc.sizes === 'object') {\n            filesToDelete = filesToDelete.concat(\n              Object.values(originalDoc?.sizes || []).map(\n                (resizedFileData) => resizedFileData?.filename as string,\n              ),\n            )\n          }\n\n          const deletionPromises = filesToDelete.map(async (filename) => {\n            if (filename) {\n              await adapter.handleDelete({ collection, doc: originalDoc, filename, req })\n            }\n          })\n\n          await Promise.all(deletionPromises)\n        }\n\n        const promises = files.map(async (file) => {\n          await adapter.handleUpload({\n            clientUploadContext: file.clientUploadContext,\n            collection,\n            data,\n            file,\n            req,\n          })\n        })\n\n        await Promise.all(promises)\n      }\n    } catch (err: unknown) {\n      req.payload.logger.error(\n        `There was an error while uploading files corresponding to the collection ${collection.slug} with filename ${data.filename}:`,\n      )\n      req.payload.logger.error({ err })\n      throw err\n    }\n    return data\n  }\n"],"names":["getIncomingFiles","getBeforeChangeHook","adapter","collection","data","originalDoc","req","files","length","filesToDelete","filename","push","sizes","concat","Object","values","map","resizedFileData","deletionPromises","handleDelete","doc","Promise","all","promises","file","handleUpload","clientUploadContext","err","payload","logger","error","slug"],"mappings":"AAIA,SAASA,gBAAgB,QAAQ,mCAAkC;AAOnE,OAAO,MAAMC,sBACX,CAAC,EAAEC,OAAO,EAAEC,UAAU,EAAQ,GAC9B,OAAO,EAAEC,IAAI,EAAEC,WAAW,EAAEC,GAAG,EAAE;QAC/B,IAAI;YACF,MAAMC,QAAQP,iBAAiB;gBAAEI;gBAAME;YAAI;YAE3C,IAAIC,MAAMC,MAAM,GAAG,GAAG;gBACpB,+BAA+B;gBAC/B,yBAAyB;gBACzB,uDAAuD;gBACvD,IAAIH,aAAa;oBACf,IAAII,gBAA0B,EAAE;oBAEhC,IAAI,OAAOJ,aAAaK,aAAa,UAAU;wBAC7CD,cAAcE,IAAI,CAACN,YAAYK,QAAQ;oBACzC;oBAEA,IAAI,OAAOL,YAAYO,KAAK,KAAK,UAAU;wBACzCH,gBAAgBA,cAAcI,MAAM,CAClCC,OAAOC,MAAM,CAACV,aAAaO,SAAS,EAAE,EAAEI,GAAG,CACzC,CAACC,kBAAoBA,iBAAiBP;oBAG5C;oBAEA,MAAMQ,mBAAmBT,cAAcO,GAAG,CAAC,OAAON;wBAChD,IAAIA,UAAU;4BACZ,MAAMR,QAAQiB,YAAY,CAAC;gCAAEhB;gCAAYiB,KAAKf;gCAAaK;gCAAUJ;4BAAI;wBAC3E;oBACF;oBAEA,MAAMe,QAAQC,GAAG,CAACJ;gBACpB;gBAEA,MAAMK,WAAWhB,MAAMS,GAAG,CAAC,OAAOQ;oBAChC,MAAMtB,QAAQuB,YAAY,CAAC;wBACzBC,qBAAqBF,KAAKE,mBAAmB;wBAC7CvB;wBACAC;wBACAoB;wBACAlB;oBACF;gBACF;gBAEA,MAAMe,QAAQC,GAAG,CAACC;YACpB;QACF,EAAE,OAAOI,KAAc;YACrBrB,IAAIsB,OAAO,CAACC,MAAM,CAACC,KAAK,CACtB,CAAC,yEAAyE,EAAE3B,WAAW4B,IAAI,CAAC,eAAe,EAAE3B,KAAKM,QAAQ,CAAC,CAAC,CAAC;YAE/HJ,IAAIsB,OAAO,CAACC,MAAM,CAACC,KAAK,CAAC;gBAAEH;YAAI;YAC/B,MAAMA;QACR;QACA,OAAOvB;IACT,EAAC"}